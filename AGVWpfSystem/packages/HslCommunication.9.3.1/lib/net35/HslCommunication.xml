<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HslCommunication</name>
    </assembly>
    <members>
        <member name="T:HslCommunication.Algorithms.ConnectPool.ConnectPool`1">
            <summary>
            一个连接池管理器，负责维护多个可用的连接，并且自动清理，扩容
            </summary>
            <typeparam name="TConnector">管理的连接类，需要支持IConnector接口</typeparam>
            <remarks>
            需要先实现 <see cref="T:HslCommunication.Algorithms.ConnectPool.IConnector"/> 接口的对象，然后就可以实现真正的连接池了，理论上可以实现任意的连接对象，包括modbus连接对象，各种PLC连接对象，数据库连接对象，redis连接对象，SimplifyNet连接对象等等。下面的示例就是modbus-tcp的实现
            <note type="warning">要想真正的支持连接池访问，还需要服务器支持一个端口的多连接操作，三菱PLC的端口就不支持，如果要测试示例代码的连接池对象，需要使用本组件的<see cref="T:HslCommunication.ModBus.ModbusTcpServer"/>来创建服务器对象</note>
            </remarks>
            <example>
            下面举例实现一个modbus的连接池对象，先实现接口化的操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            然后就可以实现真正的连接池了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="ConnectPoolExample" title="ConnectPool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.#ctor(System.Func{`0})">
            <summary>
            实例化一个连接池对象，需要指定如果创建新实例的方法
            </summary>
            <param name="createConnector">创建连接对象的委托</param>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.GetAvailableConnector">
            <summary>
            获取可用的对象
            </summary>
            <returns>可用的连接对象</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ReturnConnector(`0)">
            <summary>
            使用完之后需要通知管理器
            </summary>
            <param name="connector">连接对象</param>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.MaxConnector">
            <summary>
            获取或设置最大的连接数
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.ConectionExpireTime">
            <summary>
            获取或设置连接过期的时间，单位秒，默认30秒
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.ConnectPool`1.UsedConnector">
            <summary>
            当前已经使用的连接数
            </summary>
        </member>
        <member name="T:HslCommunication.Algorithms.ConnectPool.IConnector">
            <summary>
            连接池的接口，连接池的管理对象必须实现此接口
            </summary>
            <remarks>为了使用完整的连接池功能，需要先实现本接口，然后配合<see cref="T:HslCommunication.Algorithms.ConnectPool.ConnectPool`1"/>来使用</remarks>
            <example>
            下面举例实现一个modbus的连接池对象
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Algorithms\ConnectPool.cs" region="IConnector Example" title="IConnector示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.IsConnectUsing">
            <summary>
            指示当前的连接是否在使用用
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.GuidToken">
            <summary>
            唯一的GUID码
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.ConnectPool.IConnector.LastUseTime">
            <summary>
            最新一次使用的时间
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.IConnector.Open">
            <summary>
            打开连接
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.ConnectPool.IConnector.Close">
            <summary>
            关闭并释放
            </summary>
        </member>
        <member name="T:HslCommunication.Algorithms.Fourier.FFTFilter">
            <summary>
            一个基于傅立叶变换的一个滤波算法
            </summary>
            <remarks>
            非常感谢来自北京的monk网友，提供了完整的解决方法。
            </remarks>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FillDataArray``1(System.Collections.Generic.List{``0},System.Int32@)">
            <summary>
            对指定的数据进行填充，方便的进行傅立叶计算
            </summary>
            <typeparam name="T">数据的数据类型</typeparam>
            <param name="source">数据源</param>
            <param name="putLength">输出的长度</param>
            <returns>填充结果</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FilterFFT(System.Double[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.FilterFFT(System.Single[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.Filter(System.Single[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTFilter.Filter(System.Double[],System.Double)">
            <summary>
            对指定的原始数据进行滤波，并返回成功的数据值
            </summary>
            <param name="source">数据源，数组的长度需要为2的n次方。</param>
            <param name="filter">滤波值：最大值为1，不能低于0，越接近1，滤波强度越强，也可能会导致失去真实信号，为0时没有滤波效果。</param>
            <returns>滤波后的数据值</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.Fourier.FFTHelper">
            <summary>
            离散傅氏变换的快速算法，处理的信号，适合单周期信号数为2的N次方个，支持变换及逆变换
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.bitrp(System.Double[],System.Double[],System.Int32)">
            <summary>
            
            </summary>
            <param name="xreal"></param>
            <param name="ximag"></param>
            <param name="n"></param>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.GetFFTImage(System.Double[],System.Int32,System.Int32,System.Drawing.Color,System.Boolean)">
            <summary>
            获取FFT变换后的显示图形，需要指定图形的相关参数
            </summary>
            <param name="xreal">实数部分的值</param>
            <param name="width">图形的宽度</param>
            <param name="heigh">图形的高度</param>
            <param name="lineColor">线条颜色</param>
            <param name="isSqrtDouble">是否开两次根，显示的噪点信息会更新明显</param>
            <returns>等待呈现的图形</returns>
            <remarks>
            <note type="warning">.net standrard2.0 下不支持。</note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFTValue(System.Double[],System.Double[],System.Boolean)">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <param name="isSqrtDouble">是否开两次根，显示的噪点信息会更新明显</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.FFT(System.Single[],System.Single[])">
            <summary>
            快速傅立叶变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>变换后的数组值</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.IFFT(System.Single[],System.Single[])">
            <summary>
            快速傅立叶变换的逆变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>2的多少次方</returns>
        </member>
        <member name="M:HslCommunication.Algorithms.Fourier.FFTHelper.IFFT(System.Double[],System.Double[])">
            <summary>
            快速傅立叶变换的逆变换
            </summary>
            <param name="xreal">实数部分，数组长度最好为2的n次方</param>
            <param name="ximag">虚数部分，数组长度最好为2的n次方</param>
            <returns>2的多少次方</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.PID.PIDHelper">
            <summary>
            一个PID的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.PidInit">
            <summary>
            初始化PID的数据信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Kp">
            <summary>
            -rando
            比例的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Ki">
            <summary>
            积分的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.Kd">
            <summary>
            微分的参数信息
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.DeadBand">
            <summary>
            获取或设置死区的值
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.MaxLimit">
            <summary>
            获取或设置输出的上限，默认为没有设置
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.MinLimit">
            <summary>
            获取或设置输出的下限，默认为没有设置
            </summary>
        </member>
        <member name="P:HslCommunication.Algorithms.PID.PIDHelper.SetValue">
            <summary>
            获取或设置当前设置的值
            </summary>
        </member>
        <member name="M:HslCommunication.Algorithms.PID.PIDHelper.PidCalculate">
            <summary>
            计算Pid数据的值
            </summary>
            <returns>计算值</returns>
        </member>
        <member name="T:HslCommunication.Algorithms.PID.PidMode">
            <summary>
            Pid的模式选择
            </summary>
        </member>
        <member name="F:HslCommunication.Algorithms.PID.PidMode.Increment">
            <summary>
            增量模式
            </summary>
        </member>
        <member name="T:HslCommunication.Authorization">
            <summary>
            系统的基本授权类
            </summary>
        </member>
        <member name="M:HslCommunication.Authorization.SetAuthorizationCode(System.String)">
            <summary>
            设置本组件系统的授权信息，如果激活失败，只能使用8小时，8小时后所有的网络通信不会成功<br />
            Set the authorization information of this component system. If the activation fails, it can only be used for 8 hours. All network communication will not succeed after 8 hours
            </summary>
            <param name="code">授权码</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormAuthorize">
            <summary>
            用来测试版软件授权的窗口
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.#ctor(HslCommunication.BasicFramework.SoftAuthorize,System.String,System.Func{System.String,System.String})">
            <summary>
            实例化授权注册窗口
            </summary>
            <param name="authorize"></param>
            <param name="aboutCode">提示关于怎么获取注册码的信息</param>
            <param name="encrypt">加密的方法</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormAuthorize.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormAuthorize.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormPopup">
            <summary>
            一个用于消息弹出显示的类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.AddNewForm(HslCommunication.BasicFramework.FormPopup)">
            <summary>
            新增一个显示的弹出窗口
            </summary>
            <param name="form"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.ResetLocation">
            <summary>
            重置所有弹出窗口的位置
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.#ctor(System.String,System.Drawing.Color,System.Int32)">
            <summary>
            实例化一个窗口信息弹出的对象
            </summary>
            <param name="infotext">需要显示的文本</param>
            <param name="infocolor">文本的颜色</param>
            <param name="existTime">指定窗口多少时间后消失，单位毫秒</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.LocationUpMove">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.LocationUpMove(System.Int32)">
            <summary>
            窗体的位置进行向上调整
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormPopup.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPopup.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormPortraitSelect">
            <summary>
            一个正方形图形选择窗口，可以获取指定的分辨率
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.HasPicture">
            <summary>
            是否有图片存在
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.RectangleSelected">
            <summary>
            已选择的图形大小
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.FormPortraitSelect.RectangleImage">
            <summary>
            在控件显示的图片的大小，按照比例缩放以后
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.LoadPictureFile(System.String)">
            <summary>
            增加一张图片的路径
            </summary>
            <param name="picPath"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.GetSpecifiedSizeImage(System.Int32)">
            <summary>
            获取指定大小的图片，该图片将会按照比例压缩
            </summary>
            <param name="size">图片的横向分辨率</param>
            <returns>缩放后的图形</returns>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormPortraitSelect.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormPortraitSelect.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.FormSupport">
            <summary>
            作者的技术支持的窗口界面
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.#ctor">
            <summary>
            实例化一个默认的界面
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.FormSupport.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.FormSupport.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SharpList`1">
            <summary>
            一个高效的数组管理类，用于高效控制固定长度的数组实现<br />
            An efficient array management class for efficient control of fixed-length array implementations
            </summary>
            <typeparam name="T">泛型类型</typeparam>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            实例化一个对象，需要指定数组的最大数据对象
            </summary>
            <param name="count">数据的个数</param>
            <param name="appendLast">是否从最后一个数添加</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SharpList`1.Count">
            <summary>
            获取数组的个数<br />
            Get the number of arrays
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.Add(`0)">
            <summary>
            新增一个数据值<br />
            Add a data value
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            批量的增加数据<br />
            Increase data in batches
            </summary>
            <param name="values">批量数据信息</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.ToArray">
            <summary>
            获取数据的数组值<br />
            Get array value of data
            </summary>
            <returns>数组值</returns>
        </member>
        <member name="P:HslCommunication.BasicFramework.SharpList`1.Item(System.Int32)">
            <summary>
            获取或设置指定索引的位置的数据<br />
            Gets or sets the data at the specified index
            </summary>
            <param name="index">索引位置</param>
            <returns>数据值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SharpList`1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAnimation">
            <summary>
            系统框架支持的一些常用的动画特效
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAnimation.TimeFragment">
            <summary>
            最小的时间片段
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAnimation.BeginBackcolorAnimation(System.Windows.Forms.Control,System.Drawing.Color,System.Int32)">
            <summary>
            调整控件背景色，采用了线性的颜色插补方式，实现了控件的背景色渐变，需要指定控件，颜色，以及渐变的时间
            </summary>
            <param name="control">控件</param>
            <param name="color">设置的颜色</param>
            <param name="time">时间</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAuthorize">
            <summary>
            软件授权类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.#ctor(System.Boolean)">
            <summary>
            实例化一个软件授权类
            </summary>
            <param name="UseAdmin">是否使用管理员模式</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.TextCode">
            <summary>
            注册码描述文本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.FinalCode">
            <summary>
            最终的注册秘钥信息，注意是只读的。
            </summary>
            <remarks>
            时间：2018年9月1日 23:01:54，来自 洛阳-LYG 的建议，公开了本属性信息，只读。
            </remarks>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.IsReleaseVersion">
            <summary>
            是否正式发行版，是的话就取消授权
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.HasLoadByFile">
            <summary>
            指示是否加载过文件信息
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftAuthorize.IsSoftTrial">
            <summary>
            指示系统是否处于试用运行
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetMachineCodeString">
            <summary>
            获取本机的机器码
            </summary>
            <returns>机器码字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.ToSaveString">
            <summary>
            获取需要保存的数据内容
            </summary>
            <returns>实际保存的内容</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.LoadByString(System.String)">
            <summary>
            从字符串加载数据
            </summary>
            <param name="content">文件存储的数据</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.SaveToFile">
            <summary>
            使用特殊加密算法加密数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.LoadByFile">
            <summary>
            使用特殊解密算法解密数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CheckAuthorize(System.String,System.Func{System.String,System.String})">
            <summary>
            检查该注册码是否是正确的注册码
            </summary>
            <param name="code">注册码信息</param>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否注册成功</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.IsAuthorizeSuccess(System.Func{System.String,System.String})">
            <summary>
            检测授权是否成功
            </summary>
            <param name="encrypt">数据加密的方法，必须用户指定</param>
            <returns>是否成功授权</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetInfo(System.Boolean)">
            <summary>
            获取本计算机唯一的机器码  
            </summary>
            <returns>字符串形式的机器码</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.GetHddInfo(System.Byte)">
            <summary>
            获得硬盘信息
            </summary>
            <param name="driveIndex">硬盘序号</param>
            <returns>硬盘信息</returns>
            <remarks>
            by sunmast for everyone
            thanks lu0 for his great works
            在Windows Array8/ME中，S.M.A.R.T并不缺省安装，请将SMARTVSD.VXD拷贝到%SYSTEM%＼IOSUBSYS目录下。
            在Windows 2000/2003下，需要Administrators组的权限。
            </remarks>
            <example>
            AtapiDevice.GetHddInfo()
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CreateFile(System.String,System.IO.FileAccess,System.IO.FileShare,System.IntPtr,System.IO.FileMode,System.IO.FileAttributes,System.IntPtr)">
            <summary>
            执行打开/建立资源的功能。
            </summary>
            <param name="lpFileName">指定要打开的设备或文件的名称。</param>
            <param name="dwDesiredAccess">
            <para>Win32 常量，用于控制对设备的读访问、写访问或读/写访问的常数。内容如下表：
            <p><list type="table">
            <listheader>
            <term>名称</term>
            <description>说明</description>
            </listheader>
            <item>
            <term>GENERIC_READ</term><description>指定对设备进行读取访问。</description>
            </item>
            <item>
            <term>GENERIC_WRITE</term><description>指定对设备进行写访问。</description>
            </item>
            <item><term><b>0</b></term><description>如果值为零，则表示只允许获取与一个设备有关的信息。</description></item>
            </list></p>
            </para>
            </param>
            <param name="dwShareMode">指定打开设备时的文件共享模式</param>
            <param name="lpSecurityAttributes"></param>
            <param name="dwCreationDisposition">Win32 常量，指定操作系统打开文件的方式。内容如下表：
            <para><p>
            <list type="table">
            <listheader><term>名称</term><description>说明</description></listheader>
            <item>
            <term>CREATE_NEW</term>
            <description>指定操作系统应创建新文件。如果文件存在，则抛出 <see cref="T:System.IO.IOException"/> 异常。</description>
            </item>
            <item><term>CREATE_ALWAYS</term><description>指定操作系统应创建新文件。如果文件已存在，它将被改写。</description></item>
            </list>
            </p></para>
            </param>
            <param name="dwFlagsAndAttributes"></param>
            <param name="hTemplateFile"></param>
            <returns>使用函数打开的设备的句柄。</returns>
            <remarks>
            本函数可以执行打开或建立文件、文件流、目录/文件夹、物理磁盘、卷、系统控制的缓冲区、磁带设备、
            通信资源、邮件系统和命名管道。
            </remarks>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.CloseHandle(System.IntPtr)">
            <summary>
            关闭一个指定的指针对象指向的设备。。
            </summary>
            <param name="hObject">要关闭的句柄 <see cref="T:System.IntPtr"/> 对象。</param>
            <returns>成功返回 <b>0</b> ，不成功返回非零值。</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,System.IntPtr,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.GetVersionOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_GET_VERSION</b> 。</param>
            <param name="lpInBuffer">当参数为指针时，默认的输入值是 <b>0</b> 。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>GetVersionOutParams</b> ，表示执行函数后输出的设备检查。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftAuthorize.DeviceIoControl(System.IntPtr,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.SendCmdInParams@,System.UInt32,HslCommunication.BasicFramework.SoftAuthorize.SendCmdOutParams@,System.UInt32,System.UInt32@,System.IntPtr)">
            <summary>
            对设备执行指定的操作。
            </summary>
            <param name="hDevice">要执行操作的设备句柄。</param>
            <param name="dwIoControlCode">Win32 API 常数，输入的是以 <b>FSCTL_</b> 为前缀的常数，定义在
            <b>WinIoCtl.h</b> 文件内，执行此重载方法必须输入 <b>SMART_SEND_DRIVE_COMMAND</b> 或 <b>SMART_RCV_DRIVE_DATA</b> 。</param>
            <param name="lpInBuffer">一个 <b>SendCmdInParams</b> 结构，它保存向系统发送的查询要求具体命令的数据结构。</param>
            <param name="nInBufferSize">输入缓冲区的字节数量。</param>
            <param name="lpOutBuffer">一个 <b>SendCmdOutParams</b> 结构，它保存系统根据命令返回的设备相信信息二进制数据。</param>
            <param name="nOutBufferSize">输出缓冲区的字节数量。</param>
            <param name="lpBytesReturned">实际装载到输出缓冲区的字节数量。</param>
            <param name="lpOverlapped">同步操作控制，一般不使用，默认值为 <b>0</b> 。</param>
            <returns>非零表示成功，零表示失败。</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo">
            <summary>
            硬盘信息
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.ModuleNumber">
            <summary>
            型号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.Firmware">
            <summary>
            固件版本
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.SerialNumber">
            <summary>
            序列号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftAuthorize.HardDiskInfo.Capacity">
            <summary>
            容量，以M为单位
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.ISoftFileSaveBase">
            <summary>
            支持字符串信息加载存储的接口，定义了几个通用的方法
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.ToSaveString">
            <summary>
            获取需要保存的数据，需要重写实现
            </summary>
            <returns>需要存储的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByString(System.String)">
            <summary>
            从字符串加载数据，需要重写实现
            </summary>
            <param name="content">字符串数据</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByFile">
            <summary>
            不使用解密方法从文件读取数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISoftFileSaveBase.SaveToFile">
            <summary>
            不使用加密方法保存数据到文件
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.ISoftFileSaveBase.FileSavePath">
            <summary>
            文件路径的存储
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftFileSaveBase">
            <summary>
            文件存储功能的基类，包含了文件存储路径，存储方法等
            </summary>
            <remarks>
            需要继承才能实现你想存储的数据，比较经典的例子就是存储你的应用程序的配置信息，通常的格式就是xml文件或是json文件。具体请看例子：
            </remarks>
            <example>
            下面举例实现两个字段的普通数据存储
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase1" title="简单示例" />
            然后怎么调用呢？
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="Example" title="调用示例" />
            如果你想实现加密存储，这样就不用关心被用户看到了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftFileSaveBaseExample.cs" region="SoftFileSaveBase2" title="加密示例" />
            如果还是担心被反编译获取数据，那么这个密钥就要来自服务器的数据，本地不做存储。
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.#ctor">
            <summary>
            实例化一个文件存储的基类
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.LogHeaderText">
            <summary>
            在日志保存时的标记当前调用类的信息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.ToSaveString">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.ToSaveString"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByString(System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByString(System.String)"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByFile">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.LoadByFile"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.LoadByFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的解密方法从文件读取数据
            </summary>
            <param name="decrypt">用户自定义的解密方法</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.SaveToFile">
            <inheritdoc cref="M:HslCommunication.BasicFramework.ISoftFileSaveBase.SaveToFile"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftFileSaveBase.SaveToFile(System.Converter{System.String,System.String})">
            <summary>
            使用用户自定义的加密方法保存数据到文件
            </summary>
            <param name="encrypt">用户自定义的加密方法</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.FileSavePath">
            <summary>
            文件存储的路径
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftFileSaveBase.ILogNet">
            <summary>
            日志记录类
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftBasic">
            <summary>
            一个软件基础类，提供常用的一些静态方法，比如字符串转换，字节转换的方法<br />
            A software-based class that provides some common static methods，Such as string conversion, byte conversion method
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateFileMD5(System.String)">
            <summary>
            获取文件的md5码<br />
            Get the MD5 code of the file
            </summary>
            <param name="filePath">文件的路径，既可以是完整的路径，也可以是相对的路径 -> The path to the file</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个文件的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateFileMD5Example" title="CalculateFileMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.IO.Stream)">
            <summary>
            获取数据流的md5码<br />
            Get the MD5 code for the data stream
            </summary>
            <param name="stream">数据流，可以是内存流，也可以是文件流</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个流的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example1" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String)">
            <summary>
            获取文本字符串信息的Md5码，编码为UTF8<br />
            Get the Md5 code of the text string information, using the utf-8 encoding
            </summary>
            <param name="data">文本数据信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.String,System.Text.Encoding)">
            <summary>
            获取文本字符串信息的Md5码，使用指定的编码<br />
            Get the Md5 code of the text string information, using the specified encoding
            </summary>
            <param name="data">文本数据信息</param>
            <param name="encode">编码信息</param>
            <returns>Md5字符串</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.CalculateStreamMD5(System.Drawing.Bitmap)">
            <summary>
            获取内存图片的md5码<br />
            Get the MD5 code of the memory picture
            </summary>
            <param name="bitmap">内存图片</param>
            <returns>Md5字符串</returns>
            <example>
            下面举例实现获取一个图像的md5码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="CalculateStreamMD5Example2" title="CalculateStreamMD5示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetSizeDescription(System.Int64)">
            <summary>
            从一个字节大小返回带单位的描述，主要是用于显示操作<br />
            Returns a description with units from a byte size, mainly for display operations
            </summary>
            <param name="size">实际的大小值</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了文件的长度，这个长度可以来自于本地，也可以来自于数据库查询
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetSizeDescriptionExample" title="GetSizeDescription示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetTimeSpanDescription(System.TimeSpan)">
            <summary>
            从一个时间差返回带单位的描述，主要是用于显示操作。<br />
            Returns a description with units from a time difference, mainly for display operations.
            </summary>
            <param name="ts">实际的时间差</param>
            <returns>最终的字符串值</returns>
            <example>
            比如说我们获取了一个时间差信息
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetTimeSpanDescriptionExample" title="GetTimeSpanDescription示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[])">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[],System.String)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <param name="format">格式化的信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0,System.String)">
            <summary>
            将数组格式化为显示的字符串的信息，支持所有的类型对象<br />
            Formats the array into the displayed string information, supporting all types of objects
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">数组信息</param>
            <param name="format">格式化的信息</param>
            <returns>最终显示的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.AddArrayData``1(``0[]@,``0[],System.Int32)">
            <summary>
            一个通用的数组新增个数方法，会自动判断越界情况，越界的情况下，会自动的截断或是填充<br />
            A common array of new methods, will automatically determine the cross-border situation, in the case of cross-border, will be automatically truncated or filled
            </summary>
            <typeparam name="T">数据类型</typeparam>
            <param name="array">原数据</param>
            <param name="data">等待新增的数据</param>
            <param name="max">原数据的最大值</param>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="AddArrayDataExample" title="AddArrayData示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayExpandToLength``1(``0[],System.Int32)">
            <summary>
            将一个数组进行扩充到指定长度，或是缩短到指定长度<br />
            Extend an array to a specified length, or shorten to a specified length or fill
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <param name="length">新数组的长度</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthExample" title="ArrayExpandToLength示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayExpandToLengthEven``1(``0[])">
            <summary>
            将一个数组进行扩充到偶数长度<br />
            Extend an array to even lengths
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="data">原先数据的数据</param>
            <returns>新数组长度信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayExpandToLengthEvenExample" title="ArrayExpandToLengthEven示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySplitByLength``1(``0[],System.Int32)">
            <summary>
            将指定的数据按照指定长度进行分割，例如int[10]，指定长度4，就分割成int[4],int[4],int[2]，然后拼接list<br />
            Divide the specified data according to the specified length, such as int [10], and specify the length of 4 to divide into int [4], int [4], int [2], and then concatenate the list
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">等待分割的数组</param>
            <param name="length">指定的长度信息</param>
            <returns>分割后结果内容</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySplitByLengthExample" title="ArraySplitByLength示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SplitIntegerToArray(System.Int32,System.Int32)">
            <summary>
            将整数进行有效的拆分成数组，指定每个元素的最大值<br />
            Effectively split integers into arrays, specifying the maximum value for each element
            </summary>
            <param name="integer">整数信息</param>
            <param name="everyLength">单个的数组长度</param>
            <returns>拆分后的数组长度</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SplitIntegerToArrayExample" title="SplitIntegerToArray示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            判断两个字节的指定部分是否相同<br />
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="start1">第一个字节的起始位置</param>
            <param name="b2">第二个字节</param>
            <param name="start2">第二个字节的起始位置</param>
            <param name="length">校验的长度</param>
            <returns>返回是否相等</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample1" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoBytesEquel(System.Byte[],System.Byte[])">
            <summary>
            判断两个字节的指定部分是否相同<br />
            Determines whether the specified portion of a two-byte is the same
            </summary>
            <param name="b1">第一个字节</param>
            <param name="b2">第二个字节</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoBytesEquelExample2" title="IsTwoBytesEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsByteTokenEquel(System.Byte[],System.Guid)">
            <summary>
            判断两个数据的令牌是否相等<br />
            Determines whether the tokens of two data are equal
            </summary>
            <param name="head">字节数据</param>
            <param name="token">GUID数据</param>
            <returns>返回是否相等</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="IsTwoTokenEquelExample" title="IsByteTokenEquel示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.IsTwoTokenEquel(System.Guid,System.Guid)">
            <summary>
            判断两个数据的令牌是否相等<br />
            Determines whether the tokens of two data are equal
            </summary>
            <param name="token1">第一个令牌</param>
            <param name="token2">第二个令牌</param>
            <returns>返回是否相等</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetEnumValues``1">
            <summary>
            获取一个枚举类型的所有枚举值，可直接应用于组合框数据<br />
            Gets all the enumeration values of an enumeration type that can be applied directly to the combo box data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <returns>枚举值数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumValuesExample" title="GetEnumValues示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetEnumFromString``1(System.String)">
            <summary>
            从字符串的枚举值数据转换成真实的枚举值数据<br />
            Convert enumeration value data from strings to real enumeration value data
            </summary>
            <typeparam name="TEnum">枚举的类型值</typeparam>
            <param name="value">枚举的字符串的数据值</param>
            <returns>真实的枚举值</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetEnumFromStringExample" title="GetEnumFromString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetValueFromJsonObject``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据读取<br />
            A generic method that provides data read for a JSON object
            </summary>
            <typeparam name="T">读取的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="value_name">值名称</param>
            <param name="default_value">默认值</param>
            <returns>值对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetValueFromJsonObjectExample" title="GetValueFromJsonObject示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.JsonSetValue``1(Newtonsoft.Json.Linq.JObject,System.String,``0)">
            <summary>
            一个泛型方法，提供json对象的数据写入<br />
            A generic method that provides data writing to a JSON object
            </summary>
            <typeparam name="T">写入的泛型</typeparam>
            <param name="json">json对象</param>
            <param name="property">值名称</param>
            <param name="value">值数据</param>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="JsonSetValueExample" title="JsonSetValue示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ShowExceptionMessage(System.Exception)">
            <summary>
            显示一个完整的错误信息<br />
            Displays a complete error message
            </summary>
            <param name="ex">异常对象</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ShowExceptionMessage(System.String,System.Exception)">
            <summary>
            显示一个完整的错误信息，和额外的字符串描述信息<br />
            Displays a complete error message, and additional string description information
            </summary>
            <param name="extraMsg">额外的描述信息</param>
            <remarks>调用本方法可以显示一个异常的详细信息</remarks>
            <param name="ex">异常对象</param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetExceptionMessage(System.Exception)">
            <summary>
            获取一个异常的完整错误信息<br />
            Gets the complete error message for an exception
            </summary>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <remarks>获取异常的完整信息</remarks>
            <exception cref="T:System.NullReferenceException">ex不能为空</exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample1" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetExceptionMessage(System.String,System.Exception)">
            <summary>
            获取一个异常的完整错误信息，和额外的字符串描述信息<br />
            Gets the complete error message for an exception, and additional string description information
            </summary>
            <param name="extraMsg">额外的信息</param>
            <param name="ex">异常对象</param>
            <returns>完整的字符串数据</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetExceptionMessageExample2" title="GetExceptionMessage示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[])">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample1" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char)">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <param name="segment">分割符</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample2" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char,System.Int32)">
            <summary>
            字节数据转化成16进制表示的字符串<br />
            Byte data into a string of 16 binary representations
            </summary>
            <param name="InBytes">字节数组</param>
            <param name="segment">分割符</param>
            <param name="newLineCount">每隔指定数量的时候进行换行</param>
            <returns>返回的字符串</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToHexStringExample2" title="ByteToHexString示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.String)">
            <summary>
            字符串数据转化成16进制表示的字符串<br />
            String data into a string of 16 binary representations
            </summary>
            <param name="InString">输入的字符串数据</param>
            <returns>返回的字符串</returns>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.HexStringToBytes(System.String)">
            <summary>
            将16进制的字符串转化成Byte数据，将检测每2个字符转化，也就是说，中间可以是任意字符<br />
            Converts a 16-character string into byte data, which will detect every 2 characters converted, that is, the middle can be any character
            </summary>
            <param name="hex">十六进制的字符串，中间可以是任意的分隔符</param>
            <returns>转换后的字节数组</returns>
            <remarks>参数举例：AA 01 34 A8</remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="HexStringToBytesExample" title="HexStringToBytes示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BytesReverseByWord(System.Byte[])">
            <summary>
            将byte数组按照双字节进行反转，如果为单数的情况，则自动补齐<br />
            Reverses the byte array by double byte, or if the singular is the case, automatically
            </summary>
            <param name="inBytes">输入的字节信息</param>
            <returns>反转后的数据</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BytesReverseByWord" title="BytesReverseByWord示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BytesToAsciiBytes(System.Byte[])">
            <summary>
            将原始的byte数组转换成ascii格式的byte数组<br />
            Converts the original byte array to an ASCII-formatted byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.AsciiBytesToBytes(System.Byte[])">
            <summary>
            将ascii格式的byte数组转换成原始的byte数组<br />
            Converts an ASCII-formatted byte array to the original byte array
            </summary>
            <param name="inBytes">等待转换的byte数组</param>
            <returns>转换后的数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Byte)">
            <summary>
            从字节构建一个ASCII格式的数据内容<br />
            Build an ASCII-formatted data content from bytes
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Int16)">
            <summary>
            从short构建一个ASCII格式的数据内容<br />
            Constructing an ASCII-formatted data content from a short
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.UInt16)">
            <summary>
            从ushort构建一个ASCII格式的数据内容<br />
            Constructing an ASCII-formatted data content from ushort
            </summary>
            <param name="value">数据</param>
            <returns>ASCII格式的字节数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BuildAsciiBytesFrom(System.Byte[])">
            <summary>
            从字节数组构建一个ASCII格式的数据内容<br />
            Byte array to construct an ASCII format data content
            </summary>
            <param name="value">字节信息</param>
            <returns>ASCII格式的地址</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BoolOnByteIndex(System.Byte,System.Int32)">
            <summary>
            获取byte数据类型的第offset位，是否为True<br />
            Gets the index bit of the byte data type, whether it is True
            </summary>
            <param name="value">byte数值</param>
            <param name="offset">索引位置</param>
            <returns>结果</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BoolOnByteIndex" title="BoolOnByteIndex示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.BoolArrayToByte(System.Boolean[])">
            <summary>
            将bool数组转换到byte数组<br />
            Converting a bool array to a byte array
            </summary>
            <param name="array">bool数组</param>
            <returns>转换后的字节数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="BoolArrayToByte" title="BoolArrayToByte示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[],System.Int32)">
            <summary>
            从Byte数组中提取位数组，length代表位数<br />
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <param name="length">想要转换的长度，如果超出自动会缩小到数组最大长度</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[])">
            <summary>
            从Byte数组中提取所有的位数组<br />
            Extracts a bit array from a byte array, length represents the number of digits
            </summary>
            <param name="InBytes">原先的字节数组</param>
            <returns>转换后的bool数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ByteToBoolArray" title="ByteToBoolArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveDouble``1(``0[],System.Int32,System.Int32)">
            <summary>
            将一个数组的前后移除指定位数，返回新的一个数组<br/>
            Removes a array before and after the specified number of bits, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="leftLength">前面的位数</param>
            <param name="rightLength">后面的位数</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveDouble" title="ArrayRemoveDouble示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveBegin``1(``0[],System.Int32)">
            <summary>
            将一个数组的前面指定位数移除，返回新的一个数组<br />
            Removes the preceding specified number of bits in a array, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveBegin" title="ArrayRemoveBegin示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveLast``1(``0[],System.Int32)">
            <summary>
            将一个数组的后面指定位数移除，返回新的一个数组<br />
            Removes the specified number of digits after a array, returning a new array
            </summary>
            <param name="value">数组</param>
            <param name="length">等待移除的长度</param>
            <returns>新的数组</returns>
            <exception cref="T:System.RankException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArrayRemoveLast" title="ArrayRemoveLast示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectMiddle``1(``0[],System.Int32,System.Int32)">
            <summary>
            获取到数组里面的中间指定长度的数组<br />
            Get an array of the specified length in the array
            </summary>
            <param name="value">数组</param>
            <param name="index">起始索引</param>
            <param name="length">数据的长度</param>
            <returns>新的数组值</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectMiddle" title="ArraySelectMiddle示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectBegin``1(``0[],System.Int32)">
            <summary>
            选择一个数组的前面的几个数据信息<br />
            Select the begin few items of data information of a array
            </summary>
            <param name="value">数组</param>
            <param name="length">数据的长度</param>
            <returns>新的数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectBegin" title="ArraySelectBegin示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectLast``1(``0[],System.Int32)">
            <summary>
            选择一个数组的后面的几个数据信息<br />
            Select the last few items of data information of a array
            </summary>
            <param name="value">数组</param>
            <param name="length">数据的长度</param>
            <returns>新的数组信息</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="ArraySelectLast" title="ArraySelectLast示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceTwoByteArray(System.Byte[],System.Byte[])">
            <summary>
            拼接2个字节数组成一个数组<br />
            Splicing 2 bytes to to an array
            </summary>
            <param name="bytes1">数组一</param>
            <param name="bytes2">数组二</param>
            <returns>拼接后的数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SpliceTwoByteArray" title="SpliceTwoByteArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceByteArray(System.Byte[][])">
            <summary>
            拼接任意个字节数组为一个总的字节数组。<br />
            Concatenate any number of byte arrays into a total byte array.
            </summary>
            <param name="bytes">字节数组</param>
            <returns>拼接后的数组</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="SpliceByteArray" title="SpliceByteArray示例" />
            </example> 
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String[])">
            <summary>
            将一个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine an array of <see cref = "T:System.String" /> and multiple objects of type <see cref = "T:System.String" /> into an array
            </summary>
            <param name="first">第一个数组对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String,System.String[])">
            <summary>
            将两个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine two arrays of <see cref="T:System.String" /> and multiple objects of type <see cref="T:System.String"/> into one array
            </summary>
            <param name="first">第一个数据对象</param>
            <param name="second">第二个数据对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.SpliceStringArray(System.String,System.String,System.String,System.String[])">
            <summary>
            将两个<see cref="T:System.String"/>的数组和多个<see cref="T:System.String"/> 类型的对象整合成一个数组<br />
            Combine two arrays of <see cref="T:System.String" /> and multiple objects of type <see cref="T:System.String"/> into one array
            </summary>
            <param name="first">第一个数据对象</param>
            <param name="second">第二个数据对象</param>
            <param name="third">第三个数据对象</param>
            <param name="array">字符串数组信息</param>
            <returns>总的数组对象</returns>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBasic.FrameworkVersion">
            <summary>
            设置或获取系统框架的版本号<br />
            Set or get the version number of the system framework
            </summary>
            <remarks>
            当你要显示本组件框架的版本号的时候，就可以用这个属性来显示
            </remarks>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.DeepClone(System.Object)">
            <summary>
            使用序列化反序列化深度克隆一个对象，该对象需要支持序列化特性<br />
            Cloning an object with serialization deserialization depth that requires support for serialization attributes
            </summary>
            <param name="oringinal">源对象，支持序列化</param>
            <returns>新的一个实例化的对象</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <exception cref="T:System.NonSerializedAttribute"></exception>
            <remarks>
            <note type="warning">
            <paramref name="oringinal"/> 参数必须实现序列化的特性
            </note>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="DeepClone" title="DeepClone示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBasic.GetUniqueStringByGuidAndRandom">
            <summary>
            获取一串唯一的随机字符串，长度为20，由Guid码和4位数的随机数组成，保证字符串的唯一性<br />
            Gets a string of unique random strings with a length of 20, consisting of a GUID code and a 4-digit random number to guarantee the uniqueness of the string
            </summary>
            <returns>随机字符串数据</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBasicExample.cs" region="GetUniqueStringByGuidAndRandom" title="GetUniqueStringByGuidAndRandom示例" />
            </example>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftBuffer">
            <summary>
            一个线程安全的缓存数据块，支持批量动态修改，添加，并获取快照<br />
            A thread-safe cache data block that supports batch dynamic modification, addition, and snapshot acquisition
            </summary>
            <remarks>
            这个类可以实现什么功能呢，就是你有一个大的数组，作为你的应用程序的中间数据池，允许你往byte[]数组里存放指定长度的子byte[]数组，也允许从里面拿数据，
            这些操作都是线程安全的，当然，本类扩展了一些额外的方法支持，也可以直接赋值或获取基本的数据类型对象。
            </remarks>
            <example>
            此处举例一些数据的读写说明，可以此处的数据示例。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftBufferExample.cs" region="SoftBufferExample1" title="SoftBuffer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.#ctor">
            <summary>
            使用默认的大小初始化缓存空间<br />
            Initialize cache space with default size
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.#ctor(System.Int32)">
            <summary>
            使用指定的容量初始化缓存数据块<br />
            Initialize the cache data block with the specified capacity
            </summary>
            <param name="capacity">初始化的容量</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBool(System.Boolean,System.Int32)">
            <summary>
            设置指定的位置bool值，如果超出，则丢弃数据，该位置是指按照位为单位排序的<br />
            Set the bool value at the specified position, if it is exceeded, 
            the data is discarded, the position refers to sorting in units of bits
            </summary>
            <param name="value">bool值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBool(System.Boolean[],System.Int32)">
            <summary>
            设置指定的位置的bool数组，如果超出，则丢弃数据，该位置是指按照位为单位排序的<br />
            Set the bool array at the specified position, if it is exceeded, 
            the data is discarded, the position refers to sorting in units of bits
            </summary>
            <param name="value">bool数组值</param>
            <param name="destIndex">目标存储的索引</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBool(System.Int32)">
            <summary>
            获取指定的位置的bool值，如果超出，则引发异常<br />
            Get the bool value at the specified position, if it exceeds, an exception is thrown
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <returns>获取索引位置的bool数据值</returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBool(System.Int32,System.Int32)">
            <summary>
            获取指定位置的bool数组值，如果超过，则引发异常<br />
            Get the bool array value at the specified position, if it exceeds, an exception is thrown
            </summary>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">读取的数组长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
            <returns>bool数组值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据<br />
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetBytes(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            设置指定的位置的数据块，如果超出，则丢弃数据<br />
            Set the data block at the specified position, if it is exceeded, the data is discarded
            </summary>
            <param name="data">数据块信息</param>
            <param name="sourceIndex">Data中的起始位置</param>
            <param name="destIndex">目标存储的索引</param>
            <param name="length">准备拷贝的数据长度</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBytes(System.Int32,System.Int32)">
            <summary>
            获取内存指定长度的数据信息<br />
            Get data information of specified length in memory
            </summary>
            <param name="index">起始位置</param>
            <param name="length">数组长度</param>
            <returns>返回实际的数据信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetBytes">
            <summary>
            获取内存所有的数据信息<br />
            Get all data information in memory
            </summary>
            <returns>实际的数据信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Byte,System.Int32)">
            <summary>
            设置byte类型的数据到缓存区<br />
            Set byte type data to the cache area
            </summary>
            <param name="value">byte数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int16[],System.Int32)">
            <summary>
            设置short数组的数据到缓存区<br />
            Set short array data to the cache area
            </summary>
            <param name="values">short数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int16,System.Int32)">
            <summary>
            设置short类型的数据到缓存区<br />
            Set short type data to the cache area
            </summary>
            <param name="value">short数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt16[],System.Int32)">
            <summary>
            设置ushort数组的数据到缓存区<br />
            Set ushort array data to the cache area
            </summary>
            <param name="values">ushort数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt16,System.Int32)">
            <summary>
            设置ushort类型的数据到缓存区<br />
            Set ushort type data to the cache area
            </summary>
            <param name="value">ushort数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int32[],System.Int32)">
            <summary>
            设置int数组的数据到缓存区<br />
            Set int array data to the cache area
            </summary>
            <param name="values">int数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int32,System.Int32)">
            <summary>
            设置int类型的数据到缓存区<br />
            Set int type data to the cache area
            </summary>
            <param name="value">int数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt32[],System.Int32)">
            <summary>
            设置uint数组的数据到缓存区<br />
            Set uint array data to the cache area
            </summary>
            <param name="values">uint数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt32,System.Int32)">
            <summary>
            设置uint类型的数据到缓存区<br />
            Set uint byte data to the cache area
            </summary>
            <param name="value">uint数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Single[],System.Int32)">
            <summary>
            设置float数组的数据到缓存区<br />
            Set float array data to the cache area
            </summary>
            <param name="values">float数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Single,System.Int32)">
            <summary>
            设置float类型的数据到缓存区<br />
            Set float type data to the cache area
            </summary>
            <param name="value">float数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int64[],System.Int32)">
            <summary>
            设置long数组的数据到缓存区<br />
            Set long array data to the cache area
            </summary>
            <param name="values">long数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Int64,System.Int32)">
            <summary>
            设置long类型的数据到缓存区<br />
            Set long type data to the cache area
            </summary>
            <param name="value">long数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt64[],System.Int32)">
            <summary>
            设置ulong数组的数据到缓存区<br />
            Set long array data to the cache area
            </summary>
            <param name="values">ulong数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.UInt64,System.Int32)">
            <summary>
            设置ulong类型的数据到缓存区<br />
            Set ulong byte data to the cache area
            </summary>
            <param name="value">ulong数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Double[],System.Int32)">
            <summary>
            设置double数组的数据到缓存区<br />
            Set double array data to the cache area
            </summary>
            <param name="values">double数组</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetValue(System.Double,System.Int32)">
            <summary>
            设置double类型的数据到缓存区<br />
            Set double type data to the cache area
            </summary>
            <param name="value">double数值</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetByte(System.Int32)">
            <summary>
            获取byte类型的数据<br />
            Get byte data
            </summary>
            <param name="index">索引位置</param>
            <returns>byte数值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt16(System.Int32,System.Int32)">
            <summary>
            获取short类型的数组到缓存区<br />
            Get short type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>short数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt16(System.Int32)">
            <summary>
            获取short类型的数据到缓存区<br />
            Get short data to the cache
            </summary>
            <param name="index">索引位置</param>
            <returns>short数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt16(System.Int32,System.Int32)">
            <summary>
            获取ushort类型的数组到缓存区<br />
            Get ushort type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ushort数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt16(System.Int32)">
            <summary>
            获取ushort类型的数据到缓存区<br />
            Get ushort type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>ushort数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt32(System.Int32,System.Int32)">
            <summary>
            获取int类型的数组到缓存区<br />
            Get int type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>int数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt32(System.Int32)">
            <summary>
            获取int类型的数据到缓存区<br />
            Get int type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>int数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt32(System.Int32,System.Int32)">
            <summary>
            获取uint类型的数组到缓存区<br />
            Get uint type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>uint数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt32(System.Int32)">
            <summary>
            获取uint类型的数据到缓存区<br />
            Get uint type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>uint数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetSingle(System.Int32,System.Int32)">
            <summary>
            获取float类型的数组到缓存区<br />
            Get float type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>float数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetSingle(System.Int32)">
            <summary>
            获取float类型的数据到缓存区<br />
            Get float type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>float数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt64(System.Int32,System.Int32)">
            <summary>
            获取long类型的数组到缓存区<br />
            Get long type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>long数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetInt64(System.Int32)">
            <summary>
            获取long类型的数据到缓存区<br />
            Get long type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>long数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt64(System.Int32,System.Int32)">
            <summary>
            获取ulong类型的数组到缓存区<br />
            Get ulong type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>ulong数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetUInt64(System.Int32)">
            <summary>
            获取ulong类型的数据到缓存区<br />
            Get ulong type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>ulong数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetDouble(System.Int32,System.Int32)">
            <summary>
            获取double类型的数组到缓存区<br />
            Get double type array to cache
            </summary>
            <param name="index">索引位置</param>
            <param name="length">数组长度</param>
            <returns>double数组</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetDouble(System.Int32)">
            <summary>
            获取double类型的数据到缓存区<br />
            Get double type data to cache
            </summary>
            <param name="index">索引位置</param>
            <returns>double数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.GetCustomer``1(System.Int32)">
            <summary>
            读取自定义类型的数据，需要规定解析规则<br />
            Read custom types of data, need to specify the parsing rules
            </summary>
            <typeparam name="T">类型名称</typeparam>
            <param name="index">起始索引</param>
            <returns>自定义的数据类型</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.SetCustomer``1(``0,System.Int32)">
            <summary>
            写入自定义类型的数据到缓存中去，需要规定生成字节的方法<br />
            Write custom type data to the cache, need to specify the method of generating bytes
            </summary>
            <typeparam name="T">自定义类型</typeparam>
            <param name="data">实例对象</param>
            <param name="index">起始地址</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBuffer.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftBuffer.IsBoolReverseByWord">
            <summary>
            获取或设置当前的bool操作是否按照字节反转<br />
            Gets or sets whether the current bool operation is reversed by bytes
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftBuffer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayBase">
            <summary>
            内存队列的基类
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayBase.DataBytes">
            <summary>
            字节数据流
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftCacheArrayBase.ArrayLength">
            <summary>
            数据的长度
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayBase.HybirdLock">
            <summary>
            数据数组变动时的数据锁
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayBase.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayBase.GetAllData">
            <summary>
            获取原本的数据字节
            </summary>
            <returns>字节数组</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayLong">
            <summary>
            一个内存队列缓存的类，数据类型为Int64
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayLong.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayLong.AddValue(System.Int64)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftCacheArrayInt">
            <summary>
            一个内存队列缓存的类，数据类型为Int32
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftCacheArrayInt.DataArray">
            <summary>
            数据的本身面貌
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.#ctor(System.Int32,System.Int32)">
            <summary>
            实例化一个数据对象
            </summary>
            <param name="capacity"></param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.LoadFromBytes(System.Byte[])">
            <summary>
            用于从保存的数据对象初始化的
            </summary>
            <param name="dataSave"></param>
            <exception cref="T:System.NullReferenceException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.AddValue(System.Int32)">
            <summary>
            线程安全的添加数据
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftCacheArrayInt.GetIntArray">
            <summary>
            安全的获取数组队列
            </summary>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.Exception`1">
            <summary>
            一个自定义的支持序列化反序列化的异常类，具体用法参照第四版《CLR Via C#》P414
            </summary>
            <typeparam name="TExceptionArgs">泛型异常</typeparam>
        </member>
        <member name="F:HslCommunication.BasicFramework.Exception`1.c_args">
            <summary>
            用于反序列化的
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Exception`1.Args">
            <summary>
            消息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.#ctor(System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.#ctor(`0,System.String,System.Exception)">
            <summary>
            实例化一个异常对象
            </summary>
            <param name="args">异常消息</param>
            <param name="message">消息</param>
            <param name="innerException">内部异常类</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            获取存储对象的序列化数据
            </summary>
            <param name="info">序列化的信息</param>
            <param name="context">流的上下文</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.Exception`1.Message">
            <summary>
            获取描述当前异常的消息
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.Equals(System.Object)">
            <summary>
            确定指定的object是否等于当前的object
            </summary>
            <param name="obj">异常对象</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.Exception`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.ExceptionArgs">
            <summary>
            异常消息基类
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.ExceptionArgs.Message">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftMail">
            <summary>
            软件的邮箱类，用于发送邮箱数据
            </summary>
            <remarks>
            如果您想实现自己的邮件发送中心，就可以去对应的邮件服务器注册，如果是想快速实现邮件的发送，本系统提供了2个静态的已经注册好了的邮箱发送器。
            </remarks>
            <example>
            以下的代码演示了通过静态的发送对象来发送邮件，包含了发送普通的邮件，和发送html邮件。
            <code lang="cs" source="TestProject\HslCommunicationDemo\FormMail.cs" region="SoftMail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.SoftMailSendFailedCount">
            <summary>
            系统连续发送失败的次数，为了不影响系统，连续三次失败就禁止发送
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMail.MailSystem163">
            <summary>
            系统提供一个默认的163邮箱发送账号，只要更改接收地址即可发送服务，可能会被拦截
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMail.MailSystemQQ">
            <summary>
            系统提供一个默认的QQ邮箱发送账号，只要更改接收地址即可发送服务，发送成功概率比较高
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.#ctor(System.Action{System.Net.Mail.SmtpClient},System.String,System.String)">
            <summary>
            实例化一个邮箱发送类，需要指定初始化信息
            </summary>
            <param name="mailIni">初始化的方法</param>
            <param name="addr_From">发送地址，应该和账户匹配</param>
            <param name="addr_to">邮件接收地址</param>
            <remarks>
            初始化的方法比较复杂，需要参照示例代码。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45\BasicFramework\SoftMail.cs" region="Static Mail" title="SoftMail示例" />
            </example>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.smtpClient">
            <summary>
            系统的邮件发送客户端
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.MailFromAddress">
            <summary>
            发送邮件的地址
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMail.MailSendAddress">
            <summary>
            邮件发送的地址
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.Exception)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.Boolean)">
            <summary>
            发送邮件至地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式化文本</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.Exception,System.String)">
            <summary>
            发生BUG至邮件地址，需要提前指定发送地址，否则失败
            </summary>
            <param name="ex">异常的BUG，同样试用兼容类型</param>
            <param name="addtion">额外信息</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String)">
            <summary>
            发送邮件的方法，需要指定接收地址，主题及内容
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String,System.Boolean)">
            <summary>
            发送邮件的方法，默认发送别名，优先级，是否HTML
            </summary>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="isHtml">是否是html格式的内容</param>
            <returns>是否发送成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMail.SendMail(System.String,System.String,System.String[],System.String,System.String,System.Net.Mail.MailPriority,System.Boolean)">
            <summary>
            发送邮件的方法，需要提供完整的参数信息
            </summary>
            <param name="addr_from">发送地址</param>
            <param name="name">发送别名</param>
            <param name="addr_to">接收地址</param>
            <param name="subject">邮件主题</param>
            <param name="body">邮件内容</param>
            <param name="priority">优先级</param>
            <param name="isHtml">邮件内容是否是HTML语言</param>
            <returns>发生是否成功，内容不正确会被视为垃圾邮件</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftMsgQueue`1">
            <summary>
            一个简单通用的消息队列
            </summary>
            <typeparam name="T">类型</typeparam>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMsgQueue`1.all_items">
            <summary>
            所有临时存储的数据
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMsgQueue`1.MaxCache">
            <summary>
            临时消息存储的最大条数，必须大于10
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftMsgQueue`1.CurrentItem">
            <summary>
            获取最新添加进去的数据
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftMsgQueue`1.lock_queue">
            <summary>
            将集合进行锁定
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.AddNewItem(`0)">
            <summary>
            新增一条数据
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.ToSaveString">
            <summary>
            获取存储字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftMsgQueue`1.LoadByString(System.String)">
            <summary>
            获取加载字符串
            </summary>
            <param name="content"></param>
        </member>
        <member name="T:HslCommunication.BasicFramework.MessageBoard">
            <summary>
            系统的消息类，用来发送消息，和确认消息的
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.NameSend">
            <summary>
            发送方名称
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.NameReceive">
            <summary>
            接收方名称
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.SendTime">
            <summary>
            发送时间
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.Content">
            <summary>
            发送的消息内容
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.MessageBoard.HasViewed">
            <summary>
            消息是否已经被查看
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftNumericalOrder">
            <summary>
            一个用于自动流水号生成的类，必须指定保存的文件，实时保存来确认安全
            </summary>
            <remarks>
            <note type="important">
            序号生成器软件，当获取序列号，清空序列号操作后，会自动的将ID号存储到本地的文件中，存储方式采用乐观并发模型实现。
            </note>
            </remarks>
            <example>
            此处举个例子，也是Demo程序的源代码，包含了2个按钮的示例和瞬间调用100万次的性能示例。
            <note type="tip">百万次调用的实际耗时取决于计算机的性能，不同的计算机的表现存在差异，比如作者的：i5-4590cpu,内存ddr3-8G表示差不多在800毫秒左右</note>
            <code lang="cs" source="TestProject\HslCommunicationDemo\FormSeqCreate.cs" region="FormSeqCreate" title="示例代码" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.#ctor(System.String,System.String,System.Int32,System.String)">
            <summary>
            实例化一个流水号生成的对象
            </summary>
            <param name="textHead">流水号的头文本</param>
            <param name="timeFormate">流水号带的时间信息</param>
            <param name="numberLength">流水号数字的标准长度，不够补0</param>
            <param name="fileSavePath">流水号存储的文本位置</param>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.CurrentIndex">
            <summary>
            当前的生成序列号
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.TextHead">
            <summary>
            流水号的文本头
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.TimeFormate">
            <summary>
            时间格式默认年月日
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.NumberLength">
            <summary>
            流水号数字应该显示的长度
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.ToSaveString">
            <summary>
            获取流水号的值
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.LoadByString(System.String)">
            <summary>
            加载流水号
            </summary>
            <param name="content">源字符串信息</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.ClearNumericalOrder">
            <summary>
            清除流水号计数，进行重新计数
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetNumericalOrder">
            <summary>
            获取流水号数据
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetNumericalOrder(System.String)">
            <summary>
            获取流水号数据
            </summary>
            <param name="textHead">指定一个新的文本头</param>
            <returns>带头信息的计数后的信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftNumericalOrder.GetLongOrder">
            <summary>
            单纯的获取数字形式的流水号
            </summary>
            <returns>新增计数后的信息</returns>
        </member>
        <member name="F:HslCommunication.BasicFramework.SoftNumericalOrder.AsyncCoordinator">
            <summary>
            高性能存储块
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftIncrementCount">
            <summary>
            一个简单的不持久化的序号自增类，采用线程安全实现，并允许指定最大数字，将包含该最大值，到达后清空从指定数开始<br />
            A simple non-persistent serial number auto-increment class, which is implemented with thread safety, and allows the maximum number to be specified, which will contain the maximum number, and will be cleared from the specified number upon arrival.
            </summary>
            <example>
            先来看看一个简单的应用的
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample1" title="简单示例" />
            再来看看一些复杂的情况
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample2" title="复杂示例" />
            其他一些特殊的设定
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\BasicFramework\SoftIncrementCountSample.cs" region="Sample3" title="其他示例" />
            </example>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            实例化一个自增信息的对象，包括最大值，初始值，增量值<br />
            Instantiate an object with incremental information, including the maximum value and initial value, IncreaseTick
            </summary>
            <param name="max">数据的最大值，必须指定</param>
            <param name="start">数据的起始值，默认为0</param>
            <param name="tick">每次的增量值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.GetCurrentValue">
            <summary>
            获取自增信息，获得数据之后，下一次获取将会自增，如果自增后大于最大值，则会重置为最小值，如果小于最小值，则会重置为最大值。<br />
            Get the auto-increment information. After getting the data, the next acquisition will auto-increase. 
            If the auto-increment is greater than the maximum value, it will reset to the minimum value.
            If the auto-increment is smaller than the minimum value, it will reset to the maximum value.
            </summary>
            <returns>计数自增后的值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetMaxValue(System.Int64)">
            <summary>
            重置当前序号的最大值，最大值应该大于初始值，如果当前值大于最大值，则当前值被重置为最大值<br />
            Reset the maximum value of the current serial number. The maximum value should be greater than the initial value. 
            If the current value is greater than the maximum value, the current value is reset to the maximum value.
            </summary>
            <param name="max">最大值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetStartValue(System.Int64)">
            <summary>
            重置当前序号的初始值，需要小于最大值，如果当前值小于初始值，则当前值被重置为初始值。<br />
            To reset the initial value of the current serial number, it must be less than the maximum value. 
            If the current value is less than the initial value, the current value is reset to the initial value.
            </summary>
            <param name="start">初始值</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetCurrentValue">
            <summary>
            将当前的值重置为初始值。<br />
            Reset the current value to the initial value.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ResetCurrentValue(System.Int64)">
            <summary>
            将当前的值重置为指定值，该值不能大于max，如果大于max值，就会自动设置为max<br />
            Reset the current value to the specified value. The value cannot be greater than max. If it is greater than max, it will be automatically set to max.
            </summary>
            <param name="value">指定的数据值</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftIncrementCount.IncreaseTick">
            <summary>
            增加的单元，如果设置为0，就是不增加。如果为小于0，那就是减少，会变成负数的可能。<br />
            Increased units, if set to 0, do not increase. If it is less than 0, it is a decrease and it may become a negative number.
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SoftIncrementCount.MaxValue">
            <summary>
            获取当前的计数器的最大的设置值。<br />
            Get the maximum setting value of the current counter.
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftIncrementCount.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:HslCommunication.BasicFramework.GraphDirection">
            <summary>
            图形的方向
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Upward">
            <summary>
            向上
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Downward">
            <summary>
            向下
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Ledtward">
            <summary>
            向左
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphDirection.Rightward">
            <summary>
            向右
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.Paintdata">
            <summary>
            包含整型和字符串描述的数据类型
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Paintdata.Count">
            <summary>
            数量
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.Paintdata.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.GraphicRender">
            <summary>
            图形的呈现方式
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Histogram">
            <summary>
            直方图
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Piechart">
            <summary>
            饼图
            </summary>
        </member>
        <member name="F:HslCommunication.BasicFramework.GraphicRender.Linegraph">
            <summary>
            折线图
            </summary>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftPainting">
            <summary>
            静态类，包含了几个常用的画图方法，获取字符串，绘制小三角等
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.GetGraphicFromArray(System.Int32[],System.Int32,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            获取一个直方图
            </summary>
            <param name="array">数据数组</param>
            <param name="width">宽度</param>
            <param name="height">高度</param>
            <param name="degree">刻度划分等级</param>
            <param name="lineColor">线条颜色</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.ComputePaintLocationY(System.Single,System.Single,System.Int32,System.Single)">
            <summary>
            计算绘图时的相对偏移值
            </summary>
            <param name="max">0-100分的最大值，就是指准备绘制的最大值</param>
            <param name="min">0-100分的最小值，就是指准备绘制的最小值</param>
            <param name="height">实际绘图区域的高度</param>
            <param name="value">需要绘制数据的当前值</param>
            <returns>相对于0的位置，还需要增加上面的偏值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.PaintCoordinateDivide(System.Drawing.Graphics,System.Drawing.Pen,System.Drawing.Pen,System.Drawing.Font,System.Drawing.Brush,System.Drawing.StringFormat,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            绘制坐标系中的刻度线
            </summary>
            <param name="g"></param>
            <param name="penLine"></param>
            <param name="penDash"></param>
            <param name="font"></param>
            <param name="brush"></param>
            <param name="sf"></param>
            <param name="degree"></param>
            <param name="max"></param>
            <param name="min"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="up"></param>
            <param name="down"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.PaintTriangle(System.Drawing.Graphics,System.Drawing.Brush,System.Drawing.Point,System.Int32,HslCommunication.BasicFramework.GraphDirection)">
            <summary>
            根据指定的方向绘制一个箭头
            </summary>
            <param name="g"></param>
            <param name="brush"></param>
            <param name="point"></param>
            <param name="size"></param>
            <param name="direction"></param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftPainting.GetGraphicFromArray(HslCommunication.BasicFramework.Paintdata[],System.Int32,System.Int32,HslCommunication.BasicFramework.GraphicRender)">
            <summary>
            根据数据生成一个可视化的图形
            </summary>
            <param name="array">数据集合</param>
            <param name="width">需要绘制图形的宽度</param>
            <param name="height">需要绘制图形的高度</param>
            <param name="graphic">指定绘制成什么样子的图形</param>
            <returns>返回一个bitmap对象</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftSecurity">
            <summary>
            字符串加密解密相关的自定义类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Encrypt(System.String)">
            <summary>
            加密数据，采用对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Encrypt(System.String,System.String)">
            <summary>
            加密数据，采用对称加密的方式
            </summary>
            <param name="pToEncrypt">待加密的数据</param>
            <param name="Password">密钥，长度为8，英文或数字</param>
            <returns>加密后的数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Decrypt(System.String)">
            <summary>
            解密过程，使用的是对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSecurity.MD5Decrypt(System.String,System.String)">
            <summary>
            解密过程，使用的是对称的加密
            </summary>
            <param name="pToDecrypt">等待解密的字符</param>
            <param name="password">密钥，长度为8，英文或数字</param>
            <returns>返回原密码，如果解密失败，返回‘解密失败’</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftSqlOperate">
            <summary>
            数据库操作的相关类，包含了常用的方法，避免大量的重复代码
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSql(System.String,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSql(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            普通的执行SQL语句，并返回影响行数，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，适合插入，更新，删除</param>
            <returns>返回受影响的行数</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.String,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectTable(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择数据表的执行SQL语句，并返回最终数据表，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据表</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.String,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectEnumerable``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            选择指定类型数据集合执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据集合</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.String,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectObject``1(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            更新指定类型数据执行SQL语句，并返回指定类型的数据集合，该方法应该放到try-catch代码块中
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>结果数据</returns>
            <exception cref="T:System.Data.SqlClient.SqlException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.String,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conStr">数据库的连接字符串</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftSqlOperate.ExecuteSelectCount(System.Data.SqlClient.SqlConnection,System.String)">
            <summary>
            用于选择聚合函数值的方法，例如Count，Average，Max，Min，Sum等最终只有一个结果值的对象
            </summary>
            <param name="conn">数据库的连接对象</param>
            <param name="cmdStr">sql语句，选择数据表的语句</param>
            <returns>返回的int数据</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.ISqlDataType">
            <summary>
            数据库对应类的读取接口
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.ISqlDataType.LoadBySqlDataReader(System.Data.SqlClient.SqlDataReader)">
            <summary>
            根据sdr对象初始化数据的方法
            </summary>
            <param name="sdr">数据库reader对象</param>
        </member>
        <member name="T:HslCommunication.BasicFramework.SystemVersion">
            <summary>
            系统版本类，由三部分组成，包含了一个大版本，小版本，修订版，还有一个开发者维护的内部版<br />
            System version class, consisting of three parts, including a major version, minor version, revised version, and an internal version maintained by the developer
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.String)">
            <summary>
            根据格式化字符串的版本号初始化，例如：1.0或1.0.0或1.0.0.0503<br />
            Initialize according to the version number of the formatted string, for example: 1.0 or 1.0.0 or 1.0.0.0503
            </summary>
            <param name="VersionString">格式化的字符串，例如：1.0或1.0.0或1.0.0.0503</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的主版本，次版本，修订版来实例化一个对象<br />
            Instantiate an object based on the specified major, minor, and revision
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            根据指定的主版本，次版本，修订版，内部版本来实例化一个对象<br />
            Instantiate an object based on the specified major, minor, revision, and build
            </summary>
            <param name="main">主版本</param>
            <param name="sec">次版本</param>
            <param name="edit">修订版</param>
            <param name="inner">内部版本号</param>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.MainVersion">
            <summary>
            主版本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.SecondaryVersion">
            <summary>
            次版本
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.EditVersion">
            <summary>
            修订版
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.SystemVersion.InnerVersion">
            <summary>
            内部版本号，或者是版本号表示为年月份+内部版本的表示方式
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.ToString(System.String)">
            <summary>
            根据格式化为支持返回的不同信息的版本号<br />
            C返回1.0.0.0<br />
            N返回1.0.0<br />
            S返回1.0
            </summary>
            <param name="format">格式化信息</param>
            <returns>版本号信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.ToString">
            <summary>
            获取版本号的字符串形式，如果内部版本号为0，则显示时不携带
            </summary>
            <returns>版本号信息</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.Equals(System.Object)">
            <summary>
            判断两个实例是否相等
            </summary>
            <param name="obj">版本号</param>
            <returns>是否一致</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>哈希值</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_Equality(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断是否相等
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_Inequality(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断是否不相等
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_GreaterThan(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断一个版本是否大于另一个版本
            </summary>
            <param name="SV1">第一个版本</param>
            <param name="SV2">第二个版本</param>
            <returns>是否相同</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SystemVersion.op_LessThan(HslCommunication.BasicFramework.SystemVersion,HslCommunication.BasicFramework.SystemVersion)">
            <summary>
            判断第一个版本是否小于第二个版本
            </summary>
            <param name="SV1">第一个版本号</param>
            <param name="SV2">第二个版本号</param>
            <returns>是否小于</returns>
        </member>
        <member name="T:HslCommunication.BasicFramework.VersionInfo">
            <summary>
            版本信息类，用于展示版本发布信息
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.ReleaseDate">
            <summary>
            版本的发行日期
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.UpdateDetails">
            <summary>
            版本的更新细节
            </summary>
        </member>
        <member name="P:HslCommunication.BasicFramework.VersionInfo.VersionNum">
            <summary>
            版本号
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.VersionInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.BasicFramework.SoftZipped">
            <summary>
            一个负责压缩解压数据字节的类
            </summary>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftZipped.CompressBytes(System.Byte[])">
            <summary>
            压缩字节数据
            </summary>
            <param name="bytes">等待被压缩的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩之后的字节数据</returns>
        </member>
        <member name="M:HslCommunication.BasicFramework.SoftZipped.Decompress(System.Byte[])">
            <summary>
            解压压缩后的数据
            </summary>
            <param name="bytes">压缩后的数据</param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <returns>压缩前的原始字节数据</returns>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage">
            <summary>
            Fanuc床子的消息对象
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.ProtocolHeadBytesLength">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.HeadBytes">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.ContentBytes">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.SendBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.GetContentLengthByHeadBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.GetHeadBytesIdentity">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CNCFanucSeriesMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCRunStatus">
            <summary>
            CNC的运行状态
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.CNCWorkMode">
            <summary>
            设备的工作模式
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.MDI">
            <summary>
            手动输入
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.AUTO">
            <summary>
            自动循环
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.EDIT">
            <summary>
            程序编辑
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.HANDLE">
            <summary>
            ×100
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.JOG">
            <summary>
            连续进给
            </summary>
        </member>
        <member name="F:HslCommunication.CNC.Fanuc.CNCWorkMode.REFerence">
            <summary>
            机床回零
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.LengthSharpOffset">
            <summary>
            长度形状补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.LengthWearOffset">
            <summary>
            长度磨损补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.RadiusSharpOffset">
            <summary>
            半径形状补偿
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.CutterInfo.RadiusWearOffset">
            <summary>
            半径磨损补偿
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.CutterInfo.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.FanucSeries0i">
            <summary>
            一个FANUC的机床通信类对象
            </summary>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.#ctor(System.String,System.Int32)">
            <summary>
            根据IP及端口来实例化一个对象内容
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSpindleSpeedAndFeedRate">
            <summary>
            主轴转速及进给倍率
            </summary>
            <returns>主轴转速及进给倍率</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemProgramCurrent">
            <summary>
            读取程序名及程序号
            </summary>
            <returns>程序名及程序号</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32)">
            <summary>
            读取宏变量，可以用来读取刀具号
            </summary>
            <param name="number"></param>
            <returns>读宏变量信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemMacroValue(System.Int32,System.Int32)">
            <summary>
            读取宏变量，可以用来读取刀具号
            </summary>
            <param name="number"></param>
            <param name="length">读取的长度信息</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteSystemMacroValue(System.Int32,System.Double[])">
            <summary>
            写宏变量
            </summary>
            <param name="number">地址</param>
            <param name="values">数据值</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthSharpOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入长度形状补偿，刀具号为1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterLengthWearOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入长度磨损补偿，刀具号为1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusSharpOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入半径形状补偿，刀具号为1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.WriteCutterRadiusWearOffset(System.Int32,System.Double)">
            <summary>
            根据刀具号写入半径磨损补偿，刀具号为1-24
            </summary>
            <param name="cutter">刀具号，范围为1-24</param>
            <param name="offset">补偿值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadFanucAxisLoad">
            <summary>
            读取伺服负载
            </summary>
            <returns>轴负载</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysAllCoors">
            <summary>
            读取机床的坐标，包括机械坐标，绝对坐标，相对坐标
            </summary>
            <returns>数控机床的坐标信息，包括机械坐标，绝对坐标，相对坐标</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSystemAlarm">
            <summary>
            读取报警信息
            </summary>
            <returns>机床的当前的所有的报警信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadTimeData(System.Int32)">
            <summary>
            读取fanuc机床的时间，0是开机时间，1是运行时间，2是切割时间，3是循环时间，4是空闲时间，返回秒为单位的信息
            </summary>
            <param name="timeType">读取的时间类型</param>
            <returns>秒为单位的结果</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadAlarmStatus">
            <summary>
            读取报警状态信息
            </summary>
            <returns>报警状态数据</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadSysStatusInfo">
            <summary>
            读取系统的基本信息状态，工作模式，运行状态，是否急停等等操作
            </summary>
            <returns>结果信息数据</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgramList">
            <summary>
            读取设备的程序列表
            </summary>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCutterInfos(System.Int32)">
            <summary>
            读取当前的刀具补偿信息
            </summary>
            <param name="cutterNumber">刀具数量</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadDeviceWorkPiecesSize">
            <summary>
            读取工件尺寸
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadProgram(System.Int32)">
            <summary>
            读取指定的程序内容，目前还没有测试通
            </summary>
            <param name="program">程序号</param>
            <returns>程序内容</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentForegroundDir">
            <summary>
            读取当前程序的前台路径
            </summary>
            <returns>程序的路径信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.SetDeviceProgsCurr(System.String)">
            <summary>
            设置指定路径为当前路径
            </summary>
            <param name="programName">程序名</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentDateTime">
            <summary>
            读取机床的当前时间信息
            </summary>
            <returns>时间信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadCurrentProduceCount">
            <summary>
            读取当前的已加工的零件数量
            </summary>
            <returns>已经加工的零件数量</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ReadExpectProduceCount">
            <summary>
            读取期望的加工的零件数量
            </summary>
            <returns>期望的加工的零件数量</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadSingle(System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            构建读取一个命令的数据内容
            </summary>
            <param name="code">命令码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="e">第五个参数内容</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildWriteSingle(System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            创建写入byte[]数组的报文信息
            </summary>
            <param name="code">命令码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="data">等待写入的byte数组信息</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildWriteSingle(System.UInt16,System.Int32,System.Int32,System.Int32,System.Int32,System.Double[])">
            <summary>
            创建写入单个double数组的报文信息
            </summary>
            <param name="code">功能码</param>
            <param name="a">第一个参数内容</param>
            <param name="b">第二个参数内容</param>
            <param name="c">第三个参数内容</param>
            <param name="d">第四个参数内容</param>
            <param name="data">等待写入的double数组信息</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadProgram(System.Int32)">
            <summary>
            创建读取运行程序的报文信息
            </summary>
            <param name="program">程序号</param>
            <returns>总报文</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.BuildReadArray(System.Byte[][])">
            <summary>
            创建多个命令报文的总报文信息
            </summary>
            <param name="commands">报文命令的数组</param>
            <returns>总报文信息</returns>
        </member>
        <member name="M:HslCommunication.CNC.Fanuc.FanucSeries0i.ExtraContentArray(System.Byte[])">
            <summary>
            从机床返回的数据里解析出实际的数据内容，去除了一些多余的信息报文。
            </summary>
            <param name="content">返回的报文信息</param>
            <returns>解析之后的报文信息</returns>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.SysAlarm">
            <summary>
            当前机床的报警信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.AlarmId">
            <summary>
            当前报警的ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Type">
            <summary>
            当前的报警类型
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Axis">
            <summary>
            报警的轴信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAlarm.Message">
            <summary>
            报警的消息
            </summary>
        </member>
        <member name="T:HslCommunication.CNC.Fanuc.SysAllCoors">
            <summary>
            系统的坐标信息
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Absolute">
            <summary>
            绝对坐标
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Machine">
            <summary>
            机械坐标
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysAllCoors.Relative">
            <summary>
            相对坐标
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Dummy">
            <summary>
            dummy
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.TMMode">
            <summary>
            T/M mode
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.WorkMode">
            <summary>
            selected automatic mode
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.RunStatus">
            <summary>
            running status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Motion">
            <summary>
            axis, dwell status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.MSTB">
            <summary>
            m, s, t, b status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Emergency">
            <summary>
            emergency stop status，为1就是急停，为0就是正常
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Alarm">
            <summary>
            alarm status
            </summary>
        </member>
        <member name="P:HslCommunication.CNC.Fanuc.SysStatusInfo.Edit">
            <summary>
            editting status
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserBottle">
            <summary>
            瓶子控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.#ctor">
            <summary>
            实例化一个新的控件对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.Value">
            <summary>
            获取或设置瓶子的液位值。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.IsOpen">
            <summary>
            获取或设置瓶子是否处于打开的状态。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.BottleTag">
            <summary>
            获取或设置瓶子的标签信息，用于绘制在瓶子上的信息。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserBottle.HeadTag">
            <summary>
            获取或设置瓶子的备注信息，用于绘制在瓶子顶部的信息。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.WndProc(System.Windows.Forms.Message@)">
            <summary>
            重写消息处理机制
            </summary>
            <param name="m">系统消息</param>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重新绘制界面图形
            </summary>
            <param name="e">绘制消息</param>
        </member>
        <member name="F:HslCommunication.Controls.UserBottle.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserBottle.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserButton">
            <summary>
            一个自定义的按钮控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.#ctor">
            <summary>
            实例化一个按钮对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.UIText">
            <summary>
            设置或获取显示的文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.TextColor">
            <summary>
            设置或获取显示文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.CornerRadius">
            <summary>
            设置按钮的圆角
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.Selected">
            <summary>
            用来设置按钮的选中状态
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.ForeColor">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.Text">
            <summary>
            已经弃用
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.OriginalColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.EnableColor">
            <summary>
            按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.ActiveColor">
            <summary>
            鼠标挪动时的活动颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.BorderVisiable">
            <summary>
            设置按钮的边框是否可见
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserButton.CustomerInformation">
            <summary>
            存放用户需要保存的一些额外的信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.PerformClick">
            <summary>
            触发一次点击的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘数据区
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnClick(System.EventArgs)">
            <summary>
            点击按钮的触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.OnMouseClick(System.Windows.Forms.MouseEventArgs)">
            <summary>
            点击的时候触发事件
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserButton.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserButton.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserClock">
            <summary>
            一个时钟控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.#ctor">
            <summary>
            实例化一个时钟控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.当前时间">
            <summary>
            获取时钟的当前时间
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.时钟指针颜色">
            <summary>
            获取或设置时钟指针的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.分钟指针颜色">
            <summary>
            获取或设置时钟分钟指针颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.秒钟指针颜色">
            <summary>
            获取或设置秒钟指针颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.显示文本">
            <summary>
            获取或设置时钟的个性化文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserClock.显示文本字体">
            <summary>
            字体
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>
            重绘控件显示
            </summary>
            <param name="e"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserClock.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserClock.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserCurve">
            <summary>
            曲线控件对象
            </summary>
            <remarks>
            详细参照如下的博客:
            </remarks>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.#ctor">
            <summary>
            实例化一个曲线显示的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMaxLeft">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMinLeft">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMaxRight">
            <summary>
            获取或设置图形的纵坐标的最大值，该值必须大于最小值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueMinRight">
            <summary>
            获取或设置图形的纵坐标的最小值，该值必须小于最大值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ValueSegment">
            <summary>
            获取或设置图形的纵轴分段数
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IsAbscissaStrech">
            <summary>
            获取或设置所有的数据是否强制在一个界面里显示
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.StrechDataCountMax">
            <summary>
            获取或设置拉伸模式下的最大数据量
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IsRenderDashLine">
            <summary>
            获取或设置虚线是否进行显示
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ColorLinesAndText">
            <summary>
            获取或设置坐标轴及相关信息文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.ColorDashLines">
            <summary>
            获取或设置虚线的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.IntervalAbscissaText">
            <summary>
            获取或设置纵向虚线的分隔情况，单位为多少个数据
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.TextAddFormat">
            <summary>
            获取或设置实时数据新增时文本相对应于时间的格式化字符串，默认HH:mm
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserCurve.Title">
            <summary>
            获取或设置图标的标题信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveText(System.String[])">
            <summary>
            设置曲线的横坐标文本，适用于显示一些固定的曲线信息
            </summary>
            <param name="descriptions">应该和曲线的点数一致</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data">曲线的具体数据</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetLeftCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的左参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetRightCurve(System.String,System.Single[])">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色随机，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetRightCurve(System.String,System.Single[],System.Drawing.Color)">
            <summary>
            新增或修改一条指定关键字的右参考系曲线数据，需要指定数据，颜色，没有数据上限，线条宽度为1
            </summary>
            <param name="key">曲线关键字</param>
            <param name="data"></param>
            <param name="lineColor"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurve(System.String,System.Boolean,System.Single[],System.Drawing.Color,System.Single)">
            <summary>
            新增或修改一条指定关键字的曲线数据，需要指定参考系及数据，颜色，线条宽度
            </summary>
            <param name="key">曲线关键字</param>
            <param name="isLeft">是否以左侧坐标轴为参照系</param>
            <param name="data">数据</param>
            <param name="lineColor">线条颜色</param>
            <param name="thickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveCurve(System.String)">
            <summary>
            移除指定关键字的曲线
            </summary>
            <param name="key">曲线关键字</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAllCurve">
            <summary>
            移除指定关键字的曲线
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single[],System.Boolean)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">新增曲线的关键字</param>
            <param name="values"></param>
            <param name="isUpdateUI">是否刷新界面</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single)">
            <summary>
            新增指定关键字曲线的一个数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String,System.Single[])">
            <summary>
            新增指定关键字曲线的一组数据，注意该关键字的曲线必须存在，否则无效
            </summary>
            <param name="key">曲线的关键字</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddCurveData(System.String[],System.Single[])">
            <summary>
            新增指定关键字数组曲线的一组数据，注意该关键字的曲线必须存在，否则无效，一个数据对应一个数组
            </summary>
            <param name="keys">曲线的关键字数组</param>
            <param name="values">数组值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveVisible(System.String,System.Boolean)">
            <summary>
            设置一条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="key">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.SetCurveVisible(System.String[],System.Boolean)">
            <summary>
            设置多条曲线是否是可见的，如果该曲线不存在，则无效。
            </summary>
            <param name="keys">关键字</param>
            <param name="visible">是否可见</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single)">
            <summary>
            新增一条左侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条左侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddLeftAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条左侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single)">
            <summary>
            新增一条右侧的辅助线，使用默认的文本颜色
            </summary>
            <param name="value">数据值</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color)">
            <summary>
            新增一条右侧的辅助线，使用指定的颜色
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.AddRightAuxiliary(System.Single,System.Drawing.Color,System.Single)">
            <summary>
            新增一条右侧的辅助线
            </summary>
            <param name="value">数据值</param>
            <param name="lineColor">线条颜色</param>
            <param name="lineThickness">线条宽度</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAuxiliary(System.Single)">
            <summary>
            移除所有的指定值的辅助曲线，包括左边的和右边的
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.RemoveAllAuxiliary">
            <summary>
            移除所有的辅助线
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserCurve.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserCurve.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.HslCurveItem">
            <summary>
            曲线数据对象
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.HslCurveItem.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.HslCurveItem.Data">
            <summary>
            数据
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.LineThickness">
            <summary>
            线条的宽度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.LineColor">
            <summary>
            曲线颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.HslCurveItem.Visible">
            <summary>
            本曲线是否显示出来，默认为显示
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.AuxiliaryLine">
            <summary>
            辅助线对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.Value">
            <summary>
            实际的数据值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.PaintValue">
            <summary>
            实际的数据绘制
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineColor">
            <summary>
            辅助线的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.PenDash">
            <summary>
            辅助线的画笔资源
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineThickness">
            <summary>
            辅助线的宽度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.LineTextBrush">
            <summary>
            辅助线文本的画刷
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.AuxiliaryLine.IsLeftFrame">
            <summary>
            是否左侧参考系，True为左侧，False为右侧
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.AuxiliaryLine.Dispose">
            <summary>
            释放内存信息
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserDrum">
            <summary>
            一个罐子形状的控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.#ctor">
            <summary>
            实例化一个罐子形状的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.DrumBackColor">
            <summary>
            获取或设置容器罐的背景色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.BorderColor">
            <summary>
            获取或设置容器罐的边框色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.Text">
            <summary>
            获取或设置显示的文本信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.ForeColor">
            <summary>
            获取或设置文本的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserDrum.TextBackColor">
            <summary>
            获取或设置文本的背景色
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserDrum.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserDrum.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserGaugeChart">
            <summary>
            仪表盘控件类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.#ctor">
            <summary>
            实例化一个仪表盘控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.GetCenterPoint">
            <summary>
            获取中心点的坐标
            </summary>
            <returns></returns>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.GaugeBorder">
            <summary>
            获取或设置仪表盘的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.PointerColor">
            <summary>
            获取或设置指针的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueStart">
            <summary>
            获取或设置数值的起始值，默认为0
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueMax">
            <summary>
            获取或设置数值的最大值，默认为100
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.Value">
            <summary>
            获取或设置数值的当前值，应该处于最小值和最大值之间
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueAlarmMax">
            <summary>
            获取或设置数值的上限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.ValueAlarmMin">
            <summary>
            获取或设置数值的下限报警值，设置为超过最大值则无上限报警
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.SegmentCount">
            <summary>
            获取或设置仪表盘的分割段数，最小为2，最大1000
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.UnitText">
            <summary>
            获取或设置仪表盘的单位描述文本
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.IsTextUnderPointer">
            <summary>
            获取或设置文本是否是指针的下面
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserGaugeChart.IsBigSemiCircle">
            <summary>
            通常情况，仪表盘不会大于半个圆，除非本属性设置为 True
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserGaugeChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserGaugeChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserLantern">
            <summary>
            信号灯的控件类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.#ctor">
            <summary>
            实例化一个信号灯控件的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserLantern.LanternBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserLantern.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserLantern.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserPieChart">
            <summary>
            一个饼图的控件
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.#ctor">
            <summary>
            实例化一个饼图的控件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPieChart.IsRenderPercent">
            <summary>
            是否显示百分比信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPieChart.IsRenderSmall">
            <summary>
            是否在图形上显示占比非常小的文本信息
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.GetRandomColor">
            <summary>
            随机生成颜色，该颜色相对于白色为深色颜色
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.SetDataSource(HslCommunication.Core.HslPieItem[])">
            <summary>
            设置显示的数据源
            </summary>
            <param name="source">特殊的显示对象</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.SetDataSource(System.String[],System.Int32[])">
            <summary>
            根据名称和值进行数据源的显示，两者的长度需要一致
            </summary>
            <param name="names">名称</param>
            <param name="values">值</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:HslCommunication.Controls.UserPieChart.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserPieChart.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserPipe">
            <summary>
            
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.#ctor">
            <summary>
            管道控件信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LineWidth">
            <summary>
            获取或设置管道线的宽度。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.IsActive">
            <summary>
            获取或设置管道线是否处于活动状态。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.ActiveColor">
            <summary>
            获取或设置管道活动状态的颜色。
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LineColor">
            <summary>
            获取或设置管道的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.MoveSpeed">
            <summary>
            获取或设置管道线的移动速度。该速度和管道的宽度有关
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserPipe.LinePoints">
            <summary>
            获取或设置管道线的坐标。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.OnPaintMainWindow(System.Drawing.Graphics)">
            <summary>
            绘制
            </summary>
            <param name="g"></param>
        </member>
        <member name="F:HslCommunication.Controls.UserPipe.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserPipe.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserSwitch">
            <summary>
            一个开关按钮类
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.#ctor">
            <summary>
            实例化一个开关按钮对象
            </summary>
        </member>
        <member name="E:HslCommunication.Controls.UserSwitch.OnSwitchChanged">
            <summary>
            开关按钮发生变化的事件
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchBackground">
            <summary>
            获取或设置开关按钮的背景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchForeground">
            <summary>
            获取或设置开关按钮的前景色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchStatus">
            <summary>
            获取或设置开关按钮的开合状态
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserSwitch.SwitchStatusDescription">
            <summary>
            获取或设置两种开关状态的文本描述，例如：new string[]{"Off","On"}
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserSwitch.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserSwitch.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.UserVerticalProgress">
            <summary>
            一个直立的进度条控件，满足不同的情况使用
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Cursor">
            <summary>
            获取或设置光标在控件上显示的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.BackColor">
            <summary>
            获取或设置控件的背景颜色值
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ProgressColor">
            <summary>
            获取或设置进度的颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Max">
            <summary>
            进度条的最大值，默认为100
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.Value">
            <summary>
            当前进度条的值，不能大于最大值或小于0
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.IsTextRender">
            <summary>
            是否显示进度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.BorderColor">
            <summary>
            设置进度条的边框颜色
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ValueChangeSpeed">
            <summary>
            设置进度变更的速度
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.UseAnimation">
            <summary>
            获取或设置进度条变化的时候是否采用动画效果
            </summary>
        </member>
        <member name="P:HslCommunication.Controls.UserVerticalProgress.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.UserVerticalProgress.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.Controls.UserVerticalProgress.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.Controls.ProgressStyle">
            <summary>
            进度条的样式
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.ProgressStyle.Vertical">
            <summary>
            竖直的，纵向的进度条
            </summary>
        </member>
        <member name="F:HslCommunication.Controls.ProgressStyle.Horizontal">
            <summary>
            水平进度条
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Address.DeviceAddressBase">
            <summary>
            所有设备通信类的地址基础类<br />
            Address basic class of all device communication classes
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressBase.Address">
            <summary>
            获取或设置起始地址<br />
            Get or set the starting address
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressBase.Parse(System.String)">
            <summary>
            解析字符串的地址<br />
            Parse the address of the string
            </summary>
            <param name="address">地址信息</param>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Address.DeviceAddressDataBase">
            <summary>
            设备地址数据的信息，通常包含起始地址，数据类型，长度<br />
            Device address data information, usually including the starting address, data type, length
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressDataBase.AddressStart">
            <summary>
            数字的起始地址，也就是偏移地址<br />
            The starting address of the number, which is the offset address
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.DeviceAddressDataBase.Length">
            <summary>
            读取的数据长度，单位是字节还是字取决于设备方<br />
            The length of the data read, the unit is byte or word depends on the device side
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressDataBase.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息<br />
            Parsing from the specified address information into real device address information
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.DeviceAddressDataBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Address.McRAddressData">
            <summary>
            三菱R系列的PLC的地址表示对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McRAddressData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.McRAddressData.McDataType">
            <summary>
            三菱的数据类型及地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McRAddressData.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息，默认是三菱的地址
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.McRAddressData.ParseMelsecRFrom(System.String,System.UInt16)">
            <summary>
            解析出三菱R系列的地址信息
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="length">读取的长度，对写入无效</param>
            <returns>解析结果</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.McAddressData">
            <summary>
            三菱的数据地址表示形式<br />
            Mitsubishi's data address representation
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.McAddressData.McDataType">
            <summary>
            三菱的数据类型及地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息，默认是三菱的地址
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParseMelsecFrom(System.String,System.UInt16)">
            <summary>
            从实际三菱的地址里面解析出我们需要的地址类型<br />
            Resolve the type of address we need from the actual Mitsubishi address
            </summary>
            <param name="address">三菱的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParseKeyenceFrom(System.String,System.UInt16)">
            <summary>
            从实际基恩士的地址里面解析出我们需要的地址信息<br />
            Resolve the address information we need from the actual Keyence address
            </summary>
            <param name="address">基恩士的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.McAddressData.ParsePanasonicFrom(System.String,System.UInt16)">
            <summary>
            从实际松下的地址里面解析出
            </summary>
            <param name="address">松下的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Address.ModbusAddress">
            <summary>
            Modbus协议地址格式，可以携带站号，功能码，地址信息<br />
            Modbus protocol address format, can carry station number, function code, address information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String)">
            <summary>
            实例化一个对象，使用指定的地址初始化<br />
            Instantiate an object, initialize with the specified address
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String,System.Byte)">
            <summary>
            实例化一个对象，使用指定的地址及功能码初始化<br />
            Instantiate an object and initialize it with the specified address and function code
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
            <param name="function">默认的功能码信息</param>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.#ctor(System.String,System.Byte,System.Byte)">
            <summary>
            实例化一个对象，使用指定的地址，站号，功能码来初始化<br />
            Instantiate an object, use the specified address, station number, function code to initialize
            </summary>
            <param name="address">传入的地址信息，支持富地址，例如s=2;x=3;100</param>
            <param name="station">站号信息</param>
            <param name="function">默认的功能码信息</param>
        </member>
        <member name="P:HslCommunication.Core.Address.ModbusAddress.Station">
            <summary>
            获取或设置当前地址的站号信息<br />
            Get or set the station number information of the current address
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.ModbusAddress.Function">
            <summary>
            获取或设置当前地址携带的功能码<br />
            Get or set the function code carried by the current address
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.Parse(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.AddressAdd(System.Int32)">
            <summary>
            地址偏移指定的位置，返回一个新的地址对象<br />
            The address is offset by the specified position and a new address object is returned
            </summary>
            <param name="value">数据值信息</param>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.AddressAdd">
            <summary>
            地址偏移1，返回一个新的地址对象<br />
            The address is offset by 1 and a new address object is returned
            </summary>
            <returns>新增后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.ModbusAddress.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Address.S7AddressData">
            <summary>
            西门子的地址数据信息，主要包含数据代码，DB块，偏移地址，当处于写入时，Length无效<br />
            Address data information of Siemens, mainly including data code, DB block, offset address, when writing, Length is invalid
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.S7AddressData.DataCode">
            <summary>
            获取或设置等待读取的数据的代码<br />
            Get or set the code of the data waiting to be read
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Address.S7AddressData.DbBlock">
            <summary>
            获取或设置PLC的DB块数据信息<br />
            Get or set PLC DB data information
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.Parse(System.String,System.UInt16)">
            <summary>
            从指定的地址信息解析成真正的设备地址信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            计算特殊的地址信息<br />
            Calculate Special Address information
            </summary>
            <param name="address">字符串地址 -> String address</param>
            <param name="isCT">是否是定时器和计数器的地址</param>
            <returns>实际值 -> Actual value</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.ParseFrom(System.String)">
            <summary>
            从实际的西门子的地址里面解析出地址对象<br />
            Resolve the address object from the actual Siemens address
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Address.S7AddressData.ParseFrom(System.String,System.UInt16)">
            <summary>
            从实际的西门子的地址里面解析出地址对象<br />
            Resolve the address object from the actual Siemens address
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">读取的数据长度</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AdsNetMessage">
            <summary>
            倍福的ADS协议的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AdsNetMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AdsNetMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AdsNetMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AdsNetMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.AdsNetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AdsNetMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AdsNetMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AdsNetMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AlienMessage">
            <summary>
            异形消息对象，用于异形客户端的注册包接收以及验证使用
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AlienMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AlienMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AlienMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AlienMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AlienMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AlienMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AlienMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.AllenBradleyMessage">
            <summary>
            用于和 AllenBradley PLC 交互的消息协议类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleyMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AllenBradleyMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AllenBradleyMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.AllenBradleyMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleyMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleyMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.AllenBradleyMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.EFORTMessage">
            <summary>
            埃夫特机器人的消息对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.EFORTMessagePrevious">
            <summary>
            旧版的机器人的消息类对象，保留此类为了实现兼容
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessagePrevious.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessagePrevious.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.EFORTMessagePrevious.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.EFORTMessagePrevious.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FanucRobotMessage">
            <summary>
            发那科机器人的网络消息类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FanucRobotMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FanucRobotMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FanucRobotMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FanucRobotMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FanucRobotMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FanucRobotMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FanucRobotMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FetchWriteMessage">
            <summary>
            西门子Fetch/Write消息解析协议
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FetchWriteMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FetchWriteMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FetchWriteMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FetchWriteMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FetchWriteMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.FinsMessage">
            <summary>
            用于欧姆龙通信的Fins协议的消息解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FinsMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FinsMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FinsMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.FinsMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FinsMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FinsMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.FinsMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.HslMessage">
            <summary>
            本组件系统使用的默认的消息规则，说明解析和反解析规则的
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.HslMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.HslMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.HslMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.HslMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.HslMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.INetMessage">
            <summary>
            本系统的消息类，包含了各种解析规则，数据信息提取规则<br />
            The message class of this system contains various parsing rules and data information extraction rules
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength">
            <summary>
            消息头的指令长度，第一次接受数据的长度<br />
            Instruction length of the message header, the length of the first received data
            </summary>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes">
            <summary>
            从当前的头子节文件中提取出接下来需要接收的数据长度<br />
            Extract the length of the data to be received from the current header file
            </summary>
            <returns>返回接下来的数据内容长度</returns>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])">
            <summary>
            检查头子节的合法性<br />
            Check the legitimacy of the head subsection
            </summary>
            <param name="token">特殊的令牌，有些特殊消息的验证</param>
            <returns>是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity">
            <summary>
            获取头子节里的消息标识<br />
            Get the message ID in the header subsection
            </summary>
            <returns>消息标识</returns>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes">
            <summary>
            消息头字节<br />
            Message header byte
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes">
            <summary>
            消息内容字节<br />
            Message content byte
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.INetMessage.SendBytes">
            <summary>
            发送的字节信息<br />
            Byte information sent
            </summary>
        </member>
        <member name="T:HslCommunication.Core.IMessage.KukaVarProxyMessage">
            <summary>
            Kuka机器人的 KRC4 控制器中的服务器KUKAVARPROXY
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.KukaVarProxyMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.KukaVarProxyMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.KukaVarProxyMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.KukaVarProxyMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.KukaVarProxyMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.KukaVarProxyMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.KukaVarProxyMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.LsisFastEnetMessage">
            <summary>
            LSIS的PLC的FastEnet的消息定义
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.LsisFastEnetMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.LsisFastEnetMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.LsisFastEnetMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.LsisFastEnetMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.LsisFastEnetMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage">
            <summary>
            三菱的A兼容1E帧ASCII协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EAsciiMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage">
            <summary>
            三菱的A兼容1E帧协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecA1EBinaryMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage">
            <summary>
            基于MC协议的Qna兼容3E帧协议的ASCII通讯消息机制
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EAsciiMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage">
            <summary>
            三菱的Qna兼容3E帧协议解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.MelsecQnA3EBinaryMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.ModbusTcpMessage">
            <summary>
            Modbus-Tcp协议支持的消息解析类
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.ModbusTcpMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.ModbusTcpMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.OpenProtocolMessage">
            <summary>
            OpenProtocol协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.OpenProtocolMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.OpenProtocolMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.OpenProtocolMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.OpenProtocolMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.OpenProtocolMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.OpenProtocolMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.OpenProtocolMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.S7Message">
            <summary>
            西门子S7协议的消息解析规则
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.S7Message.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.S7Message.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.S7Message.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.S7Message.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.S7Message.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.S7Message.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.S7Message.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IMessage.SAMMessage">
            <summary>
            SAM身份证通信协议的消息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SAMMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SAMMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SAMMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SAMMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SAMMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.SAMMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Core.IMessage.SAMMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Core.IMessage.SAMMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Core.IReadWriteNet">
            <summary>
            所有的和设备或是交互类统一读写标准，公开了如何读写对方的一些api接口，并支持基于特性的读写操作<br />
            All unified read and write standards for devices and interaction classes, 
            expose how to read and write some API interfaces of each other, and support feature-based read and write operations
            </summary>
            <remarks>
            Modbus类，PLC类均实现了本接口，可以基于本接口实现统一所有的不同种类的设备的数据交互
            </remarks>
            <example>
            此处举例实现modbus，三菱，西门子三种设备的统一的数据交互
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\IReadWriteNet.cs" region="IReadWriteNetExample" title="IReadWriteNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.IReadWriteNet.LogNet">
            <summary>
            当前读写交互类的日志信息，实例化之后，就可以看到系统运行的详细信息。<br />
            Currently read and write interactive log information. After instantiation, you can see detailed information about system operation.
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IReadWriteNet.ConnectionId">
            <summary>
            当前连接的唯一ID号，默认为长度20的guid码加随机数组成，方便列表管理，也可以自己指定<br />
            The unique ID number of the current connection. The default is a 20-digit guid code plus a random number.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)">
            <summary>
            批量读取字节数组信息，需要指定地址和长度，返回原始的字节数组<br />
            Batch read byte array information, need to specify the address and length, return the original byte array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功<br />
            Write the original byte array data to the specified address, and return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取<see cref="T:System.Boolean"/>数组信息，需要指定地址和长度，返回<see cref="T:System.Boolean"/> 数组<br />
            Batch read <see cref="T:System.Boolean"/> array information, need to specify the address and length, return <see cref="T:System.Boolean"/> array
            </summary>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的 bool[] 数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)">
            <summary>
            读取单个的<see cref="T:System.Boolean"/>数据信息<br />
            Read a single <see cref="T:System.Boolean"/> data message
            </summary>
            <param name="address">数据地址</param>
            <returns>带有成功标识的 bool 值</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功<br />
            Batch write <see cref="T:System.Boolean"/> array data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)">
            <summary>
            写入单个的<see cref="T:System.Boolean"/>数据，返回是否成功<br />
            Write a single <see cref="T:System.Boolean"/> data, and return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)">
            <summary>
            读取16位的有符号的整型数据<br />
            Read 16-bit signed integer data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的short数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)">
            <summary>
            读取16位的有符号整型数组<br />
            Read 16-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的short数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)">
            <summary>
            读取16位的无符号整型<br />
            Read 16-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ushort数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)">
            <summary>
            读取16位的无符号整型数组<br />
            Read 16-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的数组长度</param>
            <returns>带有成功标识的ushort数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)">
            <summary>
            读取32位的有符号整型<br />
            Read 32-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的int数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)">
            <summary>
            读取32位有符号整型数组<br />
            Read 32-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的int数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)">
            <summary>
            读取32位的无符号整型<br />
            Read 32-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的uint数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)">
            <summary>
            读取32位的无符号整型数组<br />
            Read 32-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的uint数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)">
            <summary>
            读取64位的有符号整型<br />
            Read 64-bit signed integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的long数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)">
            <summary>
            读取64位的有符号整型数组<br />
            Read 64-bit signed integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的long数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)">
            <summary>
            读取64位的无符号整型<br />
            Read 64-bit unsigned integer
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的ulong数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)">
            <summary>
            读取64位的无符号整型的数组<br />
            Read 64-bit unsigned integer array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)">
            <summary>
            读取单浮点数据<br />
            Read single floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的float数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)">
            <summary>
            读取单浮点精度的数组<br />
            Read single floating point array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的float数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)">
            <summary>
            读取双浮点的数据<br />
            Read double floating point data
            </summary>
            <param name="address">起始地址</param>
            <returns>带有成功标识的double数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)">
            <summary>
            读取双浮点数据的数组<br />
            Read double floating point data array
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数组长度</param>
            <returns>带有成功标识的double数组</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)">
            <summary>
            读取字符串数据，默认为最常见的ASCII编码<br />
            Read string data, default is the most common ASCII encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <summary>
            使用指定的编码，读取字符串数据<br />
            Reads string data using the specified encoding
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <param name="encoding">指定的自定义的编码</param>
            <returns>带有成功标识的string数据</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadStringEncoding" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)">
            <summary>
            写入short数据，返回是否成功<br />
            Write short data, returns whether success
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])">
            <summary>
            写入short数组，返回是否成功<br />
            Write short array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt16Array" title="Int16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)">
            <summary>
            写入ushort数据，返回是否成功<br />
            Write ushort data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])">
            <summary>
            写入ushort数组，返回是否成功<br />
            Write ushort array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt16Array" title="UInt16类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)">
            <summary>
            写入int数据，返回是否成功<br />
            Write int data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])">
            <summary>
            写入int[]数组，返回是否成功<br />
            Write int array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt32Array" title="Int32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)">
            <summary>
            写入uint数据，返回是否成功<br />
            Write uint data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])">
            <summary>
            写入uint[]数组，返回是否成功<br />
            Write uint array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt32Array" title="UInt32类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)">
            <summary>
            写入long数据，返回是否成功<br />
            Write long data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])">
            <summary>
            写入long数组，返回是否成功<br />
            Write long array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteInt64Array" title="Int64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)">
            <summary>
            写入ulong数据，返回是否成功<br />
            Write ulong data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])">
            <summary>
            写入ulong数组，返回是否成功<br />
            Write ulong array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteUInt64Array" title="UInt64类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)">
            <summary>
            写入float数据，返回是否成功<br />
            Write float data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloat" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])">
            <summary>
            写入float数组，返回是否成功<br />
            Write float array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteFloatArray" title="Float类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)">
            <summary>
            写入double数据，返回是否成功<br />
            Write double data, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDouble" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])">
            <summary>
            写入double数组，返回是否成功<br />
            Write double array, return whether the write was successful
            </summary>
            <param name="address">起始地址</param>
            <param name="values">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteDoubleArray" title="Double类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)">
            <summary>
            写入字符串信息，编码为ASCII<br />
            Write string information, encoded as ASCII
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)">
            <summary>
            写入字符串信息，需要指定的编码信息<br />
            Write string information, need to specify the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)">
            <summary>
            写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为ASCII<br />
            Write string information of the specified length. If it exceeds the value, the string is truncated. 
            If the length is not enough, it is filled with 0 and the encoding is ASCII.
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <summary>
            写入指定长度的字符串信息，如果超出，就截断字符串，如果长度不足，那就补0操作，编码为指定的编码信息<br />
            Write string information of the specified length. If it exceeds the value, the string is truncated. If the length is not enough, 
            then the operation is complemented with 0 , you should specified the encoding information
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <param name="length">字符串的长度</param>
            <param name="encoding">指定的编码信息</param>
            <returns>带有成功标识的结果类对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString2" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)">
            <summary>
            读取自定义的数据类型，需要继承自IDataTransfer接口<br />
            Read custom data types, need to inherit from IDataTransfer interface
            </summary>
            <typeparam name="T">自定义的类型</typeparam>
            <param name="address">起始地址</param>
            <returns>带有成功标识的自定义类型数据</returns>
            <remarks>
            需要是定义一个类，选择好相对于的ByteTransform实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)">
            <summary>
            写入自定义类型的数据，该类型必须继承自IDataTransfer接口<br />
            Write data of a custom type, which must inherit from the IDataTransfer interface
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
            <remarks>
            需要是定义一个类，选择好相对于的<see cref="T:HslCommunication.IDataTransfer"/>实例，才能调用该方法。
            </remarks>
            <example>
            此处演示三菱的读取示例，先定义一个类，实现<see cref="T:HslCommunication.IDataTransfer"/>接口
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteCustomerExample" title="WriteCustomer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Read``1">
            <summary>
            读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Read the data content of the Hsl attribute. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadObjectExample" title="ReadObject示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)">
            <summary>
            写入支持Hsl特性的数据，返回是否写入成功，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考api文档说明<br />
            Write data that supports the Hsl attribute, and return whether the write was successful. The attribute is <see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>, please refer to the api documentation for details.
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            此处演示西门子的读取示例，先定义一个类，重点是将需要读取的数据，写入到属性的特性中去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ObjectDefineExample" title="特性实现示例" />
            接下来就可以实现数据的写入了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteObjectExample" title="WriteObject示例" />
            </example>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:HslCommunication.Core.Net.IRobotNet">
            <summary>
            所有的机器人的统一读写标准，统一的基本的读写操作<br />
            Unified reading and writing standards for all robots, unified basic reading and writing operations
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.IRobotNet.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)">
            <summary>
            根据地址读取机器人的原始的字节数据信息<br />
            Read the robot's original byte data information according to the address
            </summary>
            <param name="address">指定的地址信息，对于某些机器人无效</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)">
            <summary>
            根据地址读取机器人的字符串的数据信息<br />
            Read the string data information of the robot based on the address
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.Byte[])">
            <summary>
            根据地址，来写入设备的相关的字节数据<br />
            According to the address, to write the device related bytes data
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.String)">
            <summary>
            根据地址，来写入设备相关的字符串数据<br />
            According to the address, to write the device related string data
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAlienClient">
            <summary>
            异形客户端的基类，提供了基础的异形操作<br />
            The base class of the profiled client provides the basic profiled operation
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.#ctor">
            <summary>
            默认的无参构造方法<br />
            The default parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作<br />
            An action performed when a new request is received
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAlienClient.IsResponseAck">
            <summary>
            是否返回响应，默认为 <c>True</c><br />
            The default is <c>True</c>
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAlienClient.IsCheckPwd">
            <summary>
            是否统一检查密码，如果每个会话需要自己检查密码，就需要设置为false<br />
            Whether to check the password uniformly, if each session needs to check the password by itself, it needs to be set to false
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAlienClient.OnClientConnectedDelegate">
            <summary>
            客户上线的委托事件
            </summary>
            <param name="session">异形客户端的会话信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkAlienClient.OnClientConnected">
            <summary>
            当有服务器连接上来的时候触发<br />
            Triggered when a server is connected
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.GetResponse(System.Byte)">
            <summary>
            获取返回的命令信息
            </summary>
            <param name="status">状态</param>
            <returns>回发的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.IsClientOnline(HslCommunication.Core.Net.AlienSession)">
            <summary>
            检测当前的DTU是否在线
            </summary>
            <param name="session">当前的会话信息</param>
            <returns>当前的会话是否在线</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.IsClientPermission(HslCommunication.Core.Net.AlienSession)">
            <summary>
            检测当前的dtu是否允许登录
            </summary>
            <param name="session">当前的会话信息</param>
            <returns>当前的id是否可允许登录</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.SetPassword(System.Byte[])">
            <summary>
            设置密码，需要传入长度为6的字节数组<br />
            To set the password, you need to pass in an array of bytes of length 6
            </summary>
            <param name="password">密码信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.SetTrustClients(System.String[])">
            <summary>
            设置可信任的客户端列表，传入一个DTU的列表信息<br />
            Set up the list of trusted clients, passing in the list information for a DTU
            </summary>
            <param name="clients">客户端列表</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.ToString">
            <inheritdoc/>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusOk">
            <summary>
            状态登录成功
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusLoginRepeat">
            <summary>
            重复登录
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusLoginForbidden">
            <summary>
            禁止登录
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkAlienClient.StatusPasswodWrong">
            <summary>
            密码错误
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAlienClient.GetMsgFromCode(System.String,System.Int32)">
            <summary>
            获取错误的描述信息
            </summary>
            <param name="dtu">dtu信息</param>
            <param name="code">错误码</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkAuthenticationServerBase">
            <summary>
            带登录认证的服务器类，可以对连接的客户端进行筛选，放行用户名密码正确的连接<br />
            Server class with login authentication, which can filter connected clients and allow connections with correct username and password
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的信息，检查当前会话的用户名和密码<br />
            Additional check information when the client's socket logs in, check the username and password of the current session
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate">
            <summary>
            获取或设置是否对客户端启动账号认证<br />
            Gets or sets whether to enable account authentication on the client
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.AddAccount(System.String,System.String)">
            <summary>
            新增账户，如果想要启动账户登录，必须将<see cref="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate"/>设置为<c>True</c>。<br />
            Add an account. If you want to activate account login, you must set <see cref="P:HslCommunication.Core.Net.NetworkAuthenticationServerBase.IsUseAccountCertificate"/> to <c> True </c>
            </summary>
            <param name="userName">账户名称</param>
            <param name="password">账户名称</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.DeleteAccount(System.String)">
            <summary>
            删除一个账户的信息<br />
            Delete an account's information
            </summary>
            <param name="userName">账户名称</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkAuthenticationServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkBase">
            <summary>
            本系统所有网络类的基类，该类为抽象类，无法进行实例化，如果想使用里面的方法来实现自定义的网络通信，请通过继承使用。<br />
            The base class of all network classes in this system. This class is an abstract class and cannot be instantiated. 
            If you want to use the methods inside to implement custom network communication, please use it through inheritance.
            </summary>
            <remarks>
            本类提供了丰富的底层数据的收发支持，包含<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>消息的接收，<c>MQTT</c>以及<c>Redis</c>,<c>websocket</c>协议的实现
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.#ctor">
            <summary>
            实例化一个NetworkBase对象，令牌的默认值为空，都是0x00<br />
            Instantiate a NetworkBase object, the default value of the token is empty, both are 0x00
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkBase.LogNet">
            <summary>
            组件的日志工具，支持日志记录，只要实例化后，当前网络的基本信息，就以<see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>等级进行输出<br />
            The component's logging tool supports logging. As long as the instantiation of the basic network information, the output will be output at <see cref="F:HslCommunication.LogNet.HslMessageDegree.DEBUG"/>
            </summary>
            <remarks>
            只要实例化即可以记录日志，实例化的对象需要实现接口 <see cref="T:HslCommunication.LogNet.ILogNet"/> ，本组件提供了三个日志记录类，你可以实现基于 <see cref="T:HslCommunication.LogNet.ILogNet"/>  的对象。</remarks>
            <example>
            如下的实例化适用于所有的Network及其派生类，以下举两个例子，三菱的设备类及服务器类
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample1" title="LogNet示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="LogNetExample2" title="LogNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkBase.Token">
            <summary>
            网络类的身份令牌，在hsl协议的模式下会有效，在和设备进行通信的时候是无效的<br />
            Network-type identity tokens will be valid in the hsl protocol mode and will not be valid when communicating with the device
            </summary>
            <remarks>
            适用于Hsl协议相关的网络通信类，不适用于设备交互类。
            </remarks>
            <example>
            此处以 <see cref="T:HslCommunication.Enthernet.NetSimplifyServer"/> 服务器类及 <see cref="T:HslCommunication.Enthernet.NetSimplifyClient"/> 客户端类的令牌设置举例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenClientExample" title="Client示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="TokenServerExample" title="Server示例" />
            </example>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkBase.CoreSocket">
            <summary>
            对客户端而言是的通讯用的套接字，对服务器来说是用于侦听的套接字<br />
            A communication socket for the client, or a listening socket for the server
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize">
            <summary>
            文件传输的时候的缓存大小，直接影响传输的速度，值越大，传输速度越快，越占内存，默认为100K大小<br />
            The size of the cache during file transfer directly affects the speed of the transfer. The larger the value, the faster the transfer speed and the more memory it takes. The default size is 100K.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ThreadPoolSocketCheckTimeOut(System.Object)">
            <summary>
            检查网络套接字是否操作超时，传入的参数需要是<see cref="T:HslCommunication.HslTimeOut"/>类型，封装socket操作。<br />
            Check if the operation of the network socket has timed out. The parameters passed in need to be of type <see cref = "T:HslCommunication.HslTimeOut" /> to encapsulate the socket operation.
            </summary>
            <param name="obj">通常是 <see cref="T:HslCommunication.HslTimeOut"/> 对象 </param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Receive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            接收固定长度的字节数组，允许指定超时时间，默认为60秒，当length大于0时，接收固定长度的数据内容，当length小于0时，接收不大于1024长度的随机数据信息<br />
            Receiving a fixed-length byte array, allowing a specified timeout time. The default is 60 seconds. When length is greater than 0, 
            fixed-length data content is received. When length is less than 0, random data information of a length not greater than 1024 is received.
            </summary>
            <param name="socket">网络通讯的套接字<br />Network communication socket</param>
            <param name="length">准备接收的数据长度，当length大于0时，接收固定长度的数据内容，当length小于0时，接收不大于1024长度的随机数据信息</param>
            <param name="timeOut">单位：毫秒，超时时间，默认为60秒，如果设置小于0，则不检查超时时间</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <returns>包含了字节数据的结果类</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Int32)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符，默认超时时间为60秒，也即是60000，单位是毫秒<br />
            To receive a line of command data, you need to specify the terminator yourself. The default timeout is 60 seconds, which is 60,000, in milliseconds.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode">结束符信息</param>
            <param name="timeout">超时时间，默认为60000，单位为毫秒，也就是60秒</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveCommandLineFromSocket(System.Net.Sockets.Socket,System.Byte,System.Byte,System.Int32)">
            <summary>
            接收一行命令数据，需要自己指定这个结束符，默认超时时间为60秒，也即是60000，单位是毫秒<br />
            To receive a line of command data, you need to specify the terminator yourself. The default timeout is 60 seconds, which is 60,000, in milliseconds.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endCode1">结束符1信息</param>
            <param name="endCode2">结束符2信息</param>
            /// <param name="timeout">超时时间，默认无穷大，单位毫秒</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveByMessage(System.Net.Sockets.Socket,System.Int32,HslCommunication.Core.IMessage.INetMessage,System.Action{System.Int64,System.Int64})">
            <summary>
            接收一条完整的 <seealso cref="T:HslCommunication.Core.IMessage.INetMessage"/> 数据内容，需要指定超时时间，单位为毫秒。 <br />
            Receive a complete <seealso cref="T:HslCommunication.Core.IMessage.INetMessage"/> data content, Need to specify a timeout period in milliseconds
            </summary>
            <param name="socket">网络的套接字</param>
            <param name="timeOut">超时时间，单位：毫秒</param>
            <param name="netMessage">消息的格式定义</param>
            <param name="reportProgress">接收消息的时候的进度报告</param>
            <returns>带有是否成功的byte数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            发送消息给套接字，直到完成的时候返回，经过测试，本方法是线程安全的。<br />
            Send a message to the socket until it returns when completed. After testing, this method is thread-safe.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="data">字节数据</param>
            <returns>发送是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.Send(System.Net.Sockets.Socket,System.Byte[],System.Int32,System.Int32)">
            <summary>
            发送消息给套接字，直到完成的时候返回，经过测试，本方法是线程安全的。<br />
            Send a message to the socket until it returns when completed. After testing, this method is thread-safe.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="data">字节数据</param>
            <param name="offset">偏移的位置信息</param>
            <param name="size">发送的数据总数</param>
            <returns>发送是否成功的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，默认超时时间为10秒钟，需要指定ip地址以及端口号信息<br />
            Create a new socket object and connect to the remote address. The default timeout is 10 seconds. You need to specify the IP address and port number.
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.String,System.Int32,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，需要指定ip地址以及端口号信息，还有超时时间，单位是毫秒<br />
            To create a new socket object and connect to a remote address, you need to specify the IP address and port number information, and the timeout period in milliseconds
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="timeOut">连接的超时时间</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CreateSocketAndConnect(System.Net.IPEndPoint,System.Int32)">
            <summary>
            创建一个新的socket对象并连接到远程的地址，需要指定远程终结点，超时时间（单位是毫秒）<br />
            To create a new socket object and connect to a remote address, you need to specify the remote endpoint and the timeout period (in milliseconds)
            </summary>
            <param name="endPoint">连接的目标终结点</param>
            <param name="timeOut">连接的超时时间</param>
            <returns>返回套接字的封装结果对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkBase.cs" region="CreateSocketAndConnectExample" title="创建连接示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReadStream(System.IO.Stream,System.Byte[])">
            <summary>
            读取流中的数据到缓存区，读取的长度需要按照实际的情况来判断<br />
            Read the data in the stream to the buffer area. The length of the read needs to be determined according to the actual situation.
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>带有成功标志的读取数据长度</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStream(System.IO.Stream,System.Byte[])">
            <summary>
            将缓冲区的数据写入到流里面去<br />
            Write the buffer data to the stream
            </summary>
            <param name="stream">数据流</param>
            <param name="buffer">缓冲区</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.CheckRemoteToken(System.Byte[])">
            <summary>
            检查当前的头子节信息的令牌是否是正确的，仅用于某些特殊的协议实现<br />
            Check whether the token of the current header subsection information is correct, only for some special protocol implementations
            </summary>
            <param name="headBytes">头子节数据</param>
            <returns>令牌是验证成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBaseAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send the byte data and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="headCode">头指令</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendBytesAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.Byte[])">
            <summary>
            [自校验] 发送字节数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send the byte data and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String)">
            <summary>
            [自校验] 直接发送字符串数据并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-checking] Send string data directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="send">发送的数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStringAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String[])">
            <summary>
            [自校验] 直接发送字符串数组并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send string array directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="sends">发送的字符串数组</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendAccountAndCheckReceive(System.Net.Sockets.Socket,System.Int32,System.String,System.String)">
            <summary>
            [自校验] 直接发送字符串数组并确认对方接收完成数据，如果结果异常，则结束通讯<br />
            [Self-check] Send string array directly and confirm that the other party has received the completed data. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="customer">用户指令</param>
            <param name="name">用户名</param>
            <param name="pwd">密码</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveAndCheckBytes(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 接收一条完整的同步数据，包含头子节和内容字节，基础的数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a complete synchronization data, including header subsection and content bytes, basic data, if the result is abnormal, the communication ends
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">超时时间设置，如果为负数，则不检查超时</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException">result</exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一个字符串数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a string of data from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">接收数据的超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveStringArrayContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一个字符串数组，如果结果异常，则结束通讯<br />
            [Self-check] Receive an array of strings from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字</param>
            <param name="timeOut">接收数据的超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveBytesContentFromSocket(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            [自校验] 从网络中接收一串字节数据，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a string of byte data from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">套接字的网络</param>
            <param name="timeout">超时时间</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveLong(System.Net.Sockets.Socket)">
            <summary>
            从网络中接收Long数据<br />
            Receive Long data from the network
            </summary>
            <param name="socket">套接字网络</param>
            <returns>long数据结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendLong(System.Net.Sockets.Socket,System.Int64)">
            <summary>
            将long数据发送到套接字<br />
            Send long data to the socket
            </summary>
            <param name="socket">网络套接字</param>
            <param name="value">long数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.SendStreamToSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            发送一个流的所有数据到指定的网络套接字，需要指定发送的数据长度，支持按照百分比的进度报告<br />
            Send all the data of a stream to the specified network socket. You need to specify the length of the data to be sent. It supports the progress report in percentage.
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">内存流</param>
            <param name="receive">发送的数据长度</param>
            <param name="report">进度报告的委托</param>
            <param name="reportByPercent">进度报告是否按照百分比报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.WriteStreamFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Int64,System.Action{System.Int64,System.Int64},System.Boolean)">
            <summary>
            从套接字中接收所有的数据然后写入到指定的流当中去，需要指定数据的长度，支持按照百分比进行进度报告<br />
            Receives all data from the socket and writes it to the specified stream. The length of the data needs to be specified, and progress reporting is supported in percentage.
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">数据流</param>
            <param name="totalLength">所有数据的长度</param>
            <param name="report">进度报告</param>
            <param name="reportByPercent">进度报告是否按照百分比</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveWebSocketPayload(System.Net.Sockets.Socket)">
            <summary>
            从socket接收一条完整的websocket数据，返回<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>的数据信息<br />
            Receive a complete websocket data from the socket, return the data information of the <see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>
            </summary>
            <param name="socket">网络套接字</param>
            <returns>包含websocket消息的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveFrameWebSocketPayload(System.Net.Sockets.Socket)">
            <summary>
            从socket接收一条<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>片段数据，返回<see cref="T:HslCommunication.WebSocket.WebSocketMessage"/>的数据信息和是否最后一条数据内容<br />
            Receive a piece of <see cref = "T:HslCommunication.WebSocket.WebSocketMessage" /> fragment data from the socket, return the data information of <see cref = "T:HslCommunication.WebSocket.WebSocketMessage" /> and whether the last data content
            </summary>
            <param name="socket">网络套接字</param>
            <returns>包含websocket消息的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttRemainingLength(System.Net.Sockets.Socket)">
            <summary>
            基于MQTT协议，从网络套接字中接收剩余的数据长度<br />
            Receives the remaining data length from the network socket based on the MQTT protocol
            </summary>
            <param name="socket">网络套接字</param>
            <returns>网络中剩余的长度数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveMqttMessage(System.Net.Sockets.Socket,System.Action{System.Int64,System.Int64})">
            <summary>
            接收一条完成的MQTT协议的报文信息，包含控制码和负载数据<br />
            Receive a message of a completed MQTT protocol, including control code and payload data
            </summary>
            <param name="socket">网络套接字</param>
            <param name="reportProgress">进度报告，第一个参数是已完成的字节数量，第二个参数是总字节数量。</param>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommandString(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            接收一行基于redis协议的字符串的信息，需要指定固定的长度<br />
            Receive a line of information based on the redis protocol string, you need to specify a fixed length
            </summary>
            <param name="socket">网络套接字</param>
            <param name="length">字符串的长度</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveRedisCommand(System.Net.Sockets.Socket)">
            <summary>
            从网络接收一条完整的redis报文的消息<br />
            Receive a complete redis message from the network
            </summary>
            <param name="socket">网络套接字</param>
            <returns>接收的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ReceiveHslMessage(System.Net.Sockets.Socket)">
            <summary>
            接收一条hsl协议的数据信息，自动解析，解压，解码操作，获取最后的实际的数据，接收结果依次为暗号，用户码，负载数据<br />
            Receive a piece of hsl protocol data information, automatically parse, decompress, and decode operations to obtain the last actual data. 
            The result is a opCode, user code, and payload data in order.
            </summary>
            <param name="socket">网络套接字</param>
            <returns>接收结果，依次为暗号，用户码，负载数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.ToString">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkBase.ThreadPoolTimeoutCheckCount">
            <summary>
            获取当前进入线程池（检查超时判断）的数量<br />
            Get the current number of thread pools (check timeout judgment)
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkBase.GetIpAddressHostName(System.String)">
            <summary>
            通过主机名或是IP地址信息，获取到真实的IP地址信息<br />
            Obtain the real IP address information through the host name or IP address information
            </summary>
            <param name="hostName">主机名或是IP地址</param>
            <returns>IP地址信息</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase">
            <summary>
            所有虚拟的数据服务器的基类，提供了基本的数据读写，存储加载的功能方法，具体的字节读写需要继承重写。<br />
            The base class of all virtual data servers provides basic methods for reading and writing data and storing and loading. 
            Specific byte reads and writes need to be inherited and override.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.#ctor">
            <summary>
            实例化一个默认的数据服务器的对象<br />
            Instantiate an object of the default data server
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SaveDataPool(System.String)">
            <summary>
            将本系统的数据池数据存储到指定的文件<br />
            Store the data pool data of this system to the specified file
            </summary>
            <param name="path">指定文件的路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.LoadDataPool(System.String)">
            <summary>
            从文件加载数据池信息<br />
            Load datapool information from a file
            </summary>
            <param name="path">文件路径</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.Security.SecurityException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.LoadFromBytes(System.Byte[])">
            <summary>
            从字节数据加载数据信息，需要进行重写方法<br />
            Loading data information from byte data requires rewriting method
            </summary>
            <param name="content">字节数据</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SaveToBytes">
            <summary>
            将数据信息存储到字节数组去，需要进行重写方法<br />
            To store data information into a byte array, a rewrite method is required
            </summary>
            <returns>所有的内容</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.IReadWriteNet.ConnectionId"/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase.DataReceivedDelegate">
            <summary>
            当接收到来自客户的数据信息时触发的对象，该数据可能来自tcp或是串口<br />
            The object that is triggered when receiving data information from the customer, the data may come from tcp or serial port
            </summary>
            <param name="sender">本服务器对象</param>
            <param name="data">实际的数据信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkDataServerBase.OnDataReceived">
            <summary>
            接收到数据的时候就触发的事件<br />
            An event that is triggered when data is received
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.RaiseDataReceived(System.Byte[])">
            <summary>
            触发一个数据接收的事件信息<br />
            Event information that triggers a data reception
            </summary>
            <param name="receive">接收数据信息</param>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDataServerBase.DataSendDelegate">
            <summary>
            数据发送的时候委托<br />
            Show DataSend To PLC
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="data">数据内容</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkDataServerBase.OnDataSend">
            <summary>
            数据发送的时候就触发的事件<br />
            Events that are triggered when data is sent
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.RaiseDataSend(System.Byte[])">
            <summary>
            触发一个数据发送的事件信息<br />
            Event information that triggers a data transmission
            </summary>
            <param name="receive">数据内容</param>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端登录后，在Ip信息的过滤后，然后触发本方法，进行后续的数据接收，处理，并返回相关的数据信息<br />
            When the client logs in, after filtering the IP information, this method is then triggered to perform subsequent data reception, 
            processing, and return related data information
            </summary>
            <param name="socket">网络套接字</param>
            <param name="endPoint">终端节点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作，此处进行账户的安全验证<br />
            The operation performed when a new request is received, and the account security verification is performed here
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.SetTrustedIpAddress(System.Collections.Generic.List{System.String})">
            <summary>
            设置并启动受信任的客户端登录并读写，如果为null，将关闭对客户端的ip验证<br />
            Set and start the trusted client login and read and write, if it is null, the client's IP verification will be turned off
            </summary>
            <param name="clients">受信任的客户端列表</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.CheckIpAddressTrusted(System.String)">
            <summary>
            检查该Ip地址是否是受信任的<br />
            Check if the IP address is trusted
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <returns>是受信任的返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.GetTrustedClients">
            <summary>
            获取受信任的客户端列表<br />
            Get a list of trusted clients
            </summary>
            <returns>字符串数据信息</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDataServerBase.OnlineCount">
            <summary>
            获取在线的客户端的数量<br />
            Get the number of clients online
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.AddClient(HslCommunication.Core.Net.AppSession)">
            <summary>
            新增一个在线的客户端信息<br />
            Add an online client information
            </summary>
            <param name="session">会话内容</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.RemoveClient(HslCommunication.Core.Net.AppSession)">
            <summary>
            移除一个在线的客户端信息<br />
            Remove an online client message
            </summary>
            <param name="session">会话内容</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.CloseAction">
            <summary>
            关闭之后进行的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDataServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDeviceBase">
            <summary>
            设备交互类的基类，实现了<see cref="T:HslCommunication.Core.IReadWriteNet"/>接口的基础方法方法，需要使用继承重写来实现字节读写，bool读写操作。<br />
            The base class of the device interaction class, which implements the basic methods of the <see cref="T:HslCommunication.Core.IReadWriteNet"/> interface, 
            requires inheritance rewriting to implement byte read and write, and bool read and write operations.
            </summary>
            <remarks>需要继承实现采用使用。</remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength">
            <summary>
            一个字单位的数据表示的地址长度，西门子为2，三菱，欧姆龙，modbusTcp就为1，AB PLC无效<br />
            The address length represented by one word of data, Siemens is 2, Mitsubishi, Omron, modbusTcp is 1, AB PLC is invalid
            </summary>
            <remarks>
            对设备来说，一个地址的数据对应的字节数，或是1个字节或是2个字节，通常是这两个选择
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDeviceSoloBase">
            <summary>
            基于单次无协议的网络交互的基类，通常是串口协议扩展成网口协议的基类<br />
            Base class based on a single non-protocol network interaction, usually the base class that the serial port protocol is extended to the network port protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceSoloBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceSoloBase.ReceiveSolo(System.Net.Sockets.Socket,System.Boolean)">
            <summary>
            从串口接收一串数据信息，可以指定是否一定要接收到数据<br />
            Receive a string of data information from the serial port, you can specify whether you must receive data
            </summary>
            <param name="socket">串口对象</param>
            <param name="awaitData">是否必须要等待数据返回</param>
            <returns>结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceSoloBase.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDeviceSoloBase.SleepTime">
            <inheritdoc cref="P:HslCommunication.Serial.SerialBase.SleepTime"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDeviceSoloBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkDoubleBase">
            <summary>
            支持长连接，短连接两个模式的通用客户端基类 <br />
            Universal client base class that supports long connections and short connections to two modes
            </summary>
            <example>
            无，请使用继承类实例化，然后进行数据交互，当前的类并没有具体的实现。
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.#ctor">
            <summary>
            默认的无参构造函数 <br />
            Default no-parameter constructor
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.receiveTimeOut">
            <summary>
            接收数据的超时时间，单位：毫秒
            <br />
            Timeout for receiving data, unit: millisecond
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.isPersistentConn">
            <summary>
            是否是长连接的状态<br />
            Whether it is a long connection state
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.InteractiveLock">
            <summary>
            交互的混合锁，保证交互操作的安全性<br />
            Interactive hybrid locks to ensure the security of interactive operations
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.IsSocketError">
            <summary>
            指示长连接的套接字是否处于错误的状态<br />
            Indicates if the long-connected socket is in the wrong state
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary">
            <summary>
            设置日志记录报文是否二进制，如果为False，那就使用ASCII码<br />
            Set whether the log message is binary, if it is False, then use ASCII code
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetNewNetMessage">
            <summary>
            获取一个新的消息对象的方法，需要在继承类里面进行重写<br />
            The method to get a new message object needs to be overridden in the inheritance class
            </summary>
            <returns>消息类对象</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform">
            <summary>
            当前的数据变换机制，当你需要从字节数据转换类型数据的时候需要。<br />
            The current data transformation mechanism is required when you need to convert type data from byte data.
            </summary>
            <example>
            主要是用来转换数据类型的，下面仅仅演示了2个方法，其他的类型转换，类似处理。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ByteTransform" title="ByteTransform示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，单位是毫秒 <br />
            Gets or sets the timeout for the connection, in milliseconds
            </summary>
            <example>
            设置1秒的超时的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectTimeOutExample" title="ConnectTimeOut示例" />
            </example>
            <remarks>
            不适用于异形模式的连接。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut">
            <summary>
            获取或设置接收服务器反馈的时间，如果为负数，则不接收反馈 <br />
            Gets or sets the time to receive server feedback, and if it is a negative number, does not receive feedback
            </summary>
            <example>
            设置1秒的接收超时的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReceiveTimeOutExample" title="ReceiveTimeOut示例" />
            </example>
            <remarks>
            超时的通常原因是服务器端没有配置好，导致访问失败，为了不卡死软件，所以有了这个超时的属性。
            </remarks>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress">
            <summary>
            获取或是设置远程服务器的IP地址，如果是本机测试，那么需要设置为127.0.0.1 <br />
            Get or set the IP address of the remote server. If it is a local test, then it needs to be set to 127.0.0.1
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改
            </remarks>
            <example>
            以下举例modbus-tcp的短连接及动态更改ip地址的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="IpAddressExample" title="IpAddress示例" />
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.Port">
            <summary>
            获取或设置服务器的端口号，具体的值需要取决于对方的配置<br />
            Gets or sets the port number of the server. The specific value depends on the configuration of the other party.
            </summary>
            <remarks>
            最好实在初始化的时候进行指定，当使用短连接的时候，支持动态更改，切换；当使用长连接后，无法动态更改
            </remarks>
            <example>
            动态更改请参照IpAddress属性的更改。
            </example>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.IReadWriteNet.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkDoubleBase.AlienSession">
            <summary>
            当前的异形连接对象，如果设置了异形连接的话，仅用于异形模式的情况使用<br />
            The current alien connection object, if alien connection is set, is only used in the case of alien mode
            </summary>
            <remarks>
            具体的使用方法请参照Demo项目中的异形modbus实现。
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.SetPersistentConnection">
            <summary>
            在读取数据之前可以调用本方法将客户端设置为长连接模式，相当于跳过了ConnectServer的结果验证，对异形客户端无效，当第一次进行通信时再进行创建连接请求。<br />
            Before reading the data, you can call this method to set the client to the long connection mode, which is equivalent to skipping the result verification of ConnectServer, 
            and it is invalid for the alien client. When the first communication is performed, the connection creation request is performed.
            </summary>
            <example>
            以下的方式演示了另一种长连接的机制
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="SetPersistentConnectionExample" title="SetPersistentConnection示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.IpAddressPing">
            <summary>
            对当前设备的IP地址进行PING的操作，返回PING的结果，正常来说，返回<see cref="F:System.Net.NetworkInformation.IPStatus.Success"/><br />
            PING the IP address of the current device and return the PING result. Normally, it returns <see cref="F:System.Net.NetworkInformation.IPStatus.Success"/>
            </summary>
            <returns>返回PING的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer">
            <summary>
            尝试连接远程的服务器，如果连接成功，就切换短连接模式到长连接模式，后面的每次请求都共享一个通道，使得通讯速度更快速<br />
            Try to connect to a remote server. If the connection is successful, switch the short connection mode to the long connection mode. 
            Each subsequent request will share a channel, making the communication speed faster.
            </summary>
            <returns>返回连接结果，如果失败的话（也即IsSuccess为False），包含失败信息</returns>
            <example>
              简单的连接示例，调用该方法后，连接设备，创建一个长连接的对象，后续的读写操作均公用一个连接对象。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect1" title="连接设备" />
              如果想知道是否连接成功，请参照下面的代码。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="Connect2" title="判断连接结果" />
            </example> 
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer(HslCommunication.Core.Net.AlienSession)">
            <summary>
            使用指定的套接字创建异形客户端，在异形客户端的模式下，网络通道需要被动创建。<br />
            Use the specified socket to create the alien client. In the alien client mode, the network channel needs to be created passively.
            </summary>
            <param name="session">异形客户端对象，查看<seealso cref="T:HslCommunication.Core.Net.NetworkAlienClient"/>类型创建的客户端</param>
            <returns>通常都为成功</returns>
            <example>
              简单的创建示例。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect1" title="连接设备" />
              如果想知道是否创建成功。通常都是成功。
              <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="AlienConnect2" title="判断连接结果" />
            </example> 
            <remarks>
            不能和之前的长连接和短连接混用，详细参考 Demo程序 
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectClose">
            <summary>
            手动断开与远程服务器的连接，如果当前是长连接模式，那么就会切换到短连接模式<br />
            Manually disconnect from the remote server, if it is currently in long connection mode, it will switch to short connection mode
            </summary>
            <returns>关闭连接，不需要查看IsSuccess属性查看</returns>
            <example>
            直接关闭连接即可，基本上是不需要进行成功的判定
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ConnectCloseExample" title="关闭连接结果" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            根据实际的协议选择是否重写本方法，有些协议在创建连接之后，需要进行一些初始化的信号握手，才能最终建立网络通道。<br />
            Whether to rewrite this method is based on the actual protocol. Some protocols require some initial signal handshake to establish a network channel after the connection is created.
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否初始化成功，依据具体的协议进行重写</returns>
            <example>
            有些协议不需要握手信号，比如三菱的MC协议，Modbus协议，西门子和欧姆龙就存在握手信息，此处的例子是继承本类后重写的西门子的协议示例
            <code lang="cs" source="HslCommunication_Net45\Profinet\Siemens\SiemensS7Net.cs" region="NetworkDoubleBase Override" title="西门子重连示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <summary>
            根据实际的协议选择是否重写本方法，有些协议在断开连接之前，需要发送一些报文来关闭当前的网络通道<br />
            Select whether to rewrite this method according to the actual protocol. Some protocols need to send some packets to close the current network channel before disconnecting.
            </summary>
            <param name="socket">网络套接字</param>
            <example>
            目前暂无相关的示例，组件支持的协议都不用实现这个方法。
            </example>
            <returns>当断开连接时额外的操作结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraAfterReadFromCoreServer(HslCommunication.OperateResult)">
            <summary>
            和服务器交互完成的时候调用的方法，可以根据读写结果进行一些额外的操作，具体的操作需要根据实际的需求来重写实现<br />
            The method called when the interaction with the server is completed can perform some additional operations based on the read and write results. 
            The specific operations need to be rewritten according to actual needs.
            </summary>
            <param name="read">读取结果</param>
        </member>
        <member name="F:HslCommunication.Core.Net.NetworkDoubleBase.isUseAccountCertificate">
            <summary>
            是否使用账号登录，这个账户登录的功能是<c>HSL</c>组件创建的服务器特有的功能。<br />
            Whether to log in using an account. The function of this account login is a server-specific function created by the <c> HSL </c> component.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.SetLoginAccount(System.String,System.String)">
            <summary>
            设置当前的登录的账户名和密码信息，并启用账户验证的功能，账户名为空时设置不生效<br />
            Set the current login account name and password information, and enable the account verification function. The account name setting will not take effect when it is empty
            </summary>
            <param name="userName">账户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.AccountCertificate(System.Net.Sockets.Socket)">
            <summary>
            认证账号，根据已经设置的用户名和密码，进行发送服务器进行账号认证。<br />
            Authentication account, according to the user name and password that have been set, sending server for account authentication.
            </summary>
            <param name="socket">套接字</param>
            <returns>认证结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket">
            <summary>
            获取本次操作的可用的网络通道，如果是短连接，就重新生成一个新的网络通道，如果是长连接，就复用当前的网络通道。<br />
            Obtain the available network channels for this operation. If it is a short connection, a new network channel is regenerated. 
            If it is a long connection, the current network channel is reused.
            </summary>
            <returns>是否成功，如果成功，使用这个套接字</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.CreateSocketAndInitialication">
            <summary>
            尝试连接服务器，如果成功，并执行<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)"/>的初始化方法，并返回最终的结果。<br />
            Attempt to connect to the server, if successful, and execute the initialization method of <see cref = "M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)" />, and return the final result.
            </summary>
            <returns>带有socket的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            将数据报文发送指定的网络通道上，根据当前指定的<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>类型，返回一条完整的数据指令<br />
            Sends a data message to the specified network channel, and returns a complete data command according to the currently specified <see cref = "T:HslCommunication.Core.IMessage.INetMessage" /> type
            </summary>
            <param name="socket">指定的套接字</param>
            <param name="send">发送的完整的报文信息</param>
            <remarks>
            无锁的基于套接字直接进行叠加协议的操作。
            </remarks>
            <example>
            假设你有一个自己的socket连接了设备，本组件可以直接基于该socket实现modbus读取，三菱读取，西门子读取等等操作，前提是该服务器支持多协议，虽然这个需求听上去比较变态，但本组件支持这样的操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample1" title="ReadFromCoreServer示例" />
            </example>
            <returns>接收的完整的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ReadFromCoreServer(System.Byte[])">
            <summary>
            将数据发送到当前的网络通道中，并从网络通道中接收一个<see cref="T:HslCommunication.Core.IMessage.INetMessage"/>指定的完整的报文，网络通道将根据<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket"/>方法自动获取，本方法是线程安全的。<br />
            Send data to the current network channel and receive a complete message specified by <see cref = "T:HslCommunication.Core.IMessage.INetMessage" /> from the network channel. 
            The network channel will be automatically obtained according to the <see cref = "M:HslCommunication.Core.Net.NetworkDoubleBase.GetAvailableSocket" /> method This method is thread-safe.
            </summary>
            <param name="send">发送的完整的报文信息</param>
            <returns>接收的完整的报文信息</returns>
            <remarks>
            本方法用于实现本组件还未实现的一些报文功能，例如有些modbus服务器会有一些特殊的功能码支持，需要收发特殊的报文，详细请看示例
            </remarks>
            <example>
            此处举例有个modbus服务器，有个特殊的功能码0x09，后面携带子数据0x01即可，发送字节为 0x00 0x00 0x00 0x00 0x00 0x03 0x01 0x09 0x01
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDoubleBase.cs" region="ReadFromCoreServerExample2" title="ReadFromCoreServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.Dispose(System.Boolean)">
            <summary>
            释放当前的资源，并自动关闭长连接，如果设置了的话
            </summary>
            <param name="disposing">是否释放托管的资源信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.Dispose">
            <summary>
            释放当前的资源
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkDoubleBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkFileServerBase">
            <summary>
            文件服务器类的基类，为直接映射文件模式和间接映射文件模式提供基础的方法支持
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetFileMarksFromDictionaryWithFileName(System.String)">
            <summary>
            获取当前文件的读写锁，如果没有会自动创建，文件名应该是guid文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="fileName">完整的文件路径</param>
            <returns>读写锁</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReceiveInformationHead(System.Net.Sockets.Socket)">
            <summary>
            接收本次操作的信息头数据
            </summary>
            <param name="socket">网络套接字</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.CreateRandomFileName">
            <summary>
            获取一个随机的文件名，由GUID码和随机数字组成
            </summary>
            <returns>文件名</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFilePath(System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][Factory][Group][Id] 信息
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ReturnAbsoluteFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回服务器的绝对路径，包含根目录的信息  [Root Dir][Factory][Group][Id][FileName] 信息
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetRelativeFileName(System.String,System.String,System.String,System.String)">
            <summary>
            返回相对路径的名称
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.MoveFileToNewFile(System.String,System.String)">
            <summary>
            移动一个文件到新的文件去
            </summary>
            <param name="fileNameOld">旧的文件名称</param>
            <param name="fileNameNew">新的文件名称</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.DeleteFileAndCheck(System.Net.Sockets.Socket,System.String)">
            <summary>
            删除文件并回发确认信息，如果结果异常，则结束通讯
            </summary>
            <param name="socket">网络套接字</param>
            <param name="fullname">完整路径的文件名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkFileServerBase.FileUploadDelegate">
            <summary>
            文件上传的委托
            </summary>
            <param name="fileInfo">文件的基本信息</param>
        </member>
        <member name="E:HslCommunication.Core.Net.NetworkFileServerBase.OnFileUploadEvent">
            <summary>
            文件上传的事件，当文件上传的时候触发。
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.OnFileUpload(HslCommunication.Enthernet.FileServerInfo)">
            <summary>
            触发一个文件上传的事件。
            </summary>
            <param name="fileInfo">文件的基本信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.StartInitialization">
            <summary>
            服务器启动时的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.CheckFolderAndCreate">
            <summary>
            检查文件夹是否存在，不存在就创建
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkFileServerBase.FilesDirectoryPath">
            <summary>
            文件所存储的路径
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkFileServerBase.FileCacheSize">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetDirectoryFiles(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件列表</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.GetDirectories(System.String,System.String,System.String)">
            <summary>
            获取文件夹的所有文件夹列表
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>文件夹列表</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkFileServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkServerBase">
            <summary>
            服务器程序的基础类，提供了启动服务器的基本实现，方便后续的扩展操作。<br />
            The basic class of the server program provides the basic implementation of starting the server to facilitate subsequent expansion operations.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.IsStarted">
            <summary>
            服务器引擎是否启动<br />
            Whether the server engine is started
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkServerBase.Port">
            <summary>
            获取或设置服务器的端口号，如果是设置，需要在服务器启动前设置完成，才能生效。<br />
            Gets or sets the port number of the server. If it is set, it needs to be set before the server starts to take effect.
            </summary>
            <remarks>需要在服务器启动之前设置为有效</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.AsyncAcceptCallback(System.IAsyncResult)">
            <summary>
            异步传入的连接申请请求<br />
            Asynchronous incoming connection request
            </summary>
            <param name="iar">异步对象</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端连接到服务器，并听过额外的检查后，进行回调的方法<br />
            Callback method when the client connects to the server and has heard additional checks
            </summary>
            <param name="socket">socket对象</param>
            <param name="endPoint">远程的终结点</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的操作，并返回操作的结果信息。<br />
            The operation is additionally checked when the client's socket logs in, and the result information of the operation is returned.
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.StartInitialization">
            <summary>
            服务器启动时额外的初始化信息，可以用于启动一些额外的服务的操作。<br />
            The extra initialization information when the server starts can be used to start some additional service operations.
            </summary>
            <remarks>需要在派生类中重写</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerStart(System.Int32)">
            <summary>
            指定端口号来启动服务器的引擎<br />
            Specify the port number to start the server's engine
            </summary>
            <param name="port">指定一个端口号</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerStart">
            <summary>
            使用已经配置好的端口启动服务器的引擎<br />
            Use the configured port to start the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.CloseAction">
            <summary>
            服务器关闭的时候需要做的事情<br />
            Things to do when the server is down
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ServerClose">
            <summary>
            关闭服务器的引擎<br />
            Shut down the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ConnectHslAlientClient(System.String,System.Int32,System.String)">
            <summary>
            创建一个指定的异形客户端连接，使用Hsl协议来发送注册包<br />
            Create a specified profiled client connection and use the Hsl protocol to send registration packets
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
            <param name="dtuId">设备唯一ID号，最长11</param>
            <returns>是否成功连接</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpBase">
            <summary>
            基于Udp的应答式通信类<br />
            Udp - based responsive communication class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.#ctor">
            <summary>
            实例化一个默认的方法<br />
            Instantiate a default method
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.IpAddress">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.IpAddress"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.Port">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.Port"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ReceiveTimeout">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ReceiveTimeOut"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpBase.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度，特殊情况的时候需要调整<br />
            Gets or sets the length of data received at a time. The default length is 2KB
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ReadFromCoreServer(System.Byte[])">
            <summary>
            核心的数据交互读取，发数据发送到串口上去，然后从串口上接收返回的数据<br />
            The core data is read interactively, the data is sent to the serial port, and the returned data is received from the serial port
            </summary>
            <param name="value">完整的报文内容</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.IpAddressPing">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.IpAddressPing"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpDeviceBase">
            <summary>
            Udp报文协议的内容传送
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkUdpServerBase">
            <summary>
            Udp服务器程序的基础类，提供了启动服务器的基本实现，方便后续的扩展操作。<br />
            The basic class of the udp server program provides the basic implementation of starting the server to facilitate subsequent expansion operations.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpServerBase.IsStarted">
            <summary>
            服务器引擎是否启动<br />
            Whether the server engine is started
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkUdpServerBase.Port">
            <summary>
            获取或设置服务器的端口号，如果是设置，需要在服务器启动前设置完成，才能生效。<br />
            Gets or sets the port number of the server. If it is set, it needs to be set before the server starts to take effect.
            </summary>
            <remarks>需要在服务器启动之前设置为有效</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ThreadReceiveCycle">
            <summary>
            后台接收数据的线程
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.SocketAcceptExtraCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当客户端的socket登录的时候额外检查的操作，并返回操作的结果信息。<br />
            The operation is additionally checked when the client's socket logs in, and the result information of the operation is returned.
            </summary>
            <param name="socket">套接字</param>
            <param name="endPoint">终结点</param>
            <returns>验证的结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.StartInitialization">
            <summary>
            服务器启动时额外的初始化信息，可以用于启动一些额外的服务的操作。<br />
            The extra initialization information when the server starts can be used to start some additional service operations.
            </summary>
            <remarks>需要在派生类中重写</remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)">
            <summary>
            指定端口号来启动服务器的引擎<br />
            Specify the port number to start the server's engine
            </summary>
            <param name="port">指定一个端口号</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart">
            <summary>
            使用已经配置好的端口启动服务器的引擎<br />
            Use the configured port to start the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.CloseAction">
            <summary>
            服务器关闭的时候需要做的事情<br />
            Things to do when the server is down
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerClose">
            <summary>
            关闭服务器的引擎<br />
            Shut down the server's engine
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkUdpServerBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkWebApiBase">
            <summary>
            基于webapi的数据访问的基类，提供了基本的http接口的交互功能<br />
            A base class for data access based on webapi that provides basic HTTP interface interaction
            </summary>
            <remarks>
            当前的基类在.net framework上存在问题，在.net framework4.5及.net standard上运行稳定而且正常
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String)">
            <summary>
            使用指定的ip地址来初始化对象<br />
            Initializes the object using the specified IP address
            </summary>
            <param name="ipAddress">Ip地址信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址及端口号来初始化对象<br />
            Initializes the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            使用指定的ip地址，端口号，用户名，密码来初始化对象<br />
            Initialize the object with the specified IP address, port number, username, and password
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.ReadByAddress(System.String)">
            <summary>
            等待重写的额外的指令信息的支持。除了url的形式之外，还支持基于命令的数据交互<br />
            Additional instruction information waiting for rewriting is supported.In addition to the url format, command based data interaction is supported
            </summary>
            <param name="address">地址信息</param>
            <returns>是否读取成功的内容</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.Read(System.String)">
            <summary>
            读取对方信息的的数据信息，通常是针对GET的方法信息设计的。如果使用了url=开头，就表示是使用了原生的地址访问<br />
            Read the other side of the data information, usually designed for the GET method information.If you start with url=, you are using native address access
            </summary>
            <param name="address">无效参数</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.ReadString(System.String)">
            <summary>
            读取对方信息的的字符串数据信息，通常是针对GET的方法信息设计的。如果使用了url=开头，就表示是使用了原生的地址访问<br />
            The string data information that reads the other party information, usually designed for the GET method information.If you start with url=, you are using native address access
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.Write(System.String,System.Byte[])">
            <summary>
            使用POST的方式来向对方进行请求数据信息，需要使用url=开头，来表示是使用了原生的地址访问<br />
            Using POST to request data information from the other party, we need to start with url= to indicate that we are using native address access
            </summary>
            <param name="address">指定的地址信息，有些设备可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.Write(System.String,System.String)">
            <summary>
            使用POST的方式来向对方进行请求数据信息，需要使用url=开头，来表示是使用了原生的地址访问<br />
            Using POST to request data information from the other party, we need to start with url= to indicate that we are using native address access
            </summary>
            <param name="address">指定的地址信息</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.IpAddress">
            <summary>
            获取或设置远程服务器的IP地址<br />
            Gets or sets the IP address of the remote server
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.Port">
            <summary>
            获取或设置远程服务器的端口号信息<br />
            Gets or sets the port number information for the remote server
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.NetworkWebApiBase.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkWebApiBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.NetworkXBase">
            <summary>
            包含了主动异步接收的方法实现和文件类异步读写的实现<br />
            Contains the implementation of the active asynchronous receiving method and the implementation of asynchronous reading and writing of the file class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.#ctor">
            <summary>
            默认的无参构造方法<br />
            The default parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileStreamToSocket(System.Net.Sockets.Socket,System.String,System.Int64,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，如果结果异常，则结束通讯<br />
            [Self-check] Send the file data to the socket. If the result is abnormal, the communication is ended.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="filename">完整的文件路径</param>
            <param name="filelength">文件的长度</param>
            <param name="report">进度报告器</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将文件数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯<br />
            [Self-checking] Send the file data to the socket. The specific sending details will be implemented in the inherited class. If the result is abnormal, the communication will end
            </summary>
            <param name="socket">套接字</param>
            <param name="filename">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.SendFileAndCheckReceive(System.Net.Sockets.Socket,System.IO.Stream,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 将流数据发送至套接字，具体发送细节将在继承类中实现，如果结果异常，则结束通讯<br />
            [Self-checking] Send stream data to the socket. The specific sending details will be implemented in the inherited class. 
            If the result is abnormal, the communication will be terminated
            </summary>
            <param name="socket">套接字</param>
            <param name="stream">文件名称，文件必须存在</param>
            <param name="servername">远程端的文件名称</param>
            <param name="filetag">文件的额外标签</param>
            <param name="fileupload">文件的上传人</param>
            <param name="sendReport">发送进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileHeadFromSocket(System.Net.Sockets.Socket)">
            <summary>
            [自校验] 从套接字中接收文件头信息<br />
            [Self-checking] Receive file header information from socket
            </summary>
            <param name="socket">套接字的网络</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，如果结果异常，则结束通讯<br />
            [Self-checking] Receive a file from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="savename">接收文件后保存的文件名</param>
            <param name="receiveReport">接收进度报告</param>
            <returns>包含文件信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ReceiveFileFromSocket(System.Net.Sockets.Socket,System.IO.Stream,System.Action{System.Int64,System.Int64})">
            <summary>
            [自校验] 从网络中接收一个文件，写入数据流，如果结果异常，则结束通讯，参数顺序文件名，文件大小，文件标识，上传人<br />
            [Self-checking] Receive a file from the network. If the result is abnormal, the communication ends.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="stream">等待写入的数据流</param>
            <param name="receiveReport">接收进度报告</param>
            <returns>文件头结果</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.DeleteFileByName(System.String)">
            <summary>
            删除文件的操作<br />
            Delete file operation
            </summary>
            <param name="filename">完整的真实的文件路径</param>
            <returns>是否删除成功</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.PreprocessFolderName(System.String)">
            <summary>
            预处理文件夹的名称，除去文件夹名称最后一个'\'或'/'，如果有的话<br />
            Preprocess the name of the folder, removing the last '\' or '/' in the folder name
            </summary>
            <param name="folder">文件夹名称</param>
            <returns>返回处理之后的名称</returns>
        </member>
        <member name="M:HslCommunication.Core.Net.NetworkXBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.AlienSession">
            <summary>
            异形客户端的连接对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.#ctor">
            <summary>
            实例化一个默认的参数
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.Socket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.DTU">
            <summary>
            唯一的标识
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.Pwd">
            <summary>
            密码信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.IsStatusOk">
            <summary>
            指示当前的网络状态
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.OnlineTime">
            <summary>
            上线时间
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AlienSession.OfflineTime">
            <summary>
            最后一次下线的时间
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.Offline">
            <summary>
            进行下线操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AlienSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Net.AppSession">
            <summary>
            当前的网络会话信息，还包含了一些客户端相关的基本的参数信息<br />
            The current network session information also contains some basic parameter information related to the client
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.#ctor">
            <summary>
            实例化一个构造方法
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.WorkSocket">
            <summary>
            传输数据的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.IpAddress">
            <summary>
            IP地址
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.IpEndPoint">
            <summary>
            此连接对象连接的远程客户端
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.LoginAlias">
            <summary>
            远程对象的别名
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.HeartTime">
            <summary>
            心跳验证的时间点
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.ClientType">
            <summary>
            客户端的类型
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.ClientUniqueID">
            <summary>
            客户端唯一的标识
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Net.AppSession.UdpEndPoint">
            <summary>
            UDP通信中的远程端
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.BytesHead">
            <summary>
            指令头缓存
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.AlreadyReceivedHead">
            <summary>
            已经接收的指令头长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.BytesContent">
            <summary>
            数据内容缓存
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.AlreadyReceivedContent">
            <summary>
            已经接收的数据内容长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AppSession.KeyGroup">
            <summary>
            用于关键字分类使用
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.Clear">
            <summary>
            清除本次的接收内容
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.AppSession.ToString">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.WorkSocket">
            <summary>
            传输数据的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.Content">
            <summary>
            发送的数据内容
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.AlreadySendLength">
            <summary>
            已经发送长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.Key">
            <summary>
            关键字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.AsyncStateSend.ClientId">
            <summary>
            客户端的标识
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.FileStateObject">
            <summary>
            文件传送的异步对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.FileStateObject.Stream">
            <summary>
            操作的流
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.StateObject">
            <summary>
            网络中的异步对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.#ctor(System.Int32)">
            <summary>
            实例化一个对象，指定接收或是发送的数据长度
            </summary>
            <param name="length">数据长度</param>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.UniqueId">
            <summary>
            唯一的一串信息
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateObject.IsClose">
            <summary>
            是否关闭了通道
            </summary>
        </member>
        <member name="M:HslCommunication.Core.Net.StateObject.Clear">
            <summary>
            清空旧的数据
            </summary>
        </member>
        <member name="T:HslCommunication.Core.Net.StateOneBase">
            <summary>
            异步消息的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.DataLength">
            <summary>
            本次接收或是发送的数据长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.AlreadyDealLength">
            <summary>
            已经处理的字节长度
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.WaitDone">
            <summary>
            操作完成的信号
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.Buffer">
            <summary>
            缓存器
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.IsError">
            <summary>
            是否发生了错误
            </summary>
        </member>
        <member name="P:HslCommunication.Core.Net.StateOneBase.ErrerMsg">
            <summary>
            错误消息
            </summary>
        </member>
        <member name="T:HslCommunication.Core.NetSupport">
            <summary>
            静态的方法支持类，提供一些网络的静态支持，支持从套接字从同步接收指定长度的字节数据，并支持报告进度。<br />
            The static method support class provides some static support for the network, supports receiving byte data of a specified length from the socket from synchronization, and supports reporting progress.
            </summary>
            <remarks>
            在接收指定数量的字节数据的时候，如果一直接收不到，就会发生假死的状态。接收的数据时保存在内存里的，不适合大数据块的接收。
            </remarks>
        </member>
        <member name="F:HslCommunication.Core.NetSupport.SocketBufferSize">
            <summary>
            Socket传输中的缓冲池大小<br />
            Buffer pool size in socket transmission
            </summary>
        </member>
        <member name="M:HslCommunication.Core.NetSupport.ReadBytesFromSocket(System.Net.Sockets.Socket,System.Int32,System.Action{System.Int64,System.Int64})">
            <summary>
            从socket的网络中读取数据内容，需要指定数据长度和超时的时间，为了防止数据太大导致接收失败，所以此处接收到新的数据之后就更新时间。<br />
            To read the data content from the socket network, you need to specify the data length and timeout period. In order to prevent the data from being too large and cause the reception to fail, the time is updated after new data is received here.
            </summary>
            <param name="socket">网络套接字</param>
            <param name="receive">接收的长度</param>
            <param name="reportProgress">当前接收数据的进度报告，有些协议支持传输非常大的数据内容，可以给与进度提示的功能</param>
            <returns>最终接收的指定长度的byte[]数据</returns>
        </member>
        <member name="T:HslCommunication.Core.CoordinationStatus">
            <summary>
            线程的协调逻辑状态
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.AllDone">
            <summary>
            所有项完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.Timeout">
            <summary>
            超时
            </summary>
        </member>
        <member name="F:HslCommunication.Core.CoordinationStatus.Cancel">
            <summary>
            任务取消
            </summary>
        </member>
        <member name="T:HslCommunication.Core.AsyncCoordinator">
            <summary>
            一个线程协调逻辑类，详细参考书籍《CLR Via C#》page:681
            这个类可惜没有报告进度的功能
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.AboutToBegin(System.Int32)">
            <summary>
            每次的操作任务开始前必须调用该方法
            </summary>
            <param name="opsToAdd"></param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.JustEnded">
            <summary>
            在一次任务处理好操作之后，必须调用该方法
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.AllBegun(System.Action{HslCommunication.Core.CoordinationStatus},System.Int32)">
            <summary>
            该方法必须在发起所有的操作之后调用
            </summary>
            <param name="callback">回调方法</param>
            <param name="timeout">超时时间</param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.TimeExpired(System.Object)">
            <summary>
            超时的方法
            </summary>
            <param name="o"></param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.Cancel">
            <summary>
            取消任务的执行
            </summary>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.ReportStatus(HslCommunication.Core.CoordinationStatus)">
            <summary>
            生成一次报告
            </summary>
            <param name="status">报告的状态</param>
        </member>
        <member name="M:HslCommunication.Core.AsyncCoordinator.Maxinum(System.Int32@,System.Func{System.Int32,System.Int32})">
            <summary>
            乐观的并发方法模型，具体参照《CLR Via C#》page:686
            </summary>
            <param name="target">唯一的目标数据</param>
            <param name="change">修改数据的算法</param>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Core.HslAsyncCoordinator">
            <summary>
            一个用于高性能，乐观并发模型控制操作的类，允许一个方法(隔离方法)的安全单次执行
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.#ctor(System.Action)">
            <summary>
            实例化一个对象，需要传入隔离执行的方法
            </summary>
            <param name="operater">隔离执行的方法</param>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.StartOperaterInfomation">
            <summary>
            启动线程池执行隔离方法
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslAsyncCoordinator.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.HslReadWriteLock">
            <summary>
            一个高性能的读写锁，支持写锁定，读灵活，读时写锁定，写时读锁定
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.ToString">
            <summary>
            返回本对象的描述字符串
            </summary>
            <returns>对象的描述字符串</returns>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.#ctor">
            <summary>
            实例化一个读写锁的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Enter(System.Boolean)">
            <summary>
            根据读写情况请求锁
            </summary>
            <param name="exclusive">True为写请求，False为读请求</param>
        </member>
        <member name="M:HslCommunication.Core.HslReadWriteLock.Leave">
            <summary>
            释放锁，将根据锁状态自动区分读写锁
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SimpleHybirdLock">
            <summary>
            一个简单的混合线程同步锁，采用了基元用户加基元内核同步构造实现<br />
            A simple hybrid thread editing lock, implemented by the base user plus the element kernel synchronization.
            </summary>
            <remarks>
            当前的锁适用于，竞争频率比较低，锁部分的代码运行时间比较久的情况，当前的简单混合锁可以达到最大性能。
            </remarks>
            <example>
            以下演示常用的锁的使用方式，还包含了如何优雅的处理异常锁
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\ThreadLock.cs" region="SimpleHybirdLockExample1" title="SimpleHybirdLock示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="F:HslCommunication.Core.SimpleHybirdLock.m_waiters">
            <summary>
            基元用户模式构造同步锁
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SimpleHybirdLock.m_waiterLock">
            <summary>
            基元内核模式构造同步锁
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Enter">
            <summary>
            获取锁
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SimpleHybirdLock.Leave">
            <summary>
            离开锁
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.IsWaitting">
            <summary>
            获取当前锁是否在等待当中
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.SimpleHybirdLockCount">
            <summary>
            获取当前总的所有进入锁的信息<br />
            Get the current total information of all access locks
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SimpleHybirdLock.SimpleHybirdLockWaitCount">
            <summary>
            当前正在等待的锁的统计信息，此时已经发生了竞争了
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1">
            <summary>
            一个用于多线程并发处理数据的模型类，适用于处理数据量非常庞大的情况
            </summary>
            <typeparam name="T">等待处理的数据类型</typeparam>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.#ctor(`0[],System.Func{`0,System.Boolean},System.Int32)">
            <summary>
            实例化一个数据处理对象
            </summary>
            <param name="dataList">数据处理列表</param>
            <param name="operater">数据操作方法，应该是相对耗时的任务</param>
            <param name="threadCount">需要使用的线程数</param>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_opCount">
            <summary>
            操作总数，判定操作是否完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_opThreadCount">
            <summary>
            判断是否所有的线程是否处理完成
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_threadCount">
            <summary>
            准备启动的处理数据的线程数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_runStatus">
            <summary>
            指示多线程处理是否在运行中，防止冗余调用
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_dataList">
            <summary>
            列表数据
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_operater">
            <summary>
            需要操作的方法
            </summary>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1.MultiInfo">
            <summary>
            一个双参数委托
            </summary>
            <param name="item"></param>
            <param name="ex"></param>
        </member>
        <member name="T:HslCommunication.Core.SoftMultiTask`1.MultiInfoTwo">
            <summary>
            用于报告进度的委托，当finish等于count时，任务完成
            </summary>
            <param name="finish">已完成操作数量</param>
            <param name="count">总数量</param>
            <param name="success">成功数量</param>
            <param name="failed">失败数量</param>
        </member>
        <member name="E:HslCommunication.Core.SoftMultiTask`1.OnExceptionOccur">
            <summary>
            异常发生时事件
            </summary>
        </member>
        <member name="E:HslCommunication.Core.SoftMultiTask`1.OnReportProgress">
            <summary>
            报告处理进度时发生
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_finishCount">
            <summary>
            已处理完成数量，无论是否异常
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_successCount">
            <summary>
            处理完成并实现操作数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_failedCount">
            <summary>
            处理过程中异常数量
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.HybirdLock">
            <summary>
            用于触发事件的混合线程锁
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isRunningStop">
            <summary>
            指示处理状态是否为暂停状态
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isQuit">
            <summary>
            指示系统是否需要强制退出
            </summary>
        </member>
        <member name="F:HslCommunication.Core.SoftMultiTask`1.m_isQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.StartOperater">
            <summary>
            启动多线程进行数据处理
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.StopOperater">
            <summary>
            暂停当前的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.ResumeOperater">
            <summary>
            恢复暂停的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Core.SoftMultiTask`1.EndedOperater">
            <summary>
            直接手动强制结束操作
            </summary>
        </member>
        <member name="P:HslCommunication.Core.SoftMultiTask`1.IsQuitAfterException">
            <summary>
            在发生错误的时候是否强制退出后续的操作
            </summary>
        </member>
        <member name="T:HslCommunication.Core.ByteTransformBase">
            <summary>
            数据转换类的基础，提供了一些基础的方法实现.<br />
            The basis of the data conversion class provides some basic method implementations.
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)">
            <summary>
            使用指定的数据解析来实例化对象<br />
            Instantiate the object using the specified data parsing
            </summary>
            <param name="dataFormat">数据规则</param>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransBool(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransString(System.Byte[],System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Single)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Double)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.TransByte(System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ByteTransDataFormat4(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ByteTransDataFormat8(System.Byte[],System.Int32)">
            <summary>
            反转多字节的数据信息
            </summary>
            <param name="value">数据字节</param>
            <param name="index">起始索引，默认值为0</param>
            <returns>实际字节信息</returns>
        </member>
        <member name="P:HslCommunication.Core.ByteTransformBase.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.IByteTransform.DataFormat"/>
        </member>
        <member name="P:HslCommunication.Core.ByteTransformBase.IsStringReverseByteWord">
            <inheritdoc cref="P:HslCommunication.Core.IByteTransform.IsStringReverseByteWord"/>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ByteTransformHelper">
            <summary>
            所有数据转换类的静态辅助方法<br />
            Static helper method for all data conversion classes
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromBytes``1(HslCommunication.OperateResult{System.Byte[]},System.Func{System.Byte[],``0})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托，并捕获转换时的异常方法
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源</param>
            <param name="translator">实际转换的委托</param>
            <returns>转换结果</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromArray``1(HslCommunication.OperateResult{``0[]})">
            <summary>
            结果转换操作的基础方法，需要支持类型，及转换的委托
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <param name="result">源结果</param>
            <returns>转换结果</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetSuccessResultFromOther``2(HslCommunication.OperateResult{``1},System.Func{``1,``0})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容，所转换的规则
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``1(HslCommunication.OperateResult{``0},System.Func{``0,HslCommunication.OperateResult})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``2(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn">输入类型</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans">转换方法，从类型TIn转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``3(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``4(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``5(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``6(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``7(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``8(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``9(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``10(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``9}},System.Func{``9,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <typeparam name="TIn9">输入类型9</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TIn9的泛型委托</param>
            <param name="trans9">转换方法9，从类型TIn9转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="M:HslCommunication.Core.ByteTransformHelper.GetResultFromOther``11(HslCommunication.OperateResult{``1},System.Func{``1,HslCommunication.OperateResult{``2}},System.Func{``2,HslCommunication.OperateResult{``3}},System.Func{``3,HslCommunication.OperateResult{``4}},System.Func{``4,HslCommunication.OperateResult{``5}},System.Func{``5,HslCommunication.OperateResult{``6}},System.Func{``6,HslCommunication.OperateResult{``7}},System.Func{``7,HslCommunication.OperateResult{``8}},System.Func{``8,HslCommunication.OperateResult{``9}},System.Func{``9,HslCommunication.OperateResult{``10}},System.Func{``10,HslCommunication.OperateResult{``0}})">
            <summary>
            使用指定的转换方法，来获取到实际的结果对象内容
            </summary>
            <typeparam name="TResult">结果类型</typeparam>
            <typeparam name="TIn1">输入类型1</typeparam>
            <typeparam name="TIn2">输入类型2</typeparam>
            <typeparam name="TIn3">输入类型3</typeparam>
            <typeparam name="TIn4">输入类型4</typeparam>
            <typeparam name="TIn5">输入类型5</typeparam>
            <typeparam name="TIn6">输入类型6</typeparam>
            <typeparam name="TIn7">输入类型7</typeparam>
            <typeparam name="TIn8">输入类型8</typeparam>
            <typeparam name="TIn9">输入类型9</typeparam>
            <typeparam name="TIn10">输入类型10</typeparam>
            <param name="result">原始的结果对象</param>
            <param name="trans1">转换方法1，从类型TIn1转换拿到OperateResult的TIn2的泛型委托</param>
            <param name="trans2">转换方法2，从类型TIn2转换拿到OperateResult的TIn3的泛型委托</param>
            <param name="trans3">转换方法3，从类型TIn3转换拿到OperateResult的TIn4的泛型委托</param>
            <param name="trans4">转换方法4，从类型TIn4转换拿到OperateResult的TIn5的泛型委托</param>
            <param name="trans5">转换方法5，从类型TIn5转换拿到OperateResult的TIn6的泛型委托</param>
            <param name="trans6">转换方法6，从类型TIn6转换拿到OperateResult的TIn7的泛型委托</param>
            <param name="trans7">转换方法7，从类型TIn7转换拿到OperateResult的TIn8的泛型委托</param>
            <param name="trans8">转换方法8，从类型TIn8转换拿到OperateResult的TIn9的泛型委托</param>
            <param name="trans9">转换方法9，从类型TIn9转换拿到OperateResult的TIn10的泛型委托</param>
            <param name="trans10">转换方法10，从类型TIn10转换拿到OperateResult的TResult的泛型委托</param>
            <returns>类型为TResult的对象</returns>
        </member>
        <member name="T:HslCommunication.Core.DataFormat">
            <summary>
            应用于多字节数据的解析或是生成格式<br />
            Parsing or generating format for multibyte data
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.ABCD">
            <summary>
            按照顺序排序
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.BADC">
            <summary>
            按照单字反转
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.CDAB">
            <summary>
            按照双字反转
            </summary>
        </member>
        <member name="F:HslCommunication.Core.DataFormat.DCBA">
            <summary>
            按照倒序排序
            </summary>
        </member>
        <member name="T:HslCommunication.Core.IByteTransform">
            <summary>
            支持转换器的基础接口，规定了实际的数据类型和字节数组进行相互转换的方法。
            </summary>
            <remarks>
            所有的设备通讯类都内置了该转换的模型，并且已经配置好数据的高地位模式，可以方便的转换信息
            </remarks>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取出bool结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <returns>bool对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransBool(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取出bool数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">位的索引</param>
            <param name="length">bool长度</param>
            <returns>bool数组</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取byte结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>byte对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取byte数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>byte数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取short结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>short对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取short数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>short数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ushort结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ushort对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ushort数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ushort数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取int结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>int对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取int数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>int数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取uint结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>uint对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取uint数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>uint数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取long结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>long对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取long数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>long数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取ulong结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <returns>ulong对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取ulong数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns>ulong数组对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取float结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>float对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取float数组结果
            </summary>
            <param name="buffer">缓存数据</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)">
            <summary>
            从缓存中提取double结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <returns>double对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从缓存中提取double数组结果
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">读取的数组长度</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransString(System.Byte[],System.Int32,System.Int32,System.Text.Encoding)">
            <summary>
            从缓存中提取string结果，使用指定的编码
            </summary>
            <param name="buffer">缓存对象</param>
            <param name="index">索引位置</param>
            <param name="length">byte数组长度</param>
            <param name="encoding">字符串的编码</param>
            <returns>string对象</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean)">
            <summary>
            bool变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Boolean[])">
            <summary>
            bool数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Byte)">
            <summary>
            byte变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16)">
            <summary>
            short变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])">
            <summary>
            short数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16)">
            <summary>
            ushort变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])">
            <summary>
            ushort数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32)">
            <summary>
            int变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32[])">
            <summary>
            int数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32)">
            <summary>
            uint变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32[])">
            <summary>
            uint数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64)">
            <summary>
            long变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64[])">
            <summary>
            long数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64)">
            <summary>
            ulong变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64[])">
            <summary>
            ulong数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Single)">
            <summary>
            float变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Single[])">
            <summary>
            float数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Double)">
            <summary>
            double变量转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.Double[])">
            <summary>
            double数组变量转化缓存数据
            </summary>
            <param name="values">等待转化的数组</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.IByteTransform.TransByte(System.String,System.Int32,System.Text.Encoding)">
            <summary>
            使用指定的编码字符串转化缓存数据
            </summary>
            <param name="value">等待转化的数据</param>
            <param name="length">转换之后的数据长度</param>
            <param name="encoding">字符串的编码方式</param>
            <returns>buffer数据</returns>
        </member>
        <member name="P:HslCommunication.Core.IByteTransform.DataFormat">
            <summary>
            获取或设置数据解析的格式，可选ABCD, BADC，CDAB，DCBA格式
            </summary>
        </member>
        <member name="P:HslCommunication.Core.IByteTransform.IsStringReverseByteWord">
            <summary>
            获取或设置在解析字符串的时候是否将字节按照字单位反转
            </summary>
        </member>
        <member name="T:HslCommunication.Core.RegularByteTransform">
            <summary>
            常规的字节转换类<br />
            Regular byte conversion class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.RegularByteTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ReverseBytesTransform">
            <summary>
            字节倒序的转换类<br />
            Byte reverse order conversion class
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransUInt32(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt32(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransUInt64(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt64(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransSingle(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransSingle(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransDouble(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransDouble(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.TransByte(System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Double[])"/>
            <returns>buffer数据</returns>
        </member>
        <member name="M:HslCommunication.Core.ReverseBytesTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.ReverseWordTransform">
            <summary>
            按照字节错位的数据转换类<br />
            Data conversion class according to byte misalignment
            </summary>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.#ctor">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.#ctor(HslCommunication.Core.DataFormat)">
            <inheritdoc cref="M:HslCommunication.Core.ByteTransformBase.#ctor(HslCommunication.Core.DataFormat)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.ReverseBytesByWord(System.Byte[],System.Int32,System.Int32)">
            <summary>
            按照字节错位的方法
            </summary>
            <param name="buffer">实际的字节数据</param>
            <param name="index">起始字节位置</param>
            <param name="length">数据长度</param>
            <returns>处理过的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransUInt16(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransUInt16(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransByte(System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.TransByte(System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IByteTransform.TransByte(System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Core.ReverseWordTransform.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Core.Types.CertificateDegree">
            <summary>
            证书等级
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Types.CertificateDegree.Read">
            <summary>
            只允许读取数据的等级
            </summary>
        </member>
        <member name="F:HslCommunication.Core.Types.CertificateDegree.ReadWrite">
            <summary>
            允许同时读写数据的等级
            </summary>
        </member>
        <member name="T:HslCommunication.Core.HslPieItem">
            <summary>
            饼图的基本元素
            </summary>
        </member>
        <member name="M:HslCommunication.Core.HslPieItem.#ctor">
            <summary>
            实例化一个饼图基本元素的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:HslCommunication.Core.HslPieItem.Back">
            <summary>
            背景颜色
            </summary>
        </member>
        <member name="T:HslCommunication.Core.RemoteCloseException">
            <summary>
            远程对象关闭的异常信息<br />
            Exception information of remote object close
            </summary>
        </member>
        <member name="M:HslCommunication.Core.RemoteCloseException.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="T:HslCommunication.NetHandle">
            <summary>
            用于网络传递的信息头，使用上等同于int
            </summary>
            <remarks>
            通常用于<see cref="T:HslCommunication.Enthernet.NetComplexServer"/>和<see cref="T:HslCommunication.Enthernet.NetComplexClient"/>之间的通信，以及<see cref="T:HslCommunication.Enthernet.NetSimplifyServer"/>和<see cref="T:HslCommunication.Enthernet.NetSimplifyClient"/>通讯
            </remarks>
            <example>
            使用上等同于int，只是本结构体允许将4字节的int拆分成3部分单独访问
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetHandle.cs" region="NetHandleExample" title="NetHandle示例" />
            </example>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Implicit(System.Int32)~HslCommunication.NetHandle">
            <summary>
            赋值操作，可以直接赋值int数据
            </summary>
            <param name="value">int数值</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Implicit(HslCommunication.NetHandle)~System.Int32">
            <summary>
            也可以赋值给int数据
            </summary>
            <param name="netHandle">netHandle对象</param>
            <returns>等值的消息对象</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Equality(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否相等
            </summary>
            <param name="netHandle1">第一个数</param>
            <param name="netHandle2">第二个数</param>
            <returns>等于返回<c>True</c>，否则<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Inequality(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否不相等
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>等于返回<c>False</c>，否则<c>True</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Addition(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            两个数值相加
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的和</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_Subtraction(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            两个数值相减
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>返回两个指令的差</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_LessThan(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否小于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>小于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.op_GreaterThan(HslCommunication.NetHandle,HslCommunication.NetHandle)">
            <summary>
            判断是否大于另一个数值
            </summary>
            <param name="netHandle1">第一个对象</param>
            <param name="netHandle2">第二个对象</param>
            <returns>大于则返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.#ctor(System.Int32)">
            <summary>
            初始化一个暗号对象
            </summary>
            <param name="value">使用一个默认的数值进行初始化</param>
        </member>
        <member name="M:HslCommunication.NetHandle.#ctor(System.Byte,System.Byte,System.UInt16)">
            <summary>
            根据三个值来初始化暗号对象
            </summary>
            <param name="major">主暗号</param>
            <param name="minor">次暗号</param>
            <param name="identifier">暗号编号</param>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="F:HslCommunication.NetHandle.m_CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeValue">
            <summary>
            完整的暗号值
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeMajor">
            <summary>
            主暗号分类0-255
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeMinor">
            <summary>
            次要的暗号分类0-255
            </summary>
        </member>
        <member name="P:HslCommunication.NetHandle.CodeIdentifier">
            <summary>
            暗号的编号分类0-65535
            </summary>
        </member>
        <member name="M:HslCommunication.NetHandle.ToString">
            <summary>
            获取完整的暗号数据
            </summary>
            <returns>返回暗号的字符串表示形式</returns>
        </member>
        <member name="M:HslCommunication.NetHandle.Equals(System.Object)">
            <summary>
            判断两个实例是否相同
            </summary>
            <param name="obj">对比的对象</param>
            <returns>相同返回<c>True</c>，否则返回<c>False</c></returns>
        </member>
        <member name="M:HslCommunication.NetHandle.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns>返回当前对象的哈希值</returns>
        </member>
        <member name="T:HslCommunication.HslProtocol">
            <summary>
            用于本程序集访问通信的暗号说明
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.HeadByteLength">
            <summary>
            规定所有的网络传输指令头都为32字节
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolBufferSize">
            <summary>
            所有网络通信中的缓冲池数据信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolCheckSecends">
            <summary>
            用于心跳程序的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientQuit">
            <summary>
            客户端退出消息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientRefuseLogin">
            <summary>
            因为客户端达到上限而拒绝登录
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolClientAllowLogin">
            <summary>
            允许客户端登录到服务器
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolAccountLogin">
            <summary>
            客户端登录的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolAccountRejectLogin">
            <summary>
            客户端拒绝登录的暗号信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserString">
            <summary>
            说明发送的只是文本信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserBytes">
            <summary>
            发送的数据就是普通的字节数组
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserBitmap">
            <summary>
            发送的数据就是普通的图片数据
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserException">
            <summary>
            发送的数据是一条异常的数据，字符串为异常消息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolUserStringArray">
            <summary>
            说明发送的数据是字符串的数组
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDownload">
            <summary>
            请求文件下载的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileUpload">
            <summary>
            请求文件上传的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDelete">
            <summary>
            请求删除文件的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileCheckRight">
            <summary>
            文件校验成功
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileCheckError">
            <summary>
            文件校验失败
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileSaveError">
            <summary>
            文件保存失败
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDirectoryFiles">
            <summary>
            请求文件列表的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFileDirectories">
            <summary>
            请求子文件的列表暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolProgressReport">
            <summary>
            进度返回暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolErrorMsg">
            <summary>
            返回的错误信息
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFilesDelete">
            <summary>
            请求删除多个文件的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolFolderDelete">
            <summary>
            请求删除文件夹的暗号
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolNoZipped">
            <summary>
            不压缩数据字节
            </summary>
        </member>
        <member name="F:HslCommunication.HslProtocol.ProtocolZipped">
            <summary>
            压缩数据字节
            </summary>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Int32,System.Guid,System.Byte[])">
            <summary>
            生成终极传送指令的方法，所有的数据均通过该方法出来
            </summary>
            <param name="command">命令头</param>
            <param name="customer">自用自定义</param>
            <param name="token">令牌</param>
            <param name="data">字节数据</param>
            <returns>包装后的数据信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandAnalysis(System.Byte[],System.Byte[])">
            <summary>
            解析接收到数据，先解压缩后进行解密
            </summary>
            <param name="head">指令头</param>
            <param name="content">指令的内容</param>
            <return>真实的数据内容</return>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.Byte[])">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字节信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.String)">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字符串数据信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.CommandBytes(System.Int32,System.Guid,System.String[])">
            <summary>
            获取发送字节数据的实际数据，带指令头
            </summary>
            <param name="customer">用户数据</param>
            <param name="token">令牌</param>
            <param name="data">字符串数据信息</param>
            <returns>包装后的指令信息</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.PackStringArrayToByte(System.String[])">
            <summary>
            将字符串打包成字节数组内容
            </summary>
            <param name="data">字符串数组</param>
            <returns>打包后的原始数据内容</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.UnPackStringArrayFromByte(System.Byte[])">
            <summary>
            将字节数组还原成真实的字符串数组
            </summary>
            <param name="content">原始字节数组</param>
            <returns>解析后的字符串内容</returns>
        </member>
        <member name="M:HslCommunication.HslProtocol.ExtractHslData(System.Byte[])">
            <summary>
            从接收的数据内容提取出用户的暗号和数据内容
            </summary>
            <param name="content">数据内容</param>
            <returns>包含结果对象的信息</returns>
        </member>
        <member name="T:HslCommunication.Reflection.HslDeviceAddressAttribute">
            <summary>
            应用于Hsl组件库读取的动态地址解析
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.DeviceType">
            <summary>
            设备的类型，这将决定是否使用当前的PLC地址
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.Address">
            <summary>
            数据的地址信息
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslDeviceAddressAttribute.Length">
            <summary>
            数据长度
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String)">
            <summary>
            实例化一个地址特性，指定地址信息
            </summary>
            <param name="address">真实的地址信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Type)">
            <summary>
            实例化一个地址特性，指定地址信息
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="deviceType">设备的地址信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个地址特性，指定地址信息和数据长度，通常应用于数组的批量读取
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="length">读取的数据长度</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslDeviceAddressAttribute.#ctor(System.String,System.Int32,System.Type)">
            <summary>
            实例化一个地址特性，指定地址信息和数据长度，通常应用于数组的批量读取
            </summary>
            <param name="address">真实的地址信息</param>
            <param name="length">读取的数据长度</param>
            <param name="deviceType">设备类型</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisKeyAttribute">
            <summary>
            对应redis的一个键值信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisKeyAttribute.KeyName">
            <summary>
            键值的名称
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisKeyAttribute.#ctor(System.String)">
            <summary>
            根据键名来读取写入当前的数据信息
            </summary>
            <param name="key">键名</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisListItemAttribute">
            <summary>
            对应redis的一个列表信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListItemAttribute.ListKey">
            <summary>
            列表键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListItemAttribute.Index">
            <summary>
            当前的位置的索引
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListItemAttribute.#ctor(System.String,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的单个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="index">当前的索引位置</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisListAttribute">
            <summary>
            对应redis的一个列表信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.ListKey">
            <summary>
            列表键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.StartIndex">
            <summary>
            当前的位置的索引
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisListAttribute.EndIndex">
            <summary>
            当前位置的结束索引
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="startIndex">开始的索引信息</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisListAttribute.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            根据键名来读取写入当前的列表中的多个信息
            </summary>
            <param name="listKey">列表键名</param>
            <param name="startIndex">开始的索引信息</param>
            <param name="endIndex">结束的索引位置，-1为倒数第一个，以此类推。</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslRedisHashFieldAttribute">
            <summary>
            对应redis的一个哈希信息的内容
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisHashFieldAttribute.HaskKey">
            <summary>
            哈希键值的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Reflection.HslRedisHashFieldAttribute.Field">
            <summary>
            当前的哈希域名称
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslRedisHashFieldAttribute.#ctor(System.String,System.String)">
            <summary>
            根据键名来读取写入当前的哈希的单个信息
            </summary>
            <param name="hashKey">哈希键名</param>
            <param name="filed">哈希域名称</param>
        </member>
        <member name="T:HslCommunication.Reflection.HslReflectionHelper">
            <summary>
            反射的辅助类
            </summary>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Read``1(HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="readWrite">读写接口的实现</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Write``1(``0,HslCommunication.Core.IReadWriteNet)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，该特性为<see cref="T:HslCommunication.Reflection.HslDeviceAddressAttribute"/>，详细参考论坛的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">自定义的数据对象</param>
            <param name="readWrite">数据读写对象</param>
            <returns>包含是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.SetPropertyExp``2(System.Reflection.PropertyInfo,``0,``1)">
            <summary>
            使用表达式树的方式来给一个属性赋值
            </summary>
            <param name="propertyInfo">属性信息</param>
            <param name="obj">对象信息</param>
            <param name="objValue">实际的值</param>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Read``1(HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里读取支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>，
            <see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Reflection.HslReflectionHelper.Write``1(``0,HslCommunication.Enthernet.Redis.RedisClient)">
            <summary>
            从设备里写入支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/> ，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            需要注意的是写入并不支持<see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>特性，详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">等待写入的数据参数</param>
            <param name="redis">Redis的数据对象</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.HslSecurity.ByteEncrypt(System.Byte[])">
            <summary>
            加密方法，只对当前的程序集开放
            </summary>
            <param name="enBytes">等待加密的数据</param>
            <returns>加密后的字节数据</returns>
        </member>
        <member name="M:HslCommunication.HslSecurity.ByteDecrypt(System.Byte[])">
            <summary>
            解密方法，只对当前的程序集开放
            </summary>
            <param name="deBytes">等待解密的数据</param>
            <returns>解密后的字节数据</returns>
        </member>
        <member name="T:HslCommunication.HslExtension">
            <summary>
            扩展的辅助类方法
            </summary>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[],System.Char)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexString(System.Byte[],System.Char,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToHexString(System.Byte[],System.Char,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToHexBytes(System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.HexStringToBytes(System.String)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.GetBoolOnIndex(System.Byte,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.BoolOnByteIndex(System.Byte,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToByteArray(System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.BoolArrayToByte(System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToBoolArray(System.Byte[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToBoolArray(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ByteToBoolArray(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveDouble``1(``0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveDouble``1(``0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveBegin``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveBegin``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.RemoveLast``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayRemoveLast``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectMiddle``1(``0[],System.Int32,System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectMiddle``1(``0[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectBegin``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectBegin``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.SelectLast``1(``0[],System.Int32)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArraySelectLast``1(``0[],System.Int32)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.IncreaseBy``1(``0[],``0)">
            <summary>
            将指定的数据添加到数组的每个元素上去，使用表达式树的形式实现，将会修改原数组。不适用byte类型
            </summary>
            <typeparam name="T">数组的类型</typeparam>
            <param name="array">原始数据</param>
            <param name="value">数据值</param>
            <returns>返回的结果信息</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.CopyArray``1(``0[])">
            <summary>
            拷贝当前的实例数组，是基于引用层的浅拷贝，如果类型为值类型，那就是深度拷贝，如果类型为引用类型，就是浅拷贝
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">数组对象</param>
            <returns>拷贝的结果内容</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToArrayString``1(``0[])">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0[])"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToArrayString``1(``0[],System.String)">
            <inheritdoc cref="M:HslCommunication.BasicFramework.SoftBasic.ArrayFormat``1(``0,System.String)"/>
        </member>
        <member name="M:HslCommunication.HslExtension.ToStringArray``1(System.String,System.Func{System.String,``0})">
            <summary>
            将字符串数组转换为实际的数据数组。例如字符串格式[1,2,3,4,5]，可以转成实际的数组对象<br />
            Converts a string array into an actual data array. For example, the string format [1,2,3,4,5] can be converted into an actual array object
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">字符串数据</param>
            <param name="selector">转换方法</param>
            <returns>实际的数组</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToStringArray``1(System.String)">
            <summary>
            将字符串数组转换为实际的数据数组。支持byte,sbyte,bool,short,ushort,int,uint,long,ulong,float,double，使用默认的十进制，例如字符串格式[1,2,3,4,5]，可以转成实际的数组对象<br />
            Converts a string array into an actual data array. Support byte, sbyte, bool, short, ushort, int, uint, long, ulong, float, double, use the default decimal, 
            such as the string format [1,2,3,4,5], which can be converted into an actual array Object
            </summary>
            <typeparam name="T">类型对象</typeparam>
            <param name="value">字符串数据</param>
            <returns>实际的数组</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.BeginReceiveResult(System.Net.Sockets.Socket,System.AsyncCallback,System.Object)">
            <summary>
            启动接收数据，需要传入回调方法，传递对象<br />
            To start receiving data, you need to pass in a callback method and pass an object
            </summary>
            <param name="socket">socket对象</param>
            <param name="callback">回调方法</param>
            <param name="obj">数据对象</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.BeginReceiveResult(System.Net.Sockets.Socket,System.AsyncCallback)">
            <summary>
            启动接收数据，需要传入回调方法，传递对象默认为socket本身<br />
            To start receiving data, you need to pass in a callback method. The default object is the socket itself.
            </summary>
            <param name="socket">socket对象</param>
            <param name="callback">回调方法</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.EndReceiveResult(System.Net.Sockets.Socket,System.IAsyncResult)">
            <summary>
            结束挂起的异步读取，返回读取的字节数，如果成功的情况。<br />
            Ends the pending asynchronous read and returns the number of bytes read, if successful.
            </summary>
            <param name="socket">socket对象</param>
            <param name="ar">回调方法</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.HslExtension.ToJsonString(System.Object,Newtonsoft.Json.Formatting)">
            <summary>
            获取当前对象的JSON格式表示的字符串。<br />
            Gets the string represented by the JSON format of the current object.
            </summary>
            <returns>字符串对象</returns>
        </member>
        <member name="T:HslCommunication.HslTimeOut">
            <summary>
            超时操作的类<br />
            a class use to indicate the time-out of the connection
            </summary>
        </member>
        <member name="M:HslCommunication.HslTimeOut.#ctor">
            <summary>
            实例化对象
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.StartTime">
            <summary>
            操作的开始时间
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.IsSuccessful">
            <summary>
            操作是否成功
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.DelayTime">
            <summary>
            延时的时间，单位毫秒
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.WorkSocket">
            <summary>
            连接超时用的Socket
            </summary>
        </member>
        <member name="P:HslCommunication.HslTimeOut.IsTimeout">
            <summary>
            是否发生了超时的操作
            </summary>
        </member>
        <member name="M:HslCommunication.HslTimeOut.GetConsumeTime">
            <summary>
            获取到目前为止所花费的时间
            </summary>
            <returns>时间信息</returns>
        </member>
        <member name="M:HslCommunication.HslTimeOut.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.IDataTransfer">
            <summary>
            用于PLC通讯及ModBus自定义数据类型的读写操作
            </summary>
            <remarks>
            主要应用于设备实现设备类的自定义的数据类型读写，以此达到简化代码的操作，但是有一个前提，该数据处于连续的数据区块
            </remarks>
            <example>
            此处举例读取三菱的自定义的数据，先实现接口，然后再读写操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="IDataTransfer Example" title="DataMy示例" />
            接下来就可以实现数据的读取了
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="ReadCustomerExample" title="ReadCustomer示例" />
            </example>
        </member>
        <member name="P:HslCommunication.IDataTransfer.ReadCount">
            <summary>
            读取的数据长度，对于西门子，等同于字节数，对于三菱和Modbus为字节数的一半
            </summary>
        </member>
        <member name="M:HslCommunication.IDataTransfer.ParseSource(System.Byte[])">
            <summary>
            从字节数组进行解析实际的对象
            </summary>
            <param name="Content">从远程读取的数据源</param>
        </member>
        <member name="M:HslCommunication.IDataTransfer.ToSource">
            <summary>
            将对象生成字符源，写入PLC中
            </summary>
            <returns>准备写入到远程的数据</returns>
        </member>
        <member name="T:HslCommunication.OperateResult">
            <summary>
            操作结果的类，只带有成功标志和错误信息<br />
            The class that operates the result, with only success flags and error messages
            </summary>
            <remarks>
            当 <see cref="P:HslCommunication.OperateResult.IsSuccess"/> 为 True 时，忽略 <see cref="P:HslCommunication.OperateResult.Message"/> 及 <see cref="P:HslCommunication.OperateResult.ErrorCode"/> 的值
            </remarks>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult.IsSuccess">
            <summary>
            指示本次访问是否成功
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult.Message">
            <summary>
            具体的错误描述
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult.ErrorCode">
            <summary>
            具体的错误代码
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult.ToMessageShowString">
            <summary>
            获取错误代号及文本描述
            </summary>
            <returns>包含错误码及错误消息</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CopyErrorFromOther``1(``0)">
            <summary>
            从另一个结果类中拷贝错误信息
            </summary>
            <typeparam name="TResult">支持结果类及派生类</typeparam>
            <param name="result">结果类及派生类的对象</param>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``1(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T">目标数据类型</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``2(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``3(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``4(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``5(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``6(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``7(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``8(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``9(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateFailedResult``10(HslCommunication.OperateResult)">
            <summary>
            创建并返回一个失败的结果对象，该对象复制另一个结果对象的错误信息
            </summary>
            <typeparam name="T1">目标数据类型一</typeparam>
            <typeparam name="T2">目标数据类型二</typeparam>
            <typeparam name="T3">目标数据类型三</typeparam>
            <typeparam name="T4">目标数据类型四</typeparam>
            <typeparam name="T5">目标数据类型五</typeparam>
            <typeparam name="T6">目标数据类型六</typeparam>
            <typeparam name="T7">目标数据类型七</typeparam>
            <typeparam name="T8">目标数据类型八</typeparam>
            <typeparam name="T9">目标数据类型九</typeparam>
            <typeparam name="T10">目标数据类型十</typeparam>
            <param name="result">之前的结果对象</param>
            <returns>带默认泛型对象的失败结果类</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult">
            <summary>
            创建并返回一个成功的结果对象
            </summary>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``1(``0)">
            <summary>
            创建并返回一个成功的结果对象，并带有一个参数对象
            </summary>
            <typeparam name="T">参数类型</typeparam>
            <param name="value">类型的值对象</param>
            <returns>成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``2(``0,``1)">
            <summary>
            创建并返回一个成功的结果对象，并带有两个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``3(``0,``1,``2)">
            <summary>
            创建并返回一个成功的结果对象，并带有三个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``4(``0,``1,``2,``3)">
            <summary>
            创建并返回一个成功的结果对象，并带有四个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``5(``0,``1,``2,``3,``4)">
            <summary>
            创建并返回一个成功的结果对象，并带有五个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            创建并返回一个成功的结果对象，并带有六个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            创建并返回一个成功的结果对象，并带有七个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>
            创建并返回一个成功的结果对象，并带有八个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``9(``0,``1,``2,``3,``4,``5,``6,``7,``8)">
            <summary>
            创建并返回一个成功的结果对象，并带有九个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="M:HslCommunication.OperateResult.CreateSuccessResult``10(``0,``1,``2,``3,``4,``5,``6,``7,``8,``9)">
            <summary>
            创建并返回一个成功的结果对象，并带有十个参数对象
            </summary>
            <typeparam name="T1">第一个参数类型</typeparam>
            <typeparam name="T2">第二个参数类型</typeparam>
            <typeparam name="T3">第三个参数类型</typeparam>
            <typeparam name="T4">第四个参数类型</typeparam>
            <typeparam name="T5">第五个参数类型</typeparam>
            <typeparam name="T6">第六个参数类型</typeparam>
            <typeparam name="T7">第七个参数类型</typeparam>
            <typeparam name="T8">第八个参数类型</typeparam>
            <typeparam name="T9">第九个参数类型</typeparam>
            <typeparam name="T10">第十个参数类型</typeparam>
            <param name="value1">类型一对象</param>
            <param name="value2">类型二对象</param>
            <param name="value3">类型三对象</param>
            <param name="value4">类型四对象</param>
            <param name="value5">类型五对象</param>
            <param name="value6">类型六对象</param>
            <param name="value7">类型七对象</param>
            <param name="value8">类型八对象</param>
            <param name="value9">类型九对象</param>
            <param name="value10">类型十对象</param>
            <returns>成的结果对象</returns>
        </member>
        <member name="T:HslCommunication.OperateResult`1">
            <summary>
            操作结果的泛型类，允许带一个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`1.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`1.Content">
            <summary>
            用户自定义的泛型数据
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`2">
            <summary>
            操作结果的泛型类，允许带两个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`2.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`2.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`2.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`3">
            <summary>
            操作结果的泛型类，允许带三个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`3.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`3.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`4">
            <summary>
            操作结果的泛型类，允许带四个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`4.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`4.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`5">
            <summary>
            操作结果的泛型类，允许带五个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`5.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`5.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`6">
            <summary>
            操作结果的泛型类，允许带六个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`6.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`6.Content6">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`7">
            <summary>
            操作结果的泛型类，允许带七个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`7.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`7.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`8">
            <summary>
            操作结果的泛型类，允许带八个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`8.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`8.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`9">
            <summary>
            操作结果的泛型类，允许带九个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`9.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`9.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="T:HslCommunication.OperateResult`10">
            <summary>
            操作结果的泛型类，允许带十个用户自定义的泛型对象，推荐使用这个类
            </summary>
            <typeparam name="T1">泛型类</typeparam>
            <typeparam name="T2">泛型类</typeparam>
            <typeparam name="T3">泛型类</typeparam>
            <typeparam name="T4">泛型类</typeparam>
            <typeparam name="T5">泛型类</typeparam>
            <typeparam name="T6">泛型类</typeparam>
            <typeparam name="T7">泛型类</typeparam>
            <typeparam name="T8">泛型类</typeparam>
            <typeparam name="T9">泛型类</typeparam>
            <typeparam name="T10">泛型类</typeparam>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor">
            <summary>
            实例化一个默认的结果对象
            </summary>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor(System.String)">
            <summary>
            使用指定的消息实例化一个默认的结果对象
            </summary>
            <param name="msg">错误消息</param>
        </member>
        <member name="M:HslCommunication.OperateResult`10.#ctor(System.Int32,System.String)">
            <summary>
            使用错误代码，消息文本来实例化对象
            </summary>
            <param name="err">错误代码</param>
            <param name="msg">错误消息</param>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content1">
            <summary>
            用户自定义的泛型数据1
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content2">
            <summary>
            用户自定义的泛型数据2
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content3">
            <summary>
            用户自定义的泛型数据3
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content4">
            <summary>
            用户自定义的泛型数据4
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content5">
            <summary>
            用户自定义的泛型数据5
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content6">
            <summary>
            用户自定义的泛型数据6
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content7">
            <summary>
            用户自定义的泛型数据7
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content8">
            <summary>
            用户自定义的泛型数据8
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content9">
            <summary>
            用户自定义的泛型数据9
            </summary>
        </member>
        <member name="P:HslCommunication.OperateResult`10.Content10">
            <summary>
            用户自定义的泛型数据10
            </summary>
        </member>
        <member name="T:HslCommunication.DTU.DTUServer">
            <summary>
            DTU的服务器信息，本服务器支持任意的hsl支持的网络对象，包括plc信息，modbus设备等等，通过DTU来连接，
            然后支持多个连接对象。如果需要支持非hsl的注册报文，需要重写相关的方法<br />
            DTU server information, the server supports any network objects supported by hsl, 
            including plc information, modbus devices, etc., connected through DTU, and then supports multiple connection objects. 
            If you need to support non-HSL registration messages, you need to rewrite the relevant methods
            </summary>
            <remarks>
            针对异形客户端进行扩展信息
            </remarks>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.#ctor(System.Collections.Generic.List{HslCommunication.DTU.DTUSettingType})">
            <summary>
            根据配置的列表信息来实例化相关的DTU服务器<br />
            Instantiate the relevant DTU server according to the configured list information
            </summary>
            <param name="dTUSettings">DTU的配置信息</param>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.#ctor(System.String[],HslCommunication.Core.Net.NetworkDeviceBase[])">
            <summary>
            根据配置的列表信息来实例化相关的DTU服务器<br />
            Instantiate the relevant DTU server according to the configured list information
            </summary>
            <param name="dtuId">Dtu信息</param>
            <param name="networkDevices">设备信息</param>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.IsClientOnline(HslCommunication.Core.Net.AlienSession)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.DTU.DTUServer.Item(System.String)">
            <summary>
            根据DTU信息获取设备的连接对象<br />
            Obtain the connection object of the device according to the DTU information
            </summary>
            <param name="dtuId">设备的id信息</param>
            <returns>设备的对象</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.GetAlienSessions">
            <summary>
            获取所有的会话信息，是否在线，上线的基本信息<br />
            Get all the session information, whether it is online, online basic information
            </summary>
            <returns>会话列表</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.GetDevices">
            <summary>
            获取所有的设备的信息，可以用来读写设备的数据信息<br />
            Get all device information, can be used to read and write device data information
            </summary>
            <returns>设备数组</returns>
        </member>
        <member name="M:HslCommunication.DTU.DTUServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.DTU.DTUSettingType">
            <summary>
            DTU的类型设置器
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.DtuId">
            <summary>
            设备的唯一ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.DtuType">
            <summary>
            当前的设备的类型
            </summary>
        </member>
        <member name="P:HslCommunication.DTU.DTUSettingType.JsonParameter">
            <summary>
            额外的参数都存放在json里面
            </summary>
        </member>
        <member name="M:HslCommunication.DTU.DTUSettingType.GetClient">
            <summary>
            根据类型，获取连接对象
            </summary>
            <returns>获取设备的连接对象</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.NetComplexClient">
            <summary>
            一个基于异步高性能的客户端网络类，支持主动接收服务器的消息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormComplexNet.cs" region="NetComplexClient" title="NetComplexClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.IsClientStart">
            <summary>
            客户端系统是否启动
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ConnectFailedCount">
            <summary>
            重连接失败的次数
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ClientAlias">
            <summary>
            客户端登录的标识名称，可以为ID号，也可以为登录名
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.EndPointServer">
            <summary>
            远程服务器的IP地址和端口
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.ServerTime">
            <summary>
            服务器的时间，自动实现和服务器同步
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexClient.DelayTime">
            <summary>
            系统与服务器的延时时间，单位毫秒
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.LoginSuccess">
            <summary>
            客户端启动成功的事件，重连成功也将触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.LoginFailed">
            <summary>
            连接失败时触发的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.MessageAlerts">
            <summary>
            服务器的异常，启动，等等一般消息产生的时候，出发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.BeforReConnected">
            <summary>
            在客户端断开后并在重连服务器之前触发，用于清理系统资源
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexClient.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ClientClose">
            <summary>
            关闭该客户端引擎
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ClientStart">
            <summary>
            启动客户端引擎，连接服务器系统
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.AwaitToConnect">
            <summary>
            连接服务器之前的消息提示，如果是重连的话，就提示10秒等待信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.Send(HslCommunication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.Send(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ThreadHeartCheck">
            <summary>
            心跳线程的方法
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetComplexServer">
            <summary>
            高性能的异步网络服务器类，适合搭建局域网聊天程序，消息推送程序
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8097897.html">http://www.cnblogs.com/dathlin/p/8097897.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\ComplexNetServer\FormServer.cs" region="NetComplexServer" title="NetComplexServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.#ctor">
            <summary>
            实例化一个网络服务器类对象
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.ConnectMax">
            <summary>
            所支持的同时在线客户端的最大数量，默认为10000个
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.IsSaveLogClientLineChange">
            <summary>
            获取或设置服务器是否记录客户端上下线信息，默认为true
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetComplexServer.ClientCount">
            <summary>
            所有在线客户端的数量
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.StartInitialization">
            <summary>
            初始化操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.CloseAction">
            <summary>
            关闭网络时的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.AppSessionRemoteClose(HslCommunication.Core.Net.AppSession)">
            <summary>
            让客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">会话对象</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AllClientsStatusChange">
            <summary>
            客户端的上下限状态变更时触发，仅作为在线客户端识别
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetComplexServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.Send(HslCommunication.Core.Net.AppSession,HslCommunication.NetHandle,System.String)">
            <summary>
            服务器端用于数据发送文本的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="str">发送的文本</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.Send(HslCommunication.Core.Net.AppSession,HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务器端用于发送字节的方法
            </summary>
            <param name="session">数据发送对象</param>
            <param name="customer">用户自定义的数据对象，如不需要，赋值为0</param>
            <param name="bytes">实际发送的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendAllClients(HslCommunication.NetHandle,System.String)">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendAllClients(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            服务端用于发送所有数据到所有的客户端
            </summary>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要群发客户端的字节数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendClientByAlias(System.String,HslCommunication.NetHandle,System.String)">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="str">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.SendClientByAlias(System.String,HslCommunication.NetHandle,System.Byte[])">
            <summary>
            根据客户端设置的别名进行发送消息
            </summary>
            <param name="Alias">客户端上线的别名</param>
            <param name="customer">用户自定义的命令头</param>
            <param name="data">需要传送的实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetComplexServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.DeviceNet">
            <summary>
            通用设备的基础网络信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.DeviceNet.#ctor">
            <summary>
            实例化一个通用的设备类
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.ClientOnline">
            <summary>
            当客户端上线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.ClientOffline">
            <summary>
            当客户端下线的时候，触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.AcceptString">
            <summary>
            按照ASCII文本的方式进行触发接收的数据
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.DeviceNet.AcceptBytes">
            <summary>
            按照字节的方式进行触发接收的数据
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.DeviceNet.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="T:HslCommunication.Enthernet.DeviceState">
            <summary>
            通用设备的基础状态
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.DeviceEndPoint">
            <summary>
            设备的连接地址
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.ConnectTime">
            <summary>
            设备的连接时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.WorkSocket">
            <summary>
            网络套接字
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.ReceiveTime">
            <summary>
            上次接收到信息的时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.DeviceState.IpAddress">
            <summary>
            设备的ip地址
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.DeviceState.Buffer">
            <summary>
            缓冲内存块
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.AdvancedFileServer">
            <summary>
            文件管理类服务器，负责服务器所有分类文件的管理，特点是不支持文件附加数据，但是支持直接访问文件名
            </summary>
            <remarks>
            本文件的服务器不支持存储文件携带的额外信息，是直接将文件存放在服务器指定目录下的，文件名不更改，特点是服务器查看方便。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Advanced Server" title="AdvancedFileServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.CheckFolderAndCreate">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ReceiveFileFromSocketAndMoveFile(System.Net.Sockets.Socket,System.String,System.String)">
            <summary>
            从网络套接字接收文件并移动到目标的文件夹中，如果结果异常，则结束通讯
            </summary>
            <param name="socket"></param>
            <param name="savename"></param>
            <param name="fileNameNew"></param>
            <returns></returns>
        </member>
        <member name="P:HslCommunication.Enthernet.AdvancedFileServer.FilesDirectoryPathTemp">
            <summary>
            用于接收上传文件时的临时文件夹，临时文件使用结束后会被删除<br />
            Used to receive the temporary folder when uploading files. The temporary files will be deleted after use
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.AdvancedFileServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.FileBaseInfo">
            <summary>
            文件的基础信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileBaseInfo.Name">
            <summary>
            文件名称
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileBaseInfo.Size">
            <summary>
            文件大小
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileBaseInfo.Tag">
            <summary>
            文件的标识，注释
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileBaseInfo.Upload">
            <summary>
            文件上传人的名称
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.FileGroupInfo">
            <summary>
            文件的分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.Command">
            <summary>
            命令码
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.FileName">
            <summary>
            文件名
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.FileNames">
            <summary>
            文件名列表
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.Factory">
            <summary>
            第一级分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.Group">
            <summary>
            第二级分类信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileGroupInfo.Identify">
            <summary>
            第三级分类信息
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.FileServerInfo">
            <summary>
            文件在服务器上的信息
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileServerInfo.ActualFileFullName">
            <summary>
            文件的真是路径
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.FileClientBase">
            <summary>
            文件传输客户端基类，提供上传，下载，删除的基础服务<br />
            File transfer client base class, providing basic services for uploading, downloading, and deleting
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileClientBase.ServerIpEndPoint">
            <summary>
            文件管理服务器的ip地址及端口<br />
            IP address and port of the file management server
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileClientBase.ConnectTimeOut">
            <summary>
            获取或设置连接的超时时间，默认10秒<br />
            Gets or sets the connection timeout time. The default is 10 seconds.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.SendFactoryGroupId(System.Net.Sockets.Socket,System.String,System.String,System.String)">
            <summary>
            发送三个文件分类信息到服务器端，方便后续开展其他的操作。<br />
            Send the three file classification information to the server to facilitate subsequent operations.
            </summary>
            <param name="socket">套接字对象</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器上的文件，需要传入文件信息，以及文件绑定的分类信息。<br />
            To delete a file on the server, you need to pass in the file information and the classification information of the file binding.
            </summary>
            <param name="fileName">文件的名称</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFileBase(System.String[],System.String,System.String,System.String)">
            <summary>
            删除服务器上的文件列表，需要传入文件信息，以及文件绑定的分类信息。<br />
            To delete a file on the server, you need to pass in the file information and the classification information of the file binding.
            </summary>
            <param name="fileNames">所有等待删除的文件的名称</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DeleteFolder(System.String,System.String,System.String)">
            <summary>
            删除服务器上的指定目录的所有文件，需要传入分类信息。<br />
            To delete all files in the specified directory on the server, you need to input classification information
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.DownloadFileBase(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.Object)">
            <summary>
            下载服务器的文件数据，并且存储到对应的内容里去。<br />
            Download the file data of the server and store it in the corresponding content.
            </summary>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileName">服务器的文件名称</param>
            <param name="processReport">下载的进度报告，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <param name="source">数据源信息，决定最终存储到哪里去</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.UploadFileBase(System.Object,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传文件给服务器，需要指定上传的数据内容，上传到服务器的分类信息，支持进度汇报功能。<br />
            To upload files to the server, you need to specify the content of the uploaded data, 
            the classification information uploaded to the server, and support the progress report function.
            </summary>
            <param name="source">数据源，可以是文件名，也可以是数据流</param>
            <param name="serverName">在服务器保存的文件名，不包含驱动器路径</param>
            <param name="factory">一级分类</param>
            <param name="group">二级分类</param>
            <param name="id">三级分类</param>
            <param name="fileTag">文件的描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">汇报进度，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileClientBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.FileMarkId">
            <summary>
            文件标记对象类，标记了一个文件的当前状态，是否处于下载中，删除的操作信息<br />
            File tag object class, which marks the current status of a file, whether it is downloading, or delete operation information
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.#ctor(HslCommunication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个文件标记对象，需要传入日志信息和文件名<br />
            To instantiate a file tag object, you need to pass in log information and file name
            </summary>
            <param name="logNet">日志对象</param>
            <param name="fileName">完整的文件名称</param>
        </member>
        <member name="P:HslCommunication.Enthernet.FileMarkId.CreateTime">
            <summary>
            当前的对象创建的时间<br />
            Current object creation time
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileMarkId.ActiveTime">
            <summary>
            当前的对象最后一次活跃的时间<br />
            Last active time of the current object
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.FileMarkId.DownloadTimes">
            <summary>
            当前的文件的读取次数，通常也是下载次数。<br />
            The current number of reads of the file, usually also the number of downloads.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.AddOperation(System.Action)">
            <summary>
            新增一个对当前的文件的操作，如果没有读取，就直接执行，如果有读取，就等待读取完成的时候执行。<br />
            Add an operation on the current file. If there is no read, it will be executed directly. If there is a read, it will be executed when the read is completed.
            </summary>
            <param name="action">对当前文件的操作内容</param>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.CanClear">
            <summary>
            获取该对象是否能被清除<br />
            Gets whether the object can be cleared
            </summary>
            <returns>是否能够删除</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.EnterReadOperator">
            <summary>
            进入文件的读取状态<br />
            Enter the read state of the file
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.LeaveReadOperator">
            <summary>
            离开本次的文件读取状态，如果没有任何的客户端在读取了，就执行缓存队列里的操作信息。<br />
            Leaving the current file reading status, if no client is reading, the operation information in the cache queue is executed.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.FileMarkId.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.GroupFileContainer">
            <summary>
            文件集容器，绑定一个文件夹的文件信息组，提供了文件夹的文件信息的获取，更新接口<br />
            File set container, which binds the file information group of a folder, provides the file information acquisition and update interface of the folder
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.#ctor(HslCommunication.LogNet.ILogNet,System.String)">
            <summary>
            实例化一个新的指定目录的文件管理容器<br />
            Instantiates a new file management container for the specified directory
            </summary>
            <param name="logNet">日志记录对象，可以为空</param>
            <param name="path">文件的路径</param>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileContainer.JsonArrayContent">
            <summary>
            包含所有文件列表信息的json文本缓存<br />
            JSON text cache containing all file list information
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileContainer.FileCount">
            <summary>
            获取文件的数量<br />
            Get the number of files
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileContainer.DirectoryPath">
            <summary>
            当前的目录信息
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.GroupFileContainer.FileCountChangedDelegate">
            <summary>
            文件数量变化的委托信息
            </summary>
            <param name="container">文件列表容器</param>
            <param name="fileCount">文件的数量</param>
        </member>
        <member name="E:HslCommunication.Enthernet.GroupFileContainer.FileCountChanged">
            <summary>
            当文件数量发生变化的时候触发的事件<br />
            Event triggered when the number of files changes
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.GetCurrentFileMappingName(System.String)">
            <summary>
            下载文件时调用，根据当前的文件名称，例如 123.txt 获取到在文件服务器里映射的文件名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909<br />
            Called when downloading a file. Get the file name mapped in the file server according to the current file name, such as 123.txt. 
            For example, return b35a11ec533147ca80c7f7d1713f015b7909.
            </summary>
            <param name="fileName">文件的实际名称</param>
            <returns>文件名映射过去的实际的文件名字</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.UpdateFileMappingName(System.String,System.Int64,System.String,System.String,System.String)">
            <summary>
            上传文件时掉用，通过比对现有的文件列表，如果没有，就重新创建列表信息<br />
            Used when uploading files, by comparing existing file lists, if not, re-creating list information
            </summary>
            <param name="fileName">文件名，带后缀，不带任何的路径</param>
            <param name="fileSize">文件的大小</param>
            <param name="mappingName">文件映射名称</param>
            <param name="owner">文件的拥有者</param>
            <param name="description">文件的额外描述</param>
            <returns>映射的文件名称</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.DeleteFile(System.String)">
            <summary>
            删除一个文件信息，传入文件实际的名称，例如 123.txt 返回被删除的文件的guid名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909   此方法存在同名文件删除的风险<br />
            Delete a file information. Pass in the actual name of the file. For example, 123.txt returns the guid name of the deleted file. For example, it returns b35a11ec533147ca80c7f7d1713f015b7909. There is a risk of deleting the file with the same name
            </summary>
            <param name="fileName">实际的文件名称，如果 123.txt</param>
            <returns>映射之后的文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.DeleteFileByGuid(System.String)">
            <summary>
            删除一个文件信息，传入文件唯一的guid的名称，例如 b35a11ec533147ca80c7f7d1713f015b7909 返回被删除的文件的guid名称<br />
            Delete a file information, pass in the unique GUID name of the file, for example b35a11ec533147ca80c7f7d1713f015b7909 return the GUID name of the deleted file
            </summary>
            <param name="guidName">实际的文件名称，如果 b35a11ec533147ca80c7f7d1713f015b7909</param>
            <returns>映射之后的文件名，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.ClearAllFiles">
            <summary>
            删除当前目录下所有的文件信息，返回等待被删除的文件列表，是映射文件名：b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <returns>映射之后的文件列表，例如 b35a11ec533147ca80c7f7d1713f015b7909</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.CacheJsonArrayContent">
            <summary>
            缓存JSON文本的方法，该机制使用乐观并发模型完成<br />
            Method for caching JSON text, which is done using an optimistic concurrency model
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.LoadByPath(System.String)">
            <summary>
            从目录进行加载数据，必须实例化的时候加载，加载失败会导致系统异常，旧的文件丢失<br />
            Load data from the directory, it must be loaded when instantiating. Failure to load will cause system exceptions and old files will be lost
            </summary>
            <param name="path">当前的文件夹路径信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileContainer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.GroupFileItem">
            <summary>
            单个文件的存储信息，用来表示在文件目录管理器里表示所有的文件信息的<br />
            Storage information of a single file, used to represent all file information in the file directory manager
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.FileName">
            <summary>
            文件的名称
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.FileSize">
            <summary>
            文件的大小
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.MappingName">
            <summary>
            文件的映射名称
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.DownloadTimes">
            <summary>
            文件的下载次数
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.UploadTime">
            <summary>
            文件的上传时间
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.Owner">
            <summary>
            文件的上传人，拥有者
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.GroupFileItem.Description">
            <summary>
            文件的额外描述
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileItem.GetTextFromFileSize">
            <summary>
            获取文件的大小描述<br />
            Get file size description
            </summary>
            <returns>文件大小的字符串描述形式</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.GroupFileItem.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.IntegrationFileClient">
            <summary>
            与服务器文件引擎交互的客户端类，支持操作Advanced引擎和Ultimate引擎，用来上传，下载，删除服务器中的文件操作。<br />
            The client class that interacts with the server file engine, supports the operation of the Advanced engine and the Ultimate engine,
            and is used to upload, download, and delete file operations on the server.
            </summary>
            <remarks>
            这里需要需要的是，本客户端支持Advanced引擎和Ultimate引擎文件服务器，服务的类型需要您根据自己的需求来选择。
            </remarks>
            <example>
            此处只演示创建实例，具体的上传，下载，删除的例子请参照对应的方法
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Intergration File Client" title="IntegrationFileClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.#ctor">
            <summary>
            实例化一个默认的对象，需要提前指定服务器的远程地址<br />
            Instantiate a default object, you need to specify the remote address of the server in advance
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的Ip地址及端口号实例化一个对象<br />
            Instantiate an object with the specified IP address and port number
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Enthernet.IntegrationFileClient.FileCacheSize">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkBase.fileCacheSize"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String,System.String,System.String,System.String)">
            <summary>
            删除服务器的文件操作，需要指定文件名称，文件的三级分类信息<br />
            Delete the file operation of the server, you need to specify the file name and the three-level classification information of the file
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String)">
            <summary>
            删除服务器的文件操作，此处文件的分类为空<br />
            Delete the file operation of the server, the classification of the file is empty here
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFile(System.String[],System.String,System.String,System.String)">
            <summary>
            删除服务器的文件数组操作，需要指定文件名称，文件的三级分类信息<br />
            Delete the file operation of the server, you need to specify the file name and the three-level classification information of the file
            </summary>
            <param name="fileNames">文件名称数组，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DeleteFolderFiles(System.String,System.String,System.String)">
            <summary>
            删除服务器的文件夹的所有文件操作，文件的三级分类信息<br />
            Delete all file operations of the server folder, the three-level classification information of the file
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)">
            <summary>
            下载服务器的文件到本地的文件操作，需要指定下载的文件的名字，三级分类信息，本次保存的文件名，支持进度报告。<br />
            To download a file from the server to a local file, you need to specify the name of the downloaded file, 
            the three-level classification information, the name of the file saved this time, and support for progress reports.
            </summary>
            <param name="fileName">文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">下载的进度报告，第一个数据是已完成总接字节数，第二个数据是总字节数。</param>
            <param name="fileSaveName">准备本地保存的名称</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是服务器不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Download File" title="DownloadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.IO.Stream)">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <inheritdoc cref="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64},System.String)"/>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，如果该文件已经存在，那么就更新这个文件。<br />
            Upload a local file to the server. If the file already exists, update the file.
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传本地的文件到服务器操作，服务器存储的文件名就是当前文件默认的名称，其余参数默认为空
            </summary>
            <param name="fileName">本地的完整路径的文件名称</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.IO.Stream,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传数据流到服务器操作
            </summary>
            <param name="stream">数据流内容</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.UploadFile(System.Drawing.Bitmap,System.String,System.String,System.String,System.String,System.String,System.String,System.Action{System.Int64,System.Int64})">
            <summary>
            上传内存图片到服务器操作
            </summary>
            <param name="bitmap">内存图片，不能为空</param>
            <param name="serverName">服务器存储的文件名称，带后缀</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileTag">文件的额外描述</param>
            <param name="fileUpload">文件的上传人</param>
            <param name="processReport">上传的进度报告</param>
            <returns>是否成功的结果对象</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常，或是客户端不存在文件。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="Upload File" title="UploadFile示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFileNames(System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的目录<br />
            Get all directories under the specified path
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="DownloadPathFileNames" title="DownloadPathFileNames示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadPathFolders(System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档<br />
            Get all documents in the specified path
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <returns>是否成功的结果对象</returns>
            <remarks>
            用于分类的参数<paramref name="factory"/>，<paramref name="group"/>，<paramref name="id"/>中间不需要的可以为空，对应的是服务器上的路径系统。
            <br /><br />
            <note type="warning">
            失败的原因大多数来自于网络的接收异常。
            </note>
            </remarks>
            <example>
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormFileClient.cs" region="DownloadPathFolders" title="DownloadPathFolders示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.DownloadStringArrays``1(System.Int32,System.String,System.String,System.String)">
            <summary>
            获取指定路径下的所有的文档
            </summary>
            <param name="protocol">指令</param>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <typeparam name="T">数组的类型</typeparam>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.IntegrationFileClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.UltimateFileServer">
            <summary>
            终极文件管理服务器，实现所有的文件分类管理，读写分离，不支持直接访问文件名
            </summary>
            <remarks>
            本文件的服务器支持存储文件携带的额外信息，文件名被映射成了新的名称，无法在服务器直接查看文件信息。
            </remarks>
            <example>
            以下的示例来自Demo项目，创建了一个简单的服务器对象。
            <code lang="cs" source="TestProject\FileNetServer\FormFileServer.cs" region="Ultimate Server" title="UltimateFileServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.UltimateFileServer.m_dictionary_group_marks">
            <summary>
            所有文件组操作的词典锁
            </summary>
        </member>
        <member name="F:HslCommunication.Enthernet.UltimateFileServer.hybirdLock">
            <summary>
            词典的锁
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.GetGroupFromFilePath(System.String)">
            <summary>
            获取当前目录的读写锁，如果没有会自动创建
            </summary>
            <param name="filePath">相对路径名</param>
            <returns>读写锁</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ReceiveFileFromSocketAndUpdateGroup(System.Net.Sockets.Socket,System.String)">
            <summary>
            从套接字接收文件并保存，更新文件列表
            </summary>
            <param name="socket">套接字</param>
            <param name="savename">保存的文件名</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.TransformFactFileName(System.String,System.String,System.String,System.String)">
            <summary>
            根据文件的显示名称转化为真实存储的名称，例如 123.txt 获取到在文件服务器里映射的文件名称，例如返回 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="factory">第一大类</param>
            <param name="group">第二大类</param>
            <param name="id">第三大类</param>
            <param name="fileName">文件显示名称</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.DeleteExsistingFile(System.String,System.String)">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileName">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.DeleteExsistingFile(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            删除已经存在的文件信息，文件的名称需要是guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909
            </summary>
            <param name="path">文件的路径</param>
            <param name="fileNames">文件的guid名称，例如 b35a11ec533147ca80c7f7d1713f015b7909</param>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.UltimateFileServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.HttpGet">
            <summary>
            代表带网络请求的类中是采用GET的方式来请求的
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.HttpPost">
            <summary>
            代表带网络请求的类中是采用POST的方式来请求的
            </summary>
        </member>
        <member name="T:HslCommunication.Enthernet.HttpServer">
            <summary>
            一个支持完全自定义的Http服务器，支持返回任意的数据信息，方便调试信息，详细的案例请查看API文档信息<br />
            A Http server that supports fully customized, supports returning arbitrary data information, which is convenient for debugging information. For detailed cases, please refer to the API documentation information
            </summary>
            <example>
            我们先来看看一个最简单的例子，如何进行实例化的操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample1" title="基本的实例化" />
            通常来说，基本的实例化，返回固定的数据并不能满足我们的需求，我们需要返回自定义的数据，有一个委托，我们需要自己指定方法.
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample2" title="自定义返回" />
            我们实际的需求可能会更加的复杂，不同的网址会返回不同的数据，所以接下来我们需要对网址信息进行判断。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample3" title="区分网址" />
            如果我们想增加安全性的验证功能，比如我们的api接口需要增加用户名和密码的功能，那么我们也可以实现
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample4" title="安全实现" />
            当然了，如果我们想反回一个完整的html网页，也是可以实现的，甚至添加一些js的脚本，下面的例子就简单的说明了如何操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\HttpServerSample.cs" region="Sample5" title="返回html" />
            如果需要实现跨域的操作，可以将属性<see cref="P:HslCommunication.Enthernet.HttpServer.IsCrossDomain"/> 设置为<c>True</c>
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.#ctor">
            <summary>
            实例化一个默认的对象，当前的运行，需要使用管理员的模式运行<br />
            Instantiate a default object, the current operation, you need to use the administrator mode to run
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.Start(System.Int32)">
            <summary>
            启动服务器，正常调用该方法时，应该使用try...catch...来捕获错误信息<br />
            Start the server and use try...catch... to capture the error message when calling this method normally
            </summary>
            <param name="port">端口号信息</param>
            <exception cref="T:System.Net.HttpListenerException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.Close">
            <summary>
            关闭服务器<br />
            Shut down the server
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)">
            <summary>
            根据客户端的请求进行处理的核心方法，可以返回自定义的数据内容，只需要集成重写即可。<br />
            The core method of processing according to the client's request can return custom data content, and only needs to be integrated and rewritten.
            </summary>
            <param name="request">请求</param>
            <param name="response">回应</param>
            <param name="data">Body数据</param>
            <returns>返回的内容</returns>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.ServerEncoding">
            <summary>
            获取或设置当前服务器的编码信息，默认为UTF8编码<br />
            Get or set the encoding information of the current server, the default is UTF8 encoding
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.IsCrossDomain">
            <summary>
            获取或设置是否支持跨域操作<br />
            Get or set whether to support cross-domain operations
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.HandleRequestFunc">
            <summary>
            获取或设置当前的自定义的处理信息，如果不想继承实现方法，可以使用本属性来关联你自定义的方法。<br />
            Get or set the current custom processing information. If you don't want to inherit the implementation method, you can use this attribute to associate your custom method.
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.HttpServer.Port">
            <summary>
            获取当前的端口号信息<br />
            Get current port number information
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.HttpServer.HandleObjectMethod(System.Net.HttpListenerRequest,System.String,System.Object)">
            <summary>
            使用指定的对象来返回网络的API接口，前提是传入的数据为json参数，返回的数据为json数据，详细参照说明<br />
            Use the specified object to return the API interface of the network, 
            provided that the incoming data is json parameters and the returned data is json data, 
            please refer to the description for details
            </summary>
            <param name="request">当前的请求信息</param>
            <param name="json">json格式的参数信息</param>
            <param name="obj">等待解析的api解析的对象</param>
            <returns>等待返回客户的结果</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPlainSocket">
            <summary>
            一个基于明文的socket中心
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来实例化这个对象
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ConnectServer">
            <summary>
            连接服务器
            </summary>
            <returns>返回是否连接成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ConnectClose">
            <summary>
            关闭当前的连接对象
            </summary>
            <returns>错误信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.SendString(System.String)">
            <summary>
            发送字符串到网络上去
            </summary>
            <param name="text">文本信息</param>
            <returns>发送是否成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ReConnectServer(System.Object)">
            <summary>
            是否是处于重连的状态
            </summary>
            <param name="obj">无用的对象</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetPlainSocket.ReceivedString">
            <summary>
            当接收到字符串时候的触发事件
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPlainSocket.Encoding">
            <summary>
            当前的编码器
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPlainSocket.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPushClient">
            <summary>
            发布订阅类的客户端，使用指定的关键订阅相关的数据推送信息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8992315.html">http://www.cnblogs.com/dathlin/p/8992315.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormPushNet.cs" region="FormPushNet" title="NetPushClient示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.CreatePush(System.Action{HslCommunication.Enthernet.NetPushClient,System.String})">
            <summary>
            创建数据推送服务
            </summary>
            <param name="pushCallBack">触发数据推送的委托</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.CreatePush">
            <summary>
            创建数据推送服务，使用事件绑定的机制实现
            </summary>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.ClosePush">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushClient.KeyWord">
            <summary>
            本客户端的关键字
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushClient.ReConnectTime">
            <summary>
            获取或设置重连服务器的间隔时间，单位：毫秒
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetPushClient.OnReceived">
            <summary>
            当接收到数据的事件信息，接收到数据的时候触发。
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetPushServer">
            <summary>
            发布订阅服务器的类，支持按照关键字进行数据信息的订阅
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/8992315.html">http://www.cnblogs.com/dathlin/p/8992315.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\PushNetServer\FormServer.cs" region="NetPushServer" title="NetPushServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.#ctor">
            <summary>
            实例化一个对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ServerClose">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.PushString(System.String,System.String)">
            <summary>
            主动推送数据内容
            </summary>
            <param name="key">关键字</param>
            <param name="content">数据内容</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.RemoveKey(System.String)">
            <summary>
            移除关键字信息，通常应用于一些特殊临时用途的关键字
            </summary>
            <param name="key">关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.CreatePushRemote(System.String,System.Int32,System.String)">
            <summary>
            创建一个远程服务器的数据推送操作，以便推送给子客户端
            </summary>
            <param name="ipAddress">远程的IP地址</param>
            <param name="port">远程的端口号</param>
            <param name="key">订阅的关键字</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushServer.OnlineCount">
            <summary>
            在线客户端的数量
            </summary>
        </member>
        <member name="P:HslCommunication.Enthernet.NetPushServer.PushCacheAfterConnect">
            <summary>
            在客户端上线之后，是否推送缓存的数据，默认设置为true
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.RemoveGroupOnline(System.String,System.String)">
            <summary>
            移除客户端的数据信息
            </summary>
            <param name="key">指定的客户端</param>
            <param name="clientID">指定的客户端唯一的id信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetPushServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.PushGroupClient">
            <summary>
            订阅分类的核心组织对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.AddPushClient(HslCommunication.Core.Net.AppSession)">
            <summary>
            新增一个订阅的会话
            </summary>
            <param name="session">会话</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.RemovePushClient(System.String)">
            <summary>
            移除一个订阅的会话
            </summary>
            <param name="clientID">客户端唯一的ID信息</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.PushString(System.String,System.Action{HslCommunication.Core.Net.AppSession,System.String})">
            <summary>
            使用固定的发送方法将数据发送出去
            </summary>
            <param name="content">数据内容</param>
            <param name="send">指定的推送方法</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.RemoveAllClient">
            <summary>
            移除并关闭所有的客户端
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.HasPushedContent">
            <summary>
            获取是否推送过数据
            </summary>
            <returns>True代表有，False代表没有</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.Dispose(System.Boolean)">
            <summary>
            释放当前的程序所占用的资源
            </summary>
            <param name="disposing">是否释放资源</param>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.Dispose">
            <summary>
            释放当前的对象所占用的资源
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.PushGroupClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisClient">
            <summary>
            这是一个redis的客户端类，支持读取，写入，发布订阅，但是不支持订阅，如果需要订阅，请使用另一个类<see cref="T:HslCommunication.Enthernet.Redis.RedisSubscribe"/>
            </summary>
            <remarks>
            本类库的API指令的参考及注释来源：http://doc.redisfans.com/index.html
            </remarks>
            <example>
            基本的操作如下所示，举例了几个比较常见的指令，更多的需要参考api接口描述
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleBasic" title="基本操作代码" />
            如下是基于特性的操作，有必要说明以下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample1" title="基础的使用" />
            总的来说，当读取的数据种类比较多的时候，读取的关键字比较多的时候，处理起来就比较的麻烦，此处推荐一个全新的写法，为了更好的对比，我们假设实现一种需求
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample2" title="同等代码" />
            为此我们只需要实现一个特性类即可。代码如下：(注意，实际是很灵活的，类型都是自动转换的)
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleClass" title="数据类" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.#ctor(System.String)">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
            <param name="password">密码，如果服务器没有设置，密码设置为null</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadCustomer(System.String)">
            <summary>
            自定义的指令交互方法，该指令用空格分割，举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值，需要对返回的数据进行二次分析
            </summary>
            <param name="command">举例：LTRIM AAAAA 0 999 就是收缩列表，GET AAA 就是获取键值</param>
            <returns>从服务器返回的结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateNumberFromServer(System.String[])">
            <summary>
            向服务器请求指定，并返回数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>数字的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateLongNumberFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回long数字的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>long数字的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStringsFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回字符串数组的结果对象
            </summary>
            <param name="commands">命令数组</param>
            <returns>字符串数组的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.OperateStatusFromServer(System.String[])">
            <summary>
            向服务器请求指令，并返回状态的结果对象，通常用于写入的判断，或是请求类型的判断
            </summary>
            <param name="commands">命令数组</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String[])">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="keys">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteKey(System.String)">
            <summary>
            删除给定的一个或多个 key 。不存在的 key 会被忽略。
            </summary>
            <param name="key">关键字</param>
            <returns>被删除 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsKey(System.String)">
            <summary>
            检查给定 key 是否存在。若 key 存在，返回 1 ，否则返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>若 key 存在，返回 1 ，否则返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExpireKey(System.String,System.Int32)">
            <summary>
            为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="seconds">当前key的生存时间，单位为秒</param>
            <returns>
            设置成功返回 1 。当 key 不存在或者不能为 key 设置生存时间时，返回 0 。
            </returns>
            <remarks>
            在 Redis 中，带有生存时间的 key 被称为『易失的』(volatile)。<br />
            生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆写( overwrite)，这意味着，如果一个命令只是修改( alter)一个带生存时间的 key 的值而不是用一个新的 key 值来代替( replace)它的话，那么生存时间不会被改变。<br />
            比如说，对一个 key 执行 INCR 命令，对一个列表进行 LPUSH 命令，或者对一个哈希表执行 HSET 命令，这类操作都不会修改 key 本身的生存时间。<br />
            另一方面，如果使用 RENAME 对一个 key 进行改名，那么改名后的 key 的生存时间和改名前一样。<br />
            RENAME 命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key( 以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。<br />
            使用 PERSIST 命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个『持久的』(persistent) key 。<br />
            更新生存时间<br />
            可以对一个已经带有生存时间的 key 执行 EXPIRE 命令，新指定的生存时间会取代旧的生存时间。<br />
            过期时间的精确度<br />
            在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 key 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。<br />
            Redis 2.1.3 之前的不同之处<br />
            在 Redis 2.1.3 之前的版本中，修改一个带有生存时间的 key 会导致整个 key 被删除，这一行为是受当时复制( replication)层的限制而作出的，现在这一限制已经被修复。<br />
            </remarks>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAllKeys(System.String)">
            <summary>
            查找所有符合给定模式 pattern 的 key 。
            * 匹配数据库中所有 key。
            h?llo 匹配 hello ， hallo 和 hxllo 等。
            h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo 。
            </summary>
            <param name="pattern">给定模式</param>
            <returns>符合给定模式的 key 列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.MoveKey(System.String,System.Int32)">
            <summary>
            将当前数据库的 key 移动到给定的数据库 db 当中。
            如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。
            因此，也可以利用这一特性，将 MOVE 当作锁(locking)原语(primitive)。
            </summary>
            <param name="key">关键字</param>
            <param name="db">数据块</param>
            <returns>是否移动成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.PersistKey(System.String)">
            <summary>
            移除给定 key 的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>
            当生存时间移除成功时，返回 1 .
            如果 key 不存在或 key 没有设置生存时间，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadRandomKey">
            <summary>
            从当前数据库中随机返回(不删除)一个 key 。
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </summary>
            <returns>
            当数据库不为空时，返回一个 key 。
            当数据库为空时，返回 nil 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.RenameKey(System.String,System.String)">
            <summary>
            将 key 改名为 newkey 。
            当 key 和 newkey 相同，或者 key 不存在时，返回一个错误。
            当 newkey 已经存在时， RENAME 命令将覆盖旧值。
            </summary>
            <param name="key1">旧的key</param>
            <param name="key2">新的key</param>
            <returns>
            改名成功时提示 OK ，失败时候返回一个错误。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyType(System.String)">
            <summary>
            返回 key 所储存的值的类型。none (key不存在)，string (字符串)，list (列表)，set (集合)，zset (有序集)，hash (哈希表)
            </summary>
            <param name="key">关键字</param>
            <returns>类型</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyTTL(System.String)">
            <summary>
            以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。
            </summary>
            <param name="key">关键字</param>
            <returns>当 key 不存在时，返回 -2 。当 key 存在但没有设置剩余生存时间时，返回 -1 。否则，以秒为单位，返回 key 的剩余生存时间。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.AppendKey(System.String,System.String)">
            <summary>
            如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾。
            如果 key 不存在， APPEND 就简单地将给定 key 设为 value ，就像执行 SET key value 一样。
            返回追加 value 之后， key 中字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <returns>
            追加 value 之后， key 中字符串的长度。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String)">
            <summary>
            将 key 中储存的数字值减一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回执行 DECR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>执行 DECR 命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DecrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值减去减量 decrement 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 DECR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            本操作的值限制在 64 位(bit)有符号数字表示之内。
            返回减去 decrement 之后， key 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">操作的值</param>
            <returns>返回减去 decrement 之后， key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String)">
            <summary>
            返回 key 所关联的字符串值。如果 key 不存在那么返回特殊值 nil 。
            假如 key 储存的值不是字符串类型，返回一个错误，因为 GET 只能用于处理字符串值。
            </summary>
            <param name="key">关键字</param>
            <returns>当 key 不存在时，返回 nil ，否则，返回 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyRange(System.String,System.Int32,System.Int32)">
            <summary>
            返回 key 中字符串值的子字符串，字符串的截取范围由 start 和 end 两个偏移量决定(包括 start 和 end 在内)。
            负数偏移量表示从字符串最后开始计数， -1 表示最后一个字符， -2 表示倒数第二个，以此类推。
            返回截取得出的子字符串。
            </summary>
            <param name="key">关键字</param>
            <param name="start">截取开始的位置</param>
            <param name="end">截取结束的位置</param>
            <returns>返回截取得出的子字符串。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadAndWriteKey(System.String,System.String)">
            <summary>
            将给定 key 的值设为 value ，并返回 key 的旧值(old value)。当 key 存在但不是字符串类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">新的值</param>
            <returns>返回给定 key 的旧值。当 key 没有旧值时，也即是， key 不存在时，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String)">
            <summary>
            将 key 中储存的数字值增一。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            返回执行 INCR 命令之后 key 的值。
            </summary>
            <param name="key">关键字</param>
            <returns>返回执行 INCR 命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Int64)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。
            如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>加上 increment 之后， key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementKey(System.String,System.Single)">
            <summary>
            将 key 所储存的值加上增量 increment 。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBYFLOAT 操作。
            如果命令执行成功，那么 key 的值会被更新为（执行加法之后的）新值，并且新值会以字符串的形式返回给调用者
            </summary>
            <param name="key">关键字</param>
            <param name="value">增量数据</param>
            <returns>执行命令之后 key 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKey(System.String[])">
            <summary>
            返回所有(一个或多个)给定 key 的值。
            如果给定的 key 里面，有某个 key 不存在，那么这个 key 返回特殊值 null 。因此，该命令永不失败。
            </summary>
            <param name="keys">关键字数组</param>
            <returns>一个包含所有给定 key 的值的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String[],System.String[])">
            <summary>
            同时设置一个或多个 key-value 对。
            如果某个给定 key 已经存在，那么 MSET 会用新值覆盖原来的旧值，如果这不是你所希望的效果，请考虑使用 MSETNX 命令：它只会在所有给定 key 都不存在的情况下进行设置操作。
            </summary>
            <param name="keys">关键字数组</param>
            <param name="values">值数组</param>
            <returns>总是返回 OK (因为 MSET 不可能失败)</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。
            如果 key 已经持有其他值， SET 就覆写旧值，无视类型。
            对于某个原本带有生存时间（TTL）的键来说， 当 SET 命令成功在这个键上执行时， 这个键原有的 TTL 将被清除。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns> SET 在设置操作成功完成时，才返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteAndPublishKey(System.String,System.String)">
            <summary>
            将字符串值 value 关联到 key 。并发布一个订阅的频道数据，都成功时，才返回成功
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteExpireKey(System.String,System.String,System.Int64)">
            <summary>
            将值 value 关联到 key ，并将 key 的生存时间设为 seconds (以秒为单位)。如果 key 已经存在， SETEX 命令将覆写旧值。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="seconds">生存时间，单位秒</param>
            <returns>设置成功时返回 OK 。当 seconds 参数不合法时，返回一个错误。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyIfNotExists(System.String,System.String)">
            <summary>
            将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。设置成功，返回 1 。设置失败，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。设置失败，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteKeyRange(System.String,System.String,System.Int32)">
            <summary>
            用 value 参数覆写(overwrite)给定 key 所储存的字符串值，从偏移量 offset 开始。不存在的 key 当作空白字符串处理。返回被 SETRANGE 修改之后，字符串的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="offset">起始的偏移量</param>
            <returns>被 SETRANGE 修改之后，字符串的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadKeyLength(System.String)">
            <summary>
            返回 key 所储存的字符串值的长度。当 key 储存的不是字符串值时，返回一个错误。返回符串值的长度。当 key 不存在时，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <returns>字符串值的长度。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertBefore(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之前。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListInsertAfter(System.String,System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 当中，位于值 pivot 之后。
            当 pivot 不存在于列表 key 时，不执行任何操作。
            当 key 不存在时， key 被视为空列表，不执行任何操作。
            如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">数值</param>
            <param name="pivot">原先的值</param>
            <returns>
            如果命令执行成功，返回插入操作完成之后，列表的长度。
            如果没有找到 pivot ，返回 -1 。
            如果 key 不存在或为空列表，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.GetListLength(System.String)">
            <summary>
            返回列表 key 的长度。如果 key 不存在，则 key 被解释为一个空列表，返回 0 .如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <returns>列表 key 的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadListByIndex(System.String,System.Int64)">
            <summary>
            返回列表 key 中，下标为 index 的元素。下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。如果 key 不是列表类型，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <returns>列表中下标为 index 的元素。如果 index 参数的值不在列表的区间范围内(out of range)，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPop(System.String)">
            <summary>
            移除并返回列表 key 的头元素。列表的头元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的头元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表头，如果 key 不存在，一个空列表会被创建并执行 LPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。返回执行 LPUSH 命令后，列表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>执行 LPUSH 命令后，列表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListLeftPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表头，当且仅当 key 存在并且是一个列表。和 LPUSH 命令相反，当 key 不存在时， LPUSHX 命令什么也不做。
            返回LPUSHX 命令执行之后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>是否插入数据成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRange(System.String,System.Int64,System.Int64)">
            <summary>
            返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。
            下标(index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            返回一个列表，包含指定区间内的元素。
            </summary>
            <param name="key">关键字</param>
            <param name="start">开始的索引</param>
            <param name="stop">结束的索引</param>
            <returns>返回一个列表，包含指定区间内的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRemoveElementMatch(System.String,System.Int64,System.String)">
            <summary>
            根据参数 count 的值，移除列表中与参数 value 相等的元素。count 的值可以是以下几种：
            count > 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。
            count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。
            count = 0 : 移除表中所有与 value 相等的值。
            返回被移除的数量。
            </summary>
            <param name="key">关键字</param>
            <param name="count">移除参数</param>
            <param name="value">匹配的值</param>
            <returns>被移除元素的数量。因为不存在的 key 被视作空表(empty list)，所以当 key 不存在时， LREM 命令总是返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListSet(System.String,System.Int64,System.String)">
            <summary>
            设置数组的某一个索引的数据信息，当 index 参数超出范围，或对一个空列表( key 不存在)进行 LSET 时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="index">索引位置</param>
            <param name="value">值</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListTrim(System.String,System.Int64,System.Int64)">
            <summary>
            对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。
            举个例子，执行命令 LTRIM list 0 2 ，表示只保留列表 list 的前三个元素，其余元素全部删除。
            下标( index)参数 start 和 stop 都以 0 为底，也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素，以此类推。
            你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。
            当 key 不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="start">起始的索引信息</param>
            <param name="end">结束的索引信息</param>
            <returns>操作成功返回 ok ，否则返回错误信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPop(System.String)">
            <summary>
            移除并返回列表 key 的尾元素。当 key 不存在时，返回 nil 。
            </summary>
            <param name="key">关键字信息</param>
            <returns>列表的尾元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPopLeftPush(System.String,System.String)">
            <summary>
            命令 RPOPLPUSH 在一个原子时间内，执行以下两个动作：
            1. 将列表 source 中的最后一个元素( 尾元素)弹出，并返回给客户端。
            2. 将 source 弹出的元素插入到列表 destination ，作为 destination 列表的的头元素。
            举个例子，你有两个列表 source 和 destination ， source 列表有元素 a, b, c ， destination 列表有元素 x, y, z ，执行 RPOPLPUSH source destination 之后， source 列表包含元素 a, b ， destination 列表包含元素 c, x, y, z ，并且元素 c 会被返回给客户端。
            如果 source 不存在，值 nil 被返回，并且不执行其他动作。
            如果 source 和 destination 相同，则列表中的表尾元素被移动到表头，并返回该元素，可以把这种特殊情况视作列表的旋转( rotation)操作。
            </summary>
            <param name="key1">第一个关键字</param>
            <param name="key2">第二个关键字</param>
            <returns>返回的移除的对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String)">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPush(System.String,System.String[])">
            <summary>
            将一个或多个值 value 插入到列表 key 的表尾(最右边)。
            如果有多个 value 值，那么各个 value 值按从左到右的顺序依次插入到表尾：比如对一个空列表 mylist 执行 RPUSH mylist a b c ，得出的结果列表为 a b c ，
            如果 key 不存在，一个空列表会被创建并执行 RPUSH 操作。当 key 存在但不是列表类型时，返回一个错误。
            返回执行 RPUSH 操作后，表的长度。
            </summary>
            <param name="key">关键字</param>
            <param name="values">值</param>
            <returns>返回执行 RPUSH 操作后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ListRightPushX(System.String,System.String)">
            <summary>
            将值 value 插入到列表 key 的表尾，当且仅当 key 存在并且是一个列表。
            和 RPUSH 命令相反，当 key 不存在时， RPUSHX 命令什么也不做。
            </summary>
            <param name="key">关键字</param>
            <param name="value">值</param>
            <returns>RPUSHX 命令执行之后，表的长度。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String)">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DeleteHashKey(System.String,System.String[])">
            <summary>
            删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。返回被成功移除的域的数量，不包括被忽略的域。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">所有的域</param>
            <returns>返回被成功移除的域的数量，不包括被忽略的域。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ExistsHashKey(System.String,System.String)">
            <summary>
            查看哈希表 key 中，给定域 field 是否存在。如果哈希表含有给定域，返回 1 。
            如果哈希表不含有给定域，或 key 不存在，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <returns>如果哈希表含有给定域，返回 1 。如果哈希表不含有给定域，或 key 不存在，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String)">
            <summary>
            返回哈希表 key 中给定域 field 的值。当给定域不存在或是给定 key 不存在时，返回 nil 
            </summary>
            <param name="key">关键值</param>
            <param name="field">域</param>
            <returns>
            给定域的值。
            当给定域不存在或是给定 key 不存在时，返回 nil 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyAll(System.String)">
            <summary>
            返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。
            </summary>
            <param name="key">关键值</param>
            <returns>
            以列表形式返回哈希表的域和域的值。
            若 key 不存在，返回空列表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Int64)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.IncrementHashKey(System.String,System.String,System.Single)">
            <summary>
            为哈希表 key 中的域 field 的值加上增量 increment 。增量也可以为负数，相当于对给定域进行减法操作。
            如果 key 不存在，一个新的哈希表被创建并执行 HINCRBY 命令。返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">增量值</param>
            <returns>返回执行 HINCRBY 命令之后，哈希表 key 中域 field 的值。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeys(System.String)">
            <summary>
            返回哈希表 key 中的所有域。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            一个包含哈希表中所有域的表。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKeyLength(System.String)">
            <summary>
            返回哈希表 key 中域的数量。
            </summary>
            <param name="key">关键字</param>
            <returns>哈希表中域的数量。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashKey(System.String,System.String[])">
            <summary>
            返回哈希表 key 中，一个或多个给定域的值。如果给定的域不存在于哈希表，那么返回一个 nil 值。
            因为不存在的 key 被当作一个空哈希表来处理，所以对一个不存在的 key 进行 HMGET 操作将返回一个只带有 nil 值的表。
            </summary>
            <param name="key">关键值</param>
            <param name="fields">指定的域</param>
            <returns>
            一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设为 value 。
            如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。
            如果域 field 已经存在于哈希表中，旧值将被覆盖。
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>
            如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。
            如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKey(System.String,System.String[],System.String[])">
            <summary>
            同时将多个 field-value (域-值)对设置到哈希表 key 中。
            此命令会覆盖哈希表中已存在的域。
            如果 key 不存在，一个空哈希表被创建并执行 HMSET 操作。
            </summary>
            <param name="key">关键字</param>
            <param name="fields">域</param>
            <param name="values">数据值</param>
            <returns>
            如果命令执行成功，返回 OK 。
            当 key 不是哈希表(hash)类型时，返回一个错误
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.WriteHashKeyNx(System.String,System.String,System.String)">
            <summary>
            将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在。若域 field 已经存在，该操作无效。
            设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。
            </summary>
            <param name="key">关键字</param>
            <param name="field">域</param>
            <param name="value">数据值</param>
            <returns>设置成功，返回 1 。如果给定域已经存在且没有操作被执行，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadHashValues(System.String)">
            <summary>
            返回哈希表 key 中所有域的值。当 key 不存在时，返回一个空表。
            </summary>
            <param name="key">关键值</param>
            <returns>
            返回哈希表 key 中所有域的值。
            当 key 不存在时，返回一个空表。
            </returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String)">
            <summary>
            将一个member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="member">等待添加的元素</param>
            <returns>被添加到集合中的新元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetAdd(System.String,System.String[])">
            <summary>
            将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。
            </summary>
            <param name="key">关键字信息</param>
            <param name="members">等待添加的元素</param>
            <returns>被添加到集合中的新元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetCard(System.String)">
            <summary>
            返回集合 key 的基数(集合中元素的数量)。当 key 不存在时，返回 0 。
            </summary>
            <param name="key">集合 key 的名称</param>
            <returns>集合的基数。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合之间的差集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="diffKey">集合关键字</param>
            <returns>交集成员的列表。</returns>
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])"/>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiff(System.String,System.String[])">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合之间的差集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="diffKeys">集合关键字</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String)">
            <summary>
            这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="diffKey">运算的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetDiffStore(System.String,System.String,System.String[])">
            <summary>
            这个命令的作用和 SDIFF 类似，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="diffKeys">运算的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。
            </summary>
            <param name="key">集合关键字</param>
            <param name="interKey">运算的集合</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInter(System.String,System.String[])">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的交集。不存在的 key 被视为空集。当给定集合当中有一个空集时，结果也为空集(根据集合运算定律)。
            </summary>
            <param name="key">集合关键字</param>
            <param name="interKeys">运算的集合</param>
            <returns>交集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String)">
            <summary>
            这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="interKey">运算的集合</param>
            <returns>结果集中的成员数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetInterStore(System.String,System.String,System.String[])">
            <summary>
            这个命令类似于 SINTER 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 集合已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">目标集合</param>
            <param name="key">等待操作的集合</param>
            <param name="interKeys">运算的集合</param>
            <returns>结果集中的成员数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetIsMember(System.String,System.String)">
            <summary>
            判断 member 元素是否集合 key 的成员。如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。
            </summary>
            <param name="key">集合key</param>
            <param name="member">元素</param>
            <returns>如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMembers(System.String)">
            <summary>
            返回集合 key 中的所有成员。不存在的 key 被视为空集合。
            </summary>
            <param name="key">集合key</param>
            <returns>集合中的所有成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetMove(System.String,System.String,System.String)">
            <summary>
            将 member 元素从 source 集合移动到 destination 集合。如果 source 集合不存在或不包含指定的 member 元素，则 SMOVE 命令不执行任何操作，仅返回 0 。
            否则， member 元素从 source 集合中被移除，并添加到 destination 集合中去。当 destination 集合已经包含 member 元素时， SMOVE 命令只是简单地将 source 集合中的 member 元素删除。
            当 source 或 destination 不是集合类型时，返回一个错误。
            </summary>
            <param name="source">原集合</param>
            <param name="destination">目标集合</param>
            <param name="member">元素</param>
            <returns>如果 member 元素被成功移除，返回 1 。如果 member 元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetPop(System.String)">
            <summary>
            移除并返回集合中的一个随机元素。如果只想获取一个随机元素，但不想该元素从集合中被移除的话，可以使用 SRANDMEMBER 命令。
            </summary>
            <param name="key">集合关键字</param>
            <returns>被移除的随机元素。当 key 不存在或 key 是空集时，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String)">
            <summary>
            那么返回集合中的一个随机元素。
            </summary>
            <param name="key">集合关键字</param>
            <returns>返回一个元素；如果集合为空，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRandomMember(System.String,System.Int32)">
            <summary>
            返回集合中的多个随机元素。<br />
            如果 count 为正数，且小于集合基数，那么命令返回一个包含 count 个元素的数组，数组中的元素各不相同。如果 count 大于等于集合基数，那么返回整个集合。<br />
            如果 count 为负数，那么命令返回一个数组，数组中的元素可能会重复出现多次，而数组的长度为 count 的绝对值。
            </summary>
            <param name="key">集合关键字</param>
            <param name="count">元素个数</param>
            <returns>返回一个数组；如果集合为空，返回空数组。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String)">
            <summary>
            移除集合 key 中的一个元素，不存在的 member 元素会被忽略。
            </summary>
            <param name="key">集合关键字</param>
            <param name="member">等待移除的元素</param>
            <returns>被成功移除的元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetRemove(System.String,System.String[])">
            <summary>
            移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。
            </summary>
            <param name="key">集合关键字</param>
            <param name="members">等待移除的元素</param>
            <returns>被成功移除的元素的数量，不包括被忽略的元素。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String)">
            <summary>
            返回一个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="unionKey">并集的集合</param>
            <returns>并集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnion(System.String,System.String[])">
            <summary>
            返回一个或多个集合的全部成员，该集合是所有给定集合的并集。不存在的 key 被视为空集。
            </summary>
            <param name="key">集合关键字</param>
            <param name="unionKeys">并集的集合</param>
            <returns>并集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String)">
            <summary>
            这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">存储的目标集合</param>
            <param name="key">集合关键字</param>
            <param name="unionKey">并集的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SetUnionStore(System.String,System.String,System.String[])">
            <summary>
            这个命令类似于 SUNION 命令，但它将结果保存到 destination 集合，而不是简单地返回结果集。如果 destination 已经存在，则将其覆盖。destination 可以是 key 本身。
            </summary>
            <param name="destination">存储的目标集合</param>
            <param name="key">集合关键字</param>
            <param name="unionKeys">并集的集合</param>
            <returns>结果集中的元素数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String,System.Double)">
            <summary>
            将一个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。
            score 值可以是整数值或双精度浮点数。<br />
            如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">有序集合的元素</param>
            <param name="score">每个元素的得分</param>
            <returns>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetAdd(System.String,System.String[],System.Double[])">
            <summary>
            将一个或多个 member 元素及其 score 值加入到有序集 key 当中。如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。
            score 值可以是整数值或双精度浮点数。<br />
            如果 key 不存在，则创建一个空的有序集并执行 ZADD 操作。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="members">有序集合的元素</param>
            <param name="scores">每个元素的得分</param>
            <returns>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCard(System.String)">
            <summary>
            返回有序集 key 的基数。
            </summary>
            <param name="key">有序集合的关键字</param>
            <returns>当 key 存在且是有序集类型时，返回有序集的基数。当 key 不存在时，返回 0 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetCount(System.String,System.Double,System.Double)">
            <summary>
            返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，包含</param>
            <param name="max">最大值，包含</param>
            <returns>score 值在 min 和 max 之间的成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetIncreaseBy(System.String,System.String,System.Double)">
            <summary>
            为有序集 key 的成员 member 的 score 值加上增量 increment 。可以通过传递一个负数值 increment ，让 score 减去相应的值，比如 ZINCRBY key -5 member ，就是让 member 的 score 值减去 5 。
            当 key 不存在，或 member 不是 key 的成员时， ZINCRBY key increment member 等同于 ZADD key increment member 。当 key 不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员名称</param>
            <param name="increment">增量数据，可以为负数</param>
            <returns>member 成员的新 score 值，以字符串形式表示。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序来排列。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <remarks>
            超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start > stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。
            可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。
            </remarks>
            <param name="key">有序集合的关键字</param>
            <param name="start">起始的下标</param>
            <param name="stop">结束的下标</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，根据参数 withScore 来决定是否带 score 值的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <summary>
            返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 "(" 符号来使用可选的开区间 (小于或大于)。"(5"代表不包含5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，可以为-inf，代表最高，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="max">最大值，可以为+inf，代表最低，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，带有 score 值(根据参数 withScore 来决定)的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRank(System.String,System.String)">
            <summary>
            返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。排名以 0 为底，也就是说， score 值最小的成员排名为 0 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员 member 的名称</param>
            <returns>如果 member 是有序集 key 的成员，返回 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String)">
            <summary>
            移除有序集 key 中的指定成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">等待被移除的成员</param>
            <returns>被成功移除的成员的数量，不包括被忽略的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemove(System.String,System.String[])">
            <summary>
            移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="members">等待被移除的成员</param>
            <returns>被成功移除的成员的数量，不包括被忽略的成员。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByRank(System.String,System.Int32,System.Int32)">
            <summary>
            移除有序集 key 中，指定排名(rank)区间内的所有成员。区间分别以下标参数 start 和 stop 指出，包含 start 和 stop 在内。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <param name="key">有序集合的关键</param>
            <param name="start">开始的下标</param>
            <param name="stop">结束的下标</param>
            <returns>被移除成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetRemoveRangeByScore(System.String,System.String,System.String)">
            <summary>
            移除有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 "(" 符号来使用可选的开区间 (小于或大于)。例如"(5"代表不包括5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="min">最小值，可以为-inf，代表最低，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="max">最大值，可以为+inf，代表最低，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <returns>被移除成员的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRange(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列。具有相同 score 值的成员按字典序来排列。
            下标参数 start 和 stop 都以 0 为底，也就是说，以 0 表示有序集第一个成员，以 1 表示有序集第二个成员，以此类推。你也可以使用负数下标，以 -1 表示最后一个成员， -2 表示倒数第二个成员，以此类推。
            </summary>
            <remarks>
            超出范围的下标并不会引起错误。比如说，当 start 的值比有序集的最大下标还要大，或是 start > stop 时， ZRANGE 命令只是简单地返回一个空列表。另一方面，假如 stop 参数的值比有序集的最大下标还要大，那么 Redis 将 stop 当作最大下标来处理。
            可以通过使用 WITHSCORES 选项，来让成员和它的 score 值一并返回，返回列表以 value1,score1, ..., valueN,scoreN 的格式表示。客户端库可能会返回一些更复杂的数据类型，比如数组、元组等。
            </remarks>
            <param name="key">有序集合的关键字</param>
            <param name="start">起始的下标</param>
            <param name="stop">结束的下标</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，根据参数 withScore 来决定是否带 score 值的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRangeByScore(System.String,System.String,System.String,System.Boolean)">
            <summary>
            返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。序集成员按 score 值递减(从大到小)的次序排列。
            min 和 max 可以是 -inf 和 +inf ，这样一来，你就可以在不知道有序集的最低和最高 score 值的情况下，使用 ZRANGEBYSCORE 这类命令。
            默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，你也可以通过给参数前增加 ( 符号来使用可选的开区间 (小于或大于)。(5代表不包含5
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="max">最大值，可以为+inf，代表最高，如果为10，代表小于等于5，如果是(10，代表小于10</param>
            <param name="min">最小值，可以为-inf，代表最低，如果为5，代表大于等于5，如果是(5，代表大于5</param>
            <param name="withScore">是否带有 score 返回</param>
            <returns>指定区间内，带有 score 值(根据参数 withScore 来决定)的有序集成员的列表。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetReverseRank(System.String,System.String)">
            <summary>
            返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序。排名以 0 为底，也就是说，score 值最大的成员排名为 0 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员 member 的名称</param>
            <returns>如果 member 是有序集 key 的成员，返回 member 的排名。如果 member 不是有序集 key 的成员，返回 nil 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ZSetScore(System.String,System.String)">
            <summary>
            返回有序集 key 中，成员 member 的 score 值。如果 member 元素不是有序集 key 的成员，或 key 不存在，返回 nil 。
            </summary>
            <param name="key">有序集合的关键字</param>
            <param name="member">成员的名称</param>
            <returns>member 成员的 score 值，以字符串形式表示。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1">
            <summary>
            从设备里读取支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>，
            <see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <returns>包含是否成功的结果对象</returns>
            <example>
            我们来说明下这个方法到底是怎么用的，当我们需要读取redis好几个数据的时候，我们很可能写如下的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample1" title="基础的使用" />
            总的来说，当读取的数据种类比较多的时候，读取的关键字比较多的时候，处理起来就比较的麻烦，此处推荐一个全新的写法，为了更好的对比，我们假设实现一种需求
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample2" title="同等代码" />
            为此我们只需要实现一个特性类即可。代码如下：(注意，实际是很灵活的，类型都是自动转换的)
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="SampleClass" title="数据类" />
            当然了，异步也是一样的，异步的代码就不重复介绍了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Enthernet\RedisSample.cs" region="Sample3" title="异步示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Write``1(``0)">
            <summary>
            从设备里写入支持Hsl特性的数据内容，
            该特性为<see cref="T:HslCommunication.Reflection.HslRedisKeyAttribute"/> ，<see cref="T:HslCommunication.Reflection.HslRedisHashFieldAttribute"/>
            需要注意的是写入并不支持<see cref="T:HslCommunication.Reflection.HslRedisListAttribute"/>，<see cref="T:HslCommunication.Reflection.HslRedisListItemAttribute"/>特性，详细参考代码示例的操作说明。
            </summary>
            <typeparam name="T">自定义的数据类型对象</typeparam>
            <param name="data">等待写入的数据参数</param>
            <returns>包含是否成功的结果对象</returns>
            <example>
            <inheritdoc cref="M:HslCommunication.Enthernet.Redis.RedisClient.Read``1" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Save">
            <summary>
            SAVE 命令执行一个同步保存操作，将当前 Redis 实例的所有数据快照(snapshot)以 RDB 文件的形式保存到硬盘。
            </summary>
            <returns>保存成功时返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SaveAsync">
            <summary>
            在后台异步(Asynchronously)保存当前数据库的数据到磁盘。
            BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
            </summary>
            <returns>反馈信息。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ReadServerTime">
            <summary>
            获取服务器的时间戳信息，可用于本地时间的数据同步问题
            </summary>
            <returns>带有服务器时间的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Ping">
            <summary>
            向服务器进行PING的操作，服务器会返回PONG操作
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.DBSize">
            <summary>
            返回当前数据库的 key 的数量。
            </summary>
            <returns>当前数据库的 key 的数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.FlushDB">
            <summary>
            清空当前的数据库的key信息
            </summary>
            <returns>总是返回 OK 。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ChangePassword(System.String)">
            <summary>
            修改Redis的密码信息，如果不需要密码，则传入空字符串即可
            </summary>
            <param name="password">密码信息</param>
            <returns>是否更新了密码信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.Publish(System.String,System.String)">
            <summary>
            将信息 message 发送到指定的频道 channel，返回接收到信息 message 的订阅者数量。
            </summary>
            <param name="channel">频道，和关键字不是一回事</param>
            <param name="message">消息</param>
            <returns>接收到信息 message 的订阅者数量。</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.SelectDB(System.Int32)">
            <summary>
            切换到指定的数据库，数据库索引号 index 用数字值指定，以 0 作为起始索引值。默认使用 0 号数据库。
            </summary>
            <param name="db">索引值</param>
            <returns>是否切换成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisHelper">
            <summary>
            提供了redis辅助类的一些方法
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.PackStringCommand(System.String[])">
            <summary>
            将字符串数组打包成一个redis的报文信息
            </summary>
            <param name="commands">字节数据信息</param>
            <returns>结果报文信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetLongNumberFromCommandLine(System.Byte[])">
            <summary>
            从原始的结果数据对象中提取出数字数据
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetStringFromCommandLine(System.Byte[])">
            <summary>
            从结果的数据对象里提取字符串的信息
            </summary>
            <param name="commandLine">原始的字节数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisHelper.GetStringsFromCommandLine(System.Byte[])">
            <summary>
            从redis的结果数据中分析出所有的字符串信息
            </summary>
            <param name="commandLine">结果数据</param>
            <returns>带有结果对象的数据信息</returns>
        </member>
        <member name="T:HslCommunication.Enthernet.Redis.RedisSubscribe">
            <summary>
            Redis协议的订阅操作，一个对象订阅一个或是多个频道的信息
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String[])">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="keys">订阅关键字</param>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.#ctor(System.String,System.Int32,System.String)">
            <summary>
            实例化一个发布订阅类的客户端，需要指定ip地址，端口，及订阅关键字
            </summary>
            <param name="ipAddress">服务器的IP地址</param>
            <param name="port">服务器的端口号</param>
            <param name="key">订阅关键字</param>
        </member>
        <member name="P:HslCommunication.Enthernet.Redis.RedisSubscribe.Password">
            <summary>
            如果Redis服务器设置了密码，此处就需要进行设置。必须在CreatePush方法调用前设置
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.CreatePush(System.Action{System.String,System.String})">
            <summary>
            创建数据推送服务
            </summary>
            <param name="pushCallBack">触发数据推送的委托</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ClosePush">
            <summary>
            关闭消息推送的界面
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.Redis.RedisSubscribe.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSimplifyClient">
            <summary>
            同步访问数据的客户端类，用于向服务器请求一些确定的数据信息
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormSimplifyNet.cs" region="FormSimplifyNet" title="FormSimplifyNet示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            实例化一个客户端的对象，用于和服务器通信
            </summary>
            <param name="ipAddress">服务器的ip地址</param>
            <param name="port">服务器的端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.#ctor">
            <summary>
            实例化一个客户端对象，需要手动指定Ip地址和端口
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.String[])">
            <summary>
            客户端向服务器进行请求，请求字符串数组，忽略了自定义消息反馈
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            需要发送的底层数据
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSimplifyServer">
            <summary>
            消息处理服务器，主要用来实现接收客户端信息并进行消息反馈的操作，适用于客户端进行远程的调用，要求服务器反馈数据。<br />
            The message processing server is mainly used to implement the operation of receiving client information and performing message feedback. It is applicable to remote calls made by clients and requires the server to feedback data.
            </summary>
            <remarks>
            详细的使用说明，请参照博客<a href="http://www.cnblogs.com/dathlin/p/7697782.html">http://www.cnblogs.com/dathlin/p/7697782.html</a>
            </remarks>
            <example>
            此处贴上了Demo项目的服务器配置的示例代码
            <code lang="cs" source="TestProject\SimplifyNetTest\FormServer.cs" region="Simplify Net" title="NetSimplifyServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceiveStringEvent">
            <summary>
            接收字符串信息的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceiveStringArrayEvent">
            <summary>
            接收字符串数组信息的事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetSimplifyServer.ReceivedBytesEvent">
            <summary>
            接收字节信息的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String[])">
            <summary>
            向指定的通信对象发送字符串数组
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数组</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.CloseAction">
            <summary>
            关闭网络的操作
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <summary>
            当接收到了新的请求的时候执行的操作
            </summary>
            <param name="socket">异步对象</param>
            <param name="endPoint">终结点</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.AppSessionRemoteClose(HslCommunication.Core.Net.AppSession)">
            <summary>
            让客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">会话对象</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetSimplifyServer.ClientCount">
            <summary>
            当前在线的客户端数量
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSimplifyServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetSoftUpdateServer">
            <summary>
            用于服务器支持软件全自动更新升级的类<br />
            Class for server support software full automatic update and upgrade
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.#ctor(System.String)">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
            <param name="updateExeFileName">更新程序的名称</param>
        </member>
        <member name="P:HslCommunication.Enthernet.NetSoftUpdateServer.FileUpdatePath">
            <summary>
            系统升级时客户端所在的目录，默认为C:\HslCommunication
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.GetAllFiles(System.String,HslCommunication.LogNet.ILogNet)">
            <summary>
            获取所有的文件信息
            </summary>
            <param name="dircPath">目标路径</param>
            <param name="logNet">日志信息</param>
            <returns>文件名的列表</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetSoftUpdateServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetUdpClient">
            <summary>
            UDP客户端的类，负责发送数据到服务器，然后从服务器接收对应的数据信息，该数据经过HSL封装<br />
            UDP client class, responsible for sending data to the server, and then receiving the corresponding data information from the server, the data is encapsulated by HSL
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.#ctor(System.String,System.Int32)">
            <summary>
            实例化对象，指定发送的服务器地址和端口号<br />
            Instantiated object, specifying the server address and port number to send
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，忽略了自定义消息反馈<br />
            The client makes a request to the server, requesting string data, and ignoring custom message feedback
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据<br />
            The client makes a request to the server, requesting byte data
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送的字节内容</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.String)">
            <summary>
            客户端向服务器进行请求，请求字符串数据，并返回状态信息<br />
            The client makes a request to the server, requests string data, and returns status information
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServer(HslCommunication.NetHandle,System.Byte[])">
            <summary>
            客户端向服务器进行请求，请求字节数据，并返回状态信息<br />
            The client makes a request to the server, requests byte data, and returns status information
            </summary>
            <param name="customer">用户的指令头</param>
            <param name="send">发送数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadFromServerBase(System.Byte[])">
            <summary>
            发送的底层数据，然后返回结果数据<br />
            Send the underlying data and then return the result data
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ReadCustomerFromServerBase(System.Byte[])">
            <summary>
            发送的底层数据，然后返回结果数据，该结果是带Handle信息的。<br />
            Send the underlying data, and then return the result data, the result is with Handle information.
            </summary>
            <param name="send">需要发送的底层数据</param>
            <returns>带返回消息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Enthernet.NetUdpServer">
            <summary>
            Udp网络的服务器端类，您可以使用本类构建一个简单的，高性能的udp服务器，接收来自其他客户端的数据，当然，您也可以自定义返回你要返回的数据<br />
            Server-side class of Udp network. You can use this class to build a simple, high-performance udp server that receives data from other clients. Of course, you can also customize the data you want to return.
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.#ctor">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Enthernet.NetUdpServer.ReceiveCacheLength">
            <summary>
            获取或设置一次接收时的数据长度，默认2KB数据长度
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.RefreshReceive">
            <summary>
            重新开始接收数据
            </summary>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.DataProcessingCenter(HslCommunication.Core.Net.AppSession,System.Int32,System.Int32,System.Byte[])">
            <summary>
            数据处理中心
            </summary>
            <param name="session">会话信息</param>
            <param name="protocol">暗号</param>
            <param name="customer"></param>
            <param name="content"></param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.String)">
            <summary>
            向指定的通信对象发送字符串数据
            </summary>
            <param name="session">通信对象</param>
            <param name="customer">用户的指令头</param>
            <param name="str">实际发送的字符串数据</param>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.SendMessage(HslCommunication.Core.Net.AppSession,System.Int32,System.Byte[])">
            <summary>
            向指定的通信对象发送字节数据
            </summary>
            <param name="session">连接对象</param>
            <param name="customer">用户的指令头</param>
            <param name="bytes">实际的数据</param>
        </member>
        <member name="E:HslCommunication.Enthernet.NetUdpServer.AcceptString">
            <summary>
            当接收到文本数据的时候,触发此事件
            </summary>
        </member>
        <member name="E:HslCommunication.Enthernet.NetUdpServer.AcceptByte">
            <summary>
            当接收到字节数据的时候,触发此事件
            </summary>
        </member>
        <member name="M:HslCommunication.Enthernet.NetUdpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLT645">
            <summary>
            基于多功能电能表通信协议实现的通讯类，参考的文档是DLT645-2007
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.#ctor(System.String,System.String,System.String)">
            <summary>
            指定地址域来实例化一个对象
            </summary>
            <param name="station">设备的站号信息</param>
            <param name="password">密码，写入的时候进行验证的信息</param>
            <param name="opCode">操作者代码</param>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ActiveDeveice">
            <summary>
            激活设备的命令，在设备
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.Read(System.String,System.UInt16)">
            <summary>
            地址为数据标识
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度信息</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.Write(System.String,System.Byte[])">
            <summary>
            写入数据信息
            </summary>
            <param name="address">地址信息</param>
            <param name="value">写入的数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ReadAddress">
            <summary>
            读取设备的通信地址，仅支持点对点通讯的情况
            </summary>
            <returns>设备的通信地址</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.WriteAddress(System.String)">
            <summary>
            写入设备的通信地址，仅支持点对点通讯的情况
            </summary>
            <param name="address">等待写入的地址域</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.BroadcastTime(System.DateTime)">
            <summary>
            广播指定的时间，强制从站与主站时间同步
            </summary>
            <param name="dateTime">时间</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.FreezeCommand(System.String)">
            <summary>
            对设备发送冻结命令，默认点对点操作，地址域为99999999999999时为广播，数据域格式说明：MMDDhhmm(月日时分)，
            99DDhhmm表示月为周期定时冻结，9999hhmm表示日为周期定时冻结，999999mm表示以小时为周期定时冻结，99999999表示瞬时冻结
            </summary>
            <param name="dataArea">数据域信息</param>
            <returns>是否成功冻结</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ChangeBaudRate(System.String)">
            <summary>
            更改通信速率，波特率可选600,1200,2400,4800,9600,19200，其他值无效，可以携带地址域信息，s=1;9600
            </summary>
            <param name="baudRate">波特率的信息</param>
            <returns>是否更改成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.GetAddressByteFromString(System.String)">
            <summary>
            将地址解析成BCD码的地址，并且扩充到12位，不够的补0操作
            </summary>
            <param name="address">地址域信息</param>
            <returns>实际的结果</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.BuildEntireCommand(System.String,System.Byte,System.Byte[])">
            <summary>
            将指定的地址信息，控制码信息，数据域信息打包成完整的报文命令
            </summary>
            <param name="address">地址域信息，地址域由6个字节构成，每字节2位BCD码，地址长度可达12位十进制数。地址域支持锁位寻址，即从若干低位起，剩余高位补AAH作为通配符进行读表操作</param>
            <param name="control">控制码信息</param>
            <param name="dataArea">数据域的内容</param>
            <returns>返回是否报文创建成功</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.AnalysisBytesAddress(System.String,System.String)">
            <summary>
            从用户输入的地址信息中解析出真实的地址及数据标识
            </summary>
            <param name="address">用户输入的地址信息</param>
            <param name="defalut">默认的地址域</param>
            <returns>解析结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.AnalysisIntegerAddress(System.String,System.String)">
            <summary>
            从用户输入的地址信息中解析出真实的地址及数据标识
            </summary>
            <param name="address">用户输入的地址信息</param>
            <param name="defalut">默认的地址域</param>
            <returns>解析结果信息</returns>
        </member>
        <member name="M:HslCommunication.Instrument.DLT.DLT645.CheckResponse(System.Byte[])">
            <summary>
            检查当前的反馈数据信息是否正确
            </summary>
            <param name="response">从仪表反馈的数据信息</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="T:HslCommunication.Instrument.DLT.DLTControl">
            <summary>
            基本的控制码信息
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.Retain">
            <summary>
            保留
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.Broadcast">
            <summary>
            广播
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadData">
            <summary>
            读数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadFollowData">
            <summary>
            读后续数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ReadAddress">
            <summary>
            读通信地址
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.WriteData">
            <summary>
            写数据
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.WriteAddress">
            <summary>
            写通信地址
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.FreezeCommand">
            <summary>
            冻结命令
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ChangeBaudRate">
            <summary>
            更改通信速率
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ChangePassword">
            <summary>
            修改密码
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ClearMaxQuantityDemanded">
            <summary>
            最大需求量清零
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.ElectricityReset">
            <summary>
            电表清零
            </summary>
        </member>
        <member name="F:HslCommunication.Instrument.DLT.DLTControl.EventReset">
            <summary>
            事件清零
            </summary>
        </member>
        <member name="T:HslCommunication.Instrument.Temperature.DAM3601">
            <summary>
            阿尔泰科技发展有限公司的DAM3601温度采集模块，基于ModbusRtu开发完成。
            </summary>
            <remarks>
            该温度采集模块是基于modbus-rtu，但不是标准的modbus协议，存在一些小误差，需要重写实现，并且提供了基础的数据转换
            </remarks>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.#ctor(System.Byte)">
            <summary>
            使用站号实例化默认的对象
            </summary>
            <param name="station">站号信息</param>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.ReadAllTemperature">
            <summary>
            读取所有的温度数据，并转化成相关的信息
            </summary>
            <returns>结果数据对象</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.TransformValue(System.Int16)">
            <summary>
            数据转换方法，将读取的值，
            </summary>
            <param name="value">读取的值</param>
            <returns>转换后的值</returns>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度
            </summary>
            <param name="address">起始地址，格式为"1234"，或者是带功能码格式x=3;1234</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample2" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Instrument.Temperature.DAM3601.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Language.DefaultLanguage">
            <summary>
            系统的语言基类，默认也即是中文版本
            </summary>
        </member>
        <member name="T:HslCommunication.Language.English">
            <summary>
            English Version Text
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.ILogNet">
            <summary>
            一个通用的日志接口，支持5个等级的日志消息写入，支持设置当前的消息等级，定义一个消息存储前的触发事件。<br />
            A general-purpose log interface, supports the writing of 5 levels of log messages, supports setting the current message level, and defining a trigger event before a message is stored.
            </summary>
            <remarks>
            本组件的日志核心机制，如果您使用了本组件却不想使用本组件的日志组件功能，可以自己实现新的日志组件，只要继承本接口接口。其他常用的日志组件如下：（都是可以实现的）
            <list type="number">
            <item>Log4Net</item>
            <item>NLog</item>
            </list>
            </remarks>
            <example>
            自己实例化操作，在HslCommunication里面，可选三种类型
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example2" title="限制文件大小实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example3" title="日期存储实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            Form的示例，存储日志的使用都是一样的，就是实例化的时候不一致，以下示例代码以单文件日志为例
            <code lang="cs" source="TestProject\HslCommunicationDemo\Hsl\FormLogNet.cs" region="ILogNet" title="ILogNet示例" />
            </example>
        </member>
        <member name="P:HslCommunication.LogNet.ILogNet.LogSaveMode">
            <summary>
            日志存储模式，1:单文件，2:按大小存储，3:按时间存储<br />
            Log storage mode, 1: single file, 2: storage by size, 3: storage by time
            </summary>
        </member>
        <member name="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile">
            <summary>
            存储之前引发的事件，允许额外的操作，比如打印控制台，存储数据库等等<br />
            Store previously raised events, allowing additional operations, such as print console, store database, etc.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)">
            <summary>
            通过指定消息等级，关键字，日志信息进行消息记录<br />
            Record messages by specifying message level, keywords, and log information
            </summary>
            <param name="degree">消息等级</param>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDescrition(System.String)">
            <summary>
            写入一条解释性的信息，不属于消息等级控制的范畴<br />
            Write an explanatory message that is not part of message level control
            </summary>
            <param name="description">解释文本</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String)">
            <summary>
            写入一条调试日志<br />
            Write a debug log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String,System.String)">
            <summary>
            写入一条带关键字的调试日志<br />
            Write a debug log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteError(System.String)">
            <summary>
            写入一条错误日志<br />
            Write an error log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteError(System.String,System.String)">
            <summary>
            写入一条带关键字的错误日志<br />
            Write an error log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.Exception)">
            <summary>
            写入一条带关键字的异常信息<br />
            Write an exception log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.String,System.Exception)">
            <summary>
            写入一条带关键字和描述信息的异常信息<br />
            Write an exception log with keywords and text
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">内容</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String)">
            <summary>
            写入一条致命日志<br />
            Write an fatal log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String,System.String)">
            <summary>
            写入一条带关键字的致命日志<br />
            Write an fatal log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String)">
            <summary>
            写入一条普通日志<br />
            Write an infomation log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String,System.String)">
            <summary>
            写入一条带关键字的普通日志<br />
            Write an information log with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteNewLine">
            <summary>
            写入一行换行符<br />
            Write a newline
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteAnyString(System.String)">
            <summary>
            写入任意字符串<br />
            Write arbitrary string
            </summary>
            <param name="text">文本</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String)">
            <summary>
            写入一条警告日志<br />
            Write an warn log
            </summary>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String,System.String)">
            <summary>
            写入一条带关键字的警告日志<br />
            Write an warn log  with keywords
            </summary>
            <param name="keyWord">关键字</param>
            <param name="text">日志内容</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)">
            <summary>
            设置日志的存储等级，高于该等级的才会被存储<br />
            Set the storage level of the logs. Only the logs above this level will be stored.
            </summary>
            <param name="degree">登记信息</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.GetExistLogFileNames">
            <summary>
            获取已存在的日志文件名称<br />
            Get the name of an existing log file
            </summary>
            <returns>文件列表</returns>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.FiltrateKeyword(System.String)">
            <summary>
            过滤掉指定的关键字的日志，该信息不存储，但仍然触发<see cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile"/>事件<br />
            Filter out the logs of the specified keywords, the information is not stored, but the <see cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile" /> event is still triggered
            </summary>
            <param name="keyword">关键字</param>
        </member>
        <member name="M:HslCommunication.LogNet.ILogNet.RemoveFiltrate(System.String)">
            <summary>
            移除过滤的关键字存储<br />
            Remove filtered keyword storage
            </summary>
            <param name="keyword">关键字</param>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetBase">
            <summary>
            日志存储类的基类，提供一些基础的服务
            </summary>
            <remarks>
            基于此类可以实现任意的规则的日志存储规则，欢迎大家补充实现，本组件实现了3个日志类
            <list type="number">
            <item>单文件日志类 <see cref="T:HslCommunication.LogNet.LogNetSingle"/></item>
            <item>根据文件大小的类 <see cref="T:HslCommunication.LogNet.LogNetFileSize"/></item>
            <item>根据时间进行存储的类 <see cref="T:HslCommunication.LogNet.LogNetDateTime"/></item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.#ctor">
            <summary>
            实例化一个日志对象<br />
            Instantiate a log object
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetBase.m_fileSaveLock">
            <summary>
            文件存储的锁
            </summary>
        </member>
        <member name="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile">
            <inheritdoc cref="E:HslCommunication.LogNet.ILogNet.BeforeSaveToFile"/>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetBase.LogSaveMode">
            <inheritdoc cref="P:HslCommunication.LogNet.ILogNet.LogSaveMode"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDebug(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDebug(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDebug(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteInfo(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteInfo(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteInfo(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteWarn(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteWarn(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteWarn(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteError(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteError(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteError(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteError(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteFatal(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteFatal(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteFatal(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteException(System.String,System.Exception)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.Exception)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteException(System.String,System.String,System.Exception)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteException(System.String,System.String,System.Exception)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.RecordMessage(HslCommunication.LogNet.HslMessageDegree,System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteDescrition(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteDescrition(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteAnyString(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteAnyString(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.WriteNewLine">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.WriteNewLine"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.SetMessageDegree(HslCommunication.LogNet.HslMessageDegree)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.FiltrateKeyword(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.FiltrateKeyword(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.RemoveFiltrate(System.String)">
            <inheritdoc cref="M:HslCommunication.LogNet.ILogNet.RemoveFiltrate(System.String)"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否初次调用</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetBase.Dispose">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="T:HslCommunication.LogNet.HslEventArgs">
            <summary>
            带有日志消息的事件
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslEventArgs.HslMessage">
            <summary>
            消息信息
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetException">
            <summary>
            日志存储回调的异常信息
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetException.#ctor(System.Exception)">
            <summary>
            使用其他的异常信息来初始化日志异常
            </summary>
            <param name="innerException">异常信息</param>
        </member>
        <member name="T:HslCommunication.LogNet.LogSaveMode">
            <summary>
            日志文件的存储模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.SingleFile">
            <summary>
            单个文件的存储模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.FileFixedSize">
            <summary>
            根据文件的大小来存储，固定一个大小，不停的生成文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogSaveMode.Time">
            <summary>
            根据时间来存储，可以设置年，季，月，日，小时等等
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.GenerateMode">
            <summary>
            日志文件输出模式
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryHour">
            <summary>
            按每个小时生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryDay">
            <summary>
            按每天生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryWeek">
            <summary>
            按每个周生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryMonth">
            <summary>
            按每个月生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEverySeason">
            <summary>
            按每季度生成日志文件
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.GenerateMode.ByEveryYear">
            <summary>
            按每年生成日志文件
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.HslMessageDegree">
            <summary>
            记录消息的等级
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.None">
            <summary>
            一条消息都不记录
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.FATAL">
            <summary>
            记录致命等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.ERROR">
            <summary>
            记录异常等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.WARN">
            <summary>
            记录警告等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.INFO">
            <summary>
            记录信息等级及以上日志的消息
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.HslMessageDegree.DEBUG">
            <summary>
            记录调试等级及以上日志的信息
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.HslMessageItem">
            <summary>
            单条日志的记录信息，包含了消息等级，线程号，关键字，文本信息<br />
            Record information of a single log, including message level, thread number, keywords, text information
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Id">
            <summary>
            单个记录信息的标识ID，程序重新运行时清空，代表程序从运行以来的日志计数，不管存储的或是未存储的<br />
            The ID of a single record of information. It is cleared when the program is re-run. 
            It represents the log count of the program since it was run, whether stored or unstored.
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Degree">
            <summary>
            消息的等级，包括DEBUG，INFO，WARN，ERROR，FATAL，NONE共计六个等级<br />
            Message levels, including DEBUG, INFO, WARN, ERROR, FATAL, NONE total six levels
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.ThreadId">
            <summary>
            线程ID，发生异常时的线程号<br />
            Thread ID, the thread number when the exception occurred
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Text">
            <summary>
            消息文本，记录日志的时候给定<br />
            Message text, given when logging
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Time">
            <summary>
            记录日志的时间，而非存储日志的时间<br />
            The time the log was recorded, not the time it was stored
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.KeyWord">
            <summary>
            消息的关键字<br />
            Keyword of the message
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.HslMessageItem.Cancel">
            <summary>
            是否取消写入到文件中去，在事件 <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> 触发的时候捕获即可设置。<br />
            Whether to cancel writing to the file, can be set when the event <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> is triggered.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.HslMessageItem.ToStringWithoutKeyword">
            <summary>
            返回表示当前对象的字符串，剔除了关键字
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetManagment">
            <summary>
            日志类的管理器，提供了基本的功能代码。<br />
            The manager of the log class provides the basic function code.
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetManagment.LogFileHeadString">
            <summary>
            日志文件的头标志
            </summary>
        </member>
        <member name="P:HslCommunication.LogNet.LogNetManagment.LogNet">
            <summary>
            公开的一个静态变量，允许随意的设置<br />
            Public static variable, allowing arbitrary setting
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetManagment.GetSaveStringFromException(System.String,System.Exception)">
            <summary>
            通过异常文本格式化成字符串用于保存或发送<br />
            Formatted as a string with exception text for saving or sending
            </summary>
            <param name="text">文本消息</param>
            <param name="ex">异常</param>
            <returns>异常最终信息</returns>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetDateTime">
            <summary>
            一个日志组件，可以根据时间来区分不同的文件存储<br />
            A log component that can distinguish different file storages based on time
            </summary>
            <remarks>
            此日志实例将根据日期时间来进行分类，支持的时间分类如下：
            <list type="number">
            <item>小时</item>
            <item>天</item>
            <item>周</item>
            <item>月份</item>
            <item>季度</item>
            <item>年份</item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example3" title="日期存储实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.#ctor(System.String,HslCommunication.LogNet.GenerateMode)">
            <summary>
            实例化一个根据时间存储的日志组件，需要指定每个文件的存储时间范围<br />
            Instantiate a log component based on time, you need to specify the storage time range for each file
            </summary>
            <param name="filePath">文件存储的路径</param>
            <param name="generateMode">存储文件的间隔</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.GetExistLogFileNames">
            <inheritdoc cref="M:HslCommunication.LogNet.LogNetFileSize.GetExistLogFileNames"/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetDateTime.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetFileSize">
            <summary>
            根据文件的大小来存储日志信息，当前的文件大小增长超过设定值，就会创建新的文件来存储，新的文件命名为当前时间。<br />
            Log information is stored according to the size of the file. If the current file size exceeds the set value, a new file is created for storage, and the new file is named the current time.
            </summary>
            <remarks>
            此日志的实例是根据文件的大小储存，例如设置了2M，每隔2M，系统将生成一个新的日志文件。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example2" title="限制文件大小实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个根据文件大小生成新文件的，默认是2M大的文件<br />
            Instantiate a new file based on the file size. The default is 2M.
            </summary>
            <param name="filePath">日志文件的保存路径</param>
            <param name="fileMaxSize">每个日志文件的最大大小，默认2M</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetExistLogFileNames">
            <summary>
            返回所有的日志文件名称，返回一个列表<br />
            Returns all log file names, returns a list
            </summary>
            <returns>所有的日志文件信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetLastAccessFileName">
            <summary>
            获取之前保存的日志文件，如果文件大小超过了设定值，将会生成新的文件名称<br />
            Obtain the previously saved log file. If the file size exceeds the set value, a new file name will be generated
            </summary>
            <returns>文件名称</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.GetDefaultFileName">
            <summary>
            获取一个新的默认的文件名称<br />
            Get a new default file name
            </summary>
            <returns>完整的文件名</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetFileSize.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetSingle">
            <summary>
            单日志文件对象，所有的日志信息的记录都会写入一个文件里面去。文件名指定为空的时候，自动不存储文件。<br />
            Single log file object, all log information records will be written to a file. When the file name is specified as empty, the file is not stored automatically.
            </summary>
            <remarks>
            此日志实例化需要指定一个完整的文件路径，当需要记录日志的时候调用方法，会使得日志越来越大，对于写入的性能没有太大影响，但是会影响文件读取。
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="基本的使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example5" title="所有日志不存储" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example6" title="仅存储ERROR等级" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example7" title="不指定路径" />
            </example>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.#ctor(System.String)">
            <summary>
            实例化一个单文件日志的对象，如果日志的路径为空，那么就不存储数据，只触发<see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/>事件<br />
            Instantiate a single file log object. If the log path is empty, then no data is stored and only the <see cref="E:HslCommunication.LogNet.LogNetBase.BeforeSaveToFile"/> event is triggered.
            </summary>
            <param name="filePath">文件的路径</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.ClearLog">
            <summary>
            单日志文件允许清空日志内容<br />
            Single log file allows clearing log contents
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetAllSavedLog">
            <summary>
            获取单日志文件的所有保存记录<br />
            Get all saved records of a single log file
            </summary>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetExistLogFileNames">
            <summary>
            获取所有的日志文件数组，对于单日志文件来说就只有一个<br />
            Get all log file arrays, only one for a single log file
            </summary>
            <returns>字符串数组，包含了所有的存在的日志数据</returns>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.GetFileSaveName">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetSingle.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.LogNet.FormLogNetView">
            <summary>
            日志查看器的窗口类，用于分析统计日志数据
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.#ctor">
            <summary>
            实例化一个日志查看器的窗口
            </summary>
        </member>
        <member name="F:HslCommunication.LogNet.FormLogNetView.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:HslCommunication.LogNet.FormLogNetView.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HslCommunication.LogNet.LogNetAnalysisControl">
            <summary>
            一个用于日志分析的控件
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.#ctor">
            <summary>
            实例化一个控件信息
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.SetLogNetSource(System.String)">
            <summary>
            设置日志的数据源
            </summary>
            <param name="logSource">直接从日志文件中读到的数据或是来自网络的数据</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.FilterLogSource(System.String)">
            <summary>
            从现有的日志中筛选数据
            </summary>
            <param name="degree"></param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.AnalysisLogSource(System.DateTime,System.DateTime,System.String)">
            <summary>
            底层的数据分析筛选
            </summary>
            <param name="start"></param>
            <param name="end"></param>
            <param name="degree"></param>
        </member>
        <member name="F:HslCommunication.LogNet.LogNetAnalysisControl.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:HslCommunication.LogNet.LogNetAnalysisControl.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要修改
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusAscii">
            <summary>
            Modbus-Ascii通讯协议的类库，基于rtu类库完善过来，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            The client communication class of Modbus-Ascii protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="remarks"/>
            </remarks>
            <example>
            基本的用法请参照下面的代码示例，初始化部分的代码省略
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="Example" title="Modbus示例" />
            复杂的读取数据的代码示例如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="ReadExample" title="read示例" />
            写入数据的代码如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusAsciiExample.cs" region="WriteExample" title="write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.#ctor">
            <summary>
            实例化一个Modbus-ascii协议的客户端对象<br />
            Instantiate a client object of the Modbus-ascii protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.#ctor(System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.#ctor(System.Byte)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.CheckModbusTcpResponse(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusAscii.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusInfo">
            <summary>
            Modbus协议相关的一些信息，包括功能码定义，报文的生成的定义等等信息<br />
            Some information related to Modbus protocol, including function code definition, definition of message generation, etc.
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadCoil">
            <summary>
            读取线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadDiscrete">
            <summary>
            读取离散量
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadRegister">
            <summary>
            读取寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.ReadInputRegister">
            <summary>
            读取输入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteOneCoil">
            <summary>
            写单个线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteOneRegister">
            <summary>
            写单个寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteCoil">
            <summary>
            写多个线圈
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteRegister">
            <summary>
            写多个寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.WriteMaskRegister">
            <summary>
            使用掩码的方式写入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeNotSupport">
            <summary>
            不支持该功能码
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeOverBound">
            <summary>
            该地址越界
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeQuantityOver">
            <summary>
            读取长度超过最大值
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.ModbusInfo.FunctionCodeReadWriteException">
            <summary>
            读写异常
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildReadModbusCommand(System.String,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus读取数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码应该根据bool或是字来区分<br />
            To construct the core message of Modbus reading data, you need to specify the address, length, station number, 
            whether the starting address is 0, and the default function code should be distinguished according to bool or word
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="length">读取的数据长度</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildReadModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            构建Modbus读取数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码应该根据bool或是字来区分<br />
            To construct the core message of Modbus reading data, you need to specify the address, length, station number, 
            whether the starting address is 0, and the default function code should be distinguished according to bool or word
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="length">读取的数据长度</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(System.String,System.Boolean[],System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length,
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(System.String,System.Boolean,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length, station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">bool的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Boolean[])">
            <summary>
            构建Modbus写入bool数组的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to the bool array, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteBoolModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Boolean)">
            <summary>
            构建Modbus写入bool数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message that Modbus writes to bool data, you need to specify the address, length, station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">bool数据的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.Byte[],System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.Int16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">short数据信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(System.String,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="value">bool数组的信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteMaskModbusCommand(System.String,System.UInt16,System.UInt16,System.Byte,System.Boolean,System.Byte)">
            <summary>
            构建Modbus写入掩码的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the Modbus write mask core message, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="address">Modbus的富文本地址</param>
            <param name="andMask">进行与操作的掩码信息</param>
            <param name="orMask">进行或操作的掩码信息</param>
            <param name="station">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteWordModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Byte[])">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="values">bool数组的信息</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteMaskModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16,System.UInt16)">
            <summary>
            构建Modbus写入掩码数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing mask data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="andMask">等待进行与操作的掩码</param>
            <param name="orMask">等待进行或操作的掩码</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteOneRegisterModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.Int16)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">short的值</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.BuildWriteOneRegisterModbusCommand(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            构建Modbus写入字数据的核心报文，需要指定地址，长度，站号，是否起始地址0，默认的功能码<br />
            To construct the core message of Modbus writing word data, you need to specify the address, length, 
            station number, whether the starting address is 0, and the default function code
            </summary>
            <param name="mAddress">Modbus的富文本地址</param>
            <param name="value">ushort的值</param>
            <returns>包含最终命令的结果对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExtractActualData(System.Byte[])">
            <summary>
            从返回的modbus的书内容中，提取出真实的数据，适用于写入和读取操作<br />
            Extract real data from the content of the returned modbus book, suitable for writing and reading operations
            </summary>
            <param name="response">返回的核心modbus报文信息</param>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.PackCommandToTcp(System.Byte[],System.UInt16)">
            <summary>
            将modbus指令打包成Modbus-Tcp指令，需要指定ID信息来添加6个字节的报文头<br />
            Pack the Modbus command into Modbus-Tcp command, you need to specify the ID information to add a 6-byte message header
            </summary>
            <param name="modbus">Modbus核心指令</param>
            <param name="id">消息的序号</param>
            <returns>Modbus-Tcp指令</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExplodeTcpCommandToCore(System.Byte[])">
            <summary>
            将modbus-tcp的报文数据重新还原成modbus指令，移除6个字节的报文头数据<br />
            Re-modify the message data of modbus-tcp into the modbus command, remove the 6-byte message header data
            </summary>
            <param name="modbusTcp">modbus-tcp的报文</param>
            <returns>modbus数据报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.ExplodeRtuCommandToCore(System.Byte[])">
            <summary>
            将modbus-rtu的数据重新还原成modbus数据，移除CRC校验的内容<br />
            Restore the data of modbus-rtu to modbus data again, remove the content of CRC check
            </summary>
            <param name="modbusRtu">modbus-rtu的报文</param>
            <returns>modbus数据报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.PackCommandToRtu(System.Byte[])">
            <summary>
            将modbus指令打包成Modbus-Rtu指令，在报文的末尾添加CRC16的校验码<br />
            Pack the modbus instruction into Modbus-Rtu instruction, add CRC16 check code at the end of the message
            </summary>
            <param name="modbus">Modbus指令</param>
            <returns>Modbus-Rtu指令</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.TransModbusCoreToAsciiPackCommand(System.Byte[])">
            <summary>
            将一个modbus核心的数据报文，转换成modbus-ascii的数据报文，增加LRC校验，增加首尾标记数据<br />
            Convert a Modbus core data message into a Modbus-ascii data message, add LRC check, and add head and tail tag data
            </summary>
            <param name="modbus">modbus-rtu的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus-ascii的报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.TransAsciiPackCommandToCore(System.Byte[])">
            <summary>
            将一个modbus-ascii的数据报文，转换成的modbus核心数据报文，移除首尾标记，移除LRC校验<br />
            Convert a Modbus-ascii data message into a Modbus core data message, remove the first and last tags, and remove the LRC check
            </summary>
            <param name="modbusAscii">modbus-ascii的完整报文，携带相关的校验码</param>
            <returns>可以用于直接发送的modbus的报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.AnalysisAddress(System.String,System.Byte,System.Boolean,System.Byte)">
            <summary>
            分析Modbus协议的地址信息，该地址适应于tcp及rtu模式<br />
            Analysis of the address information of Modbus protocol, the address is adapted to tcp and rtu mode
            </summary>
            <param name="address">带格式的地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="defaultStation">默认的站号信息</param>
            <param name="isStartWithZero">起始地址是否从0开始</param>
            <param name="defaultFunction">默认的功能码信息</param>
            <returns>转换后的地址信息</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusInfo.GetDescriptionByErrorCode(System.Byte)">
            <summary>
            通过错误码来获取到对应的文本消息<br />
            Get the corresponding text message through the error code
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="T:HslCommunication.ModBus.ModBusMonitorAddress">
            <summary>
            服务器端提供的数据监视服务
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.ModBusMonitorAddress.Address">
            <summary>
            本次数据监视的地址
            </summary>
        </member>
        <member name="E:HslCommunication.ModBus.ModBusMonitorAddress.OnWrite">
            <summary>
            数据写入时触发的事件
            </summary>
        </member>
        <member name="E:HslCommunication.ModBus.ModBusMonitorAddress.OnChange">
            <summary>
            数据改变时触发的事件
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModBusMonitorAddress.SetValue(System.Int16)">
            <summary>
            强制设置触发事件
            </summary>
            <param name="value">数据值信息</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModBusMonitorAddress.SetChangeValue(System.Int16,System.Int16)">
            <summary>
            强制设置触发值变更事件
            </summary>
            <param name="before">变更前的值</param>
            <param name="after">变更后的值</param>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusRtu">
            <summary>
            Modbus-Rtu通讯协议的类库，多项式码0xA001，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            Modbus-Rtu communication protocol class library, polynomial code 0xA001, supports standard function codes, 
            and also supports extended function code implementation. The address is in rich text. For details, see the remark
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="remarks"/>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.#ctor">
            <summary>
            实例化一个Modbus-Rtu协议的客户端对象<br />
            Instantiate a client object of the Modbus-Rtu protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtu.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.CheckModbusTcpResponse(System.Byte[])">
            <summary>
            检查当前的Modbus-Rtu响应是否是正确的<br />
            Check if the current Modbus-Rtu response is correct
            </summary>
            <param name="send">发送的数据信息</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtu.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusRtuOverTcp">
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusRtu"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.#ctor"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusRtuOverTcp.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.CheckModbusTcpResponse(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusRtu.CheckModbusTcpResponse(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusRtuOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusTcpNet">
            <summary>
            Modbus-Tcp协议的客户端通讯类，方便的和服务器进行数据交互，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            The client communication class of Modbus-Tcp protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            本客户端支持的标准的modbus协议，Modbus-Tcp及Modbus-Udp内置的消息号会进行自增，比如我们想要控制消息号在0-1000之间自增，不能超过一千，可以写如下的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Sample1" title="序号示例" />
            <note type="important">
            地址共可以携带3个信息，最完整的表示方式"s=2;x=3;100"，对应的modbus报文是 02 03 00 64 00 01 的前四个字节，站号，功能码，起始地址，下面举例
            </note>
            <list type="definition">
            <item>
                <term>读取线圈</term>
                <description>ReadCoil("100")表示读取线圈100的值，ReadCoil("s=2;100")表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>读取离散输入</term>
                <description>ReadDiscrete("100")表示读取离散输入100的值，ReadDiscrete("s=2;100")表示读取站号为2，离散地址为100的值</description>
            </item>
            <item>
                <term>读取寄存器</term>
                <description>ReadInt16("100")表示读取寄存器100的值，ReadInt16("s=2;100")表示读取站号为2，寄存器100的值</description>
            </item>
            <item>
                <term>读取输入寄存器</term>
                <description>ReadInt16("x=4;100")表示读取输入寄存器100的值，ReadInt16("s=2;x=4;100")表示读取站号为2，输入寄存器100的值</description>
            </item>
            </list>
            对于写入来说也是一致的
            <list type="definition">
            <item>
                <term>写入线圈</term>
                <description>WriteCoil("100",true)表示读取线圈100的值，WriteCoil("s=2;100",true)表示读取站号为2，线圈地址为100的值</description>
            </item>
            <item>
                <term>写入寄存器</term>
                <description>Write("100",(short)123)表示写寄存器100的值123，Write("s=2;100",(short)123)表示写入站号为2，寄存器100的值123</description>
            </item>
            </list>
            特殊说明部分：
             <list type="definition">
            <item>
                <term>01功能码</term>
                <description>ReadBool("100")</description>
            </item>
            <item>
                <term>02功能码</term>
                <description>ReadBool("x=2;100")</description>
            </item>
            <item>
                <term>03功能码</term>
                <description>Read("100")</description>
            </item>
            <item>
                <term>04功能码</term>
                <description>Read("x=4;100")</description>
            </item>
            <item>
                <term>05功能码</term>
                <description>Write("100", True)</description>
            </item>
            <item>
                <term>06功能码</term>
                <description>Write("100", (short)100);Write("100", (ushort)100)</description>
            </item>
            <item>
                <term>0F功能码</term>
                <description>Write("100", new bool[]{True})</description>
            </item>
            <item>
                <term>10功能码</term>
                <description>写入寄存器的方法出去上述06功能码的示例，如果写一个short想用10功能码：Write("100", new short[]{100})</description>
            </item>
            </list>
            </remarks>
            <example>
            基本的用法请参照下面的代码示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="Example1" title="Modbus示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.#ctor">
            <summary>
            实例化一个Modbus-Tcp协议的客户端对象<br />
            Instantiate a client object of the Modbus-Tcp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero">
            <summary>
            获取或设置起始的地址是否从0开始，默认为True<br />
            Gets or sets whether the starting address starts from 0. The default is True
            </summary>
            <remarks>
            <note type="warning">因为有些设备的起始地址是从1开始的，就要设置本属性为<c>False</c></note>
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.Station">
            <summary>
            获取或者重新修改服务器的默认站号信息，当然，你可以再读写的时候动态指定，参见备注<br />
            Get or modify the default station number information of the server. Of course, you can specify it dynamically when reading and writing, see note
            </summary>
            <remarks>
            当你调用 ReadCoil("100") 时，对应的站号就是本属性的值，当你调用 ReadCoil("s=2;100") 时，就忽略本属性的值，读写寄存器的时候同理
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.ByteTransformBase.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse">
            <summary>
            字符串数据是否按照字来反转，默认为False<br />
            Whether the string data is reversed according to words. The default is False.
            </summary>
            <remarks>
            字符串按照2个字节的排列进行颠倒，根据实际情况进行设置
            </remarks>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpNet.MessageId">
            <summary>
            获取modbus协议自增的消息号，你可以自定义modbus的消息号的规则，详细参见<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/>说明，也可以查找<see cref="T:HslCommunication.BasicFramework.SoftIncrementCount"/>说明。<br />
            Get the message number incremented by the modbus protocol. You can customize the rules of the message number of the modbus. For details, please refer to the description of <see cref = "T:HslCommunication.ModBus.ModbusTcpNet" />, or you can find the description of <see cref = "T:HslCommunication.BasicFramework.SoftIncrementCount" />
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)">
            <summary>
            读取线圈，需要指定起始地址，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            To read the coil, you need to specify the start address. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量的读取线圈，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            For batch reading coils, you need to specify the start address and read length. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)">
            <summary>
            读取输入线圈，需要指定起始地址，如果富文本地址不指定，默认使用的功能码是 0x02<br />
            To read the input coil, you need to specify the start address. If the rich text address is not specified, the default function code is 0x02.
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <returns>带有成功标志的bool对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量的读取输入点，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x02<br />
            To read input points in batches, you need to specify the start address and read length. If the rich text address is not specified, the default function code is 0x02
            </summary>
            <param name="address">起始地址，格式为"1234"</param>
            <param name="length">读取长度</param>
            <returns>带有成功标志的bool数组对象</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)">
            <summary>
            从Modbus服务器批量读取寄存器的信息，需要指定起始地址，读取长度，如果富文本地址不指定，默认使用的功能码是 0x03，如果需要使用04功能码，那么地址就写成 x=4;100<br />
            To read the register information from the Modbus server in batches, you need to specify the start address and read length. If the rich text address is not specified, 
            the default function code is 0x03. If you need to use the 04 function code, the address is written as x = 4; 100
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="length">读取的数量</param>
            <returns>带有成功标志的字节信息</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量读取的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <summary>
            读取服务器的数据，需要指定不同的功能码
            </summary>
            <param name="address">地址</param>
            <param name="length">长度</param>
            <returns>带是否成功的结果数据</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到Modbus的寄存器上去，需要指定起始地址和数据内容，如果富文本地址不指定，默认使用的功能码是 0x10<br />
            To write data to Modbus registers, you need to specify the start address and data content. If the rich text address is not specified, the default function code is 0x10
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的数据，长度根据data的长度来指示</param>
            <returns>返回写入结果</returns>
            <remarks>
            富地址格式，支持携带站号信息，功能码信息，具体参照类的示例代码
            </remarks>
            <example>
            此处演示批量写入的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\Modbus.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)">
            <summary>
            将数据写入到Modbus的单个寄存器上去，需要指定起始地址和数据值，如果富文本地址不指定，默认使用的功能码是 0x06<br />
            To write data to a single register of Modbus, you need to specify the start address and data value. If the rich text address is not specified, the default function code is 0x06.
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的short数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)">
            <summary>
            将数据写入到Modbus的单个寄存器上去，需要指定起始地址和数据值，如果富文本地址不指定，默认使用的功能码是 0x06<br />
            To write data to a single register of Modbus, you need to specify the start address and data value. If the rich text address is not specified, the default function code is 0x06.
            </summary>
            <param name="address">起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="value">写入的ushort数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)">
            <summary>
            向设备写入掩码数据，使用0x16功能码，需要确认对方是否支持相关的操作，掩码数据的操作主要针对寄存器。<br />
            To write mask data to the server, using the 0x16 function code, you need to confirm whether the other party supports related operations. 
            The operation of mask data is mainly directed to the register.
            </summary>
            <param name="address">起始地址，起始地址，比如"100"，"x=4;100"，"s=1;100","s=1;x=4;100"</param>
            <param name="andMask">等待与操作的掩码数据</param>
            <param name="orMask">等待或操作的掩码数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取线圈或是离散的数据信息，需要指定地址和长度，具体的结果取决于实现，如果富文本地址不指定，默认使用的功能码是 0x01<br />
            To read coils or discrete data in batches, you need to specify the address and length. The specific result depends on the implementation. If the rich text address is not specified, the default function code is 0x01.
            </summary>
            <param name="address">数据地址，比如 "1234" </param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的bool[]数组</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])">
            <summary>
            向线圈中写入bool数组，返回是否写入成功，如果富文本地址不指定，默认使用的功能码是 0x0F<br />
            Write the bool array to the coil, and return whether the writing is successful. If the rich text address is not specified, the default function code is 0x0F.
            </summary>
            <param name="address">要写入的数据地址，比如"1234"</param>
            <param name="values">要写入的实际数组</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)">
            <summary>
            向线圈中写入bool数值，返回是否写入成功，如果富文本地址不指定，默认使用的功能码是 0x05<br />
            Write bool value to the coil and return whether the writing is successful. If the rich text address is not specified, the default function code is 0x05.
            </summary>
            <param name="address">要写入的数据地址，比如"12345"</param>
            <param name="value">要写入的实际数据</param>
            <returns>返回写入结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusTcpServer">
            <summary>
            Modbus的虚拟服务器，同时支持Tcp和Rtu的机制，支持线圈，离散输入，寄存器和输入寄存器的读写操作，可以用来当做系统的数据交换池
            </summary>
            <remarks>
            可以基于本类实现一个功能复杂的modbus服务器，在传统的.NET版本里，还支持modbus-rtu指令的收发，.NET Standard版本服务器不支持rtu操作。服务器支持的数据池如下：
            <list type="number">
            <item>线圈，功能码对应01，05，15</item>
            <item>离散输入，功能码对应02</item>
            <item>寄存器，功能码对应03，06，16</item>
            <item>输入寄存器，功能码对应04，输入寄存器在服务器端可以实现读写的操作</item>
            </list>
            </remarks>
            <example>
            读写的地址格式为富文本地址，具体请参照下面的示例代码。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Modbus\ModbusTcpServer.cs" region="ModbusTcpServerExample" title="ModbusTcpServer示例" />
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.#ctor">
            <summary>
            实例化一个Modbus Tcp及Rtu的服务器，支持数据读写操作
            </summary>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusTcpServer.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadCoil(System.String)">
            <summary>
            读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadCoil(System.String,System.UInt16)">
            <summary>
            批量读取地址的线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean)">
            <summary>
            写入线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteCoil(System.String,System.Boolean[])">
            <summary>
            写入线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDiscrete(System.String)">
            <summary>
            读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadDiscrete(System.String,System.UInt16)">
            <summary>
            批量读取地址的离散线圈的通断情况
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="length">读取长度</param>
            <returns><c>True</c>或是<c>False</c></returns>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean)">
            <summary>
            写入离散线圈的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.WriteDiscrete(System.String,System.Boolean[])">
            <summary>
            写入离散线圈数组的通断值
            </summary>
            <param name="address">起始地址，示例："100"</param>
            <param name="data">是否通断</param>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Write(System.String,System.Byte,System.Byte)">
            <summary>
            写入寄存器数据，指定字节数据
            </summary>
            <param name="address">起始地址，示例："100"，如果是输入寄存器："x=4;100"</param>
            <param name="high">高位数据</param>
            <param name="low">地位数据</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateExceptionBack(System.Byte[],System.Byte)">
            <summary>
            创建特殊的功能标识，然后返回该信息<br />
            Create a special feature ID and return this information
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="error">错误码</param>
            <returns>携带错误码的modbus报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateReadBack(System.Byte[],System.Byte[])">
            <summary>
            创建返回消息<br />
            Create return message
            </summary>
            <param name="modbusCore">modbus核心报文</param>
            <param name="content">返回的实际数据内容</param>
            <returns>携带内容的modbus报文</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CreateWriteBack(System.Byte[])">
            <summary>
            创建写入成功的反馈信号<br />
            Create feedback signal for successful write
            </summary>
            <param name="modbus">modbus核心报文</param>
            <returns>携带成功写入的信息</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.AddSubcription(HslCommunication.ModBus.ModBusMonitorAddress)">
            <summary>
            新增一个数据监视的任务，针对的是寄存器地址的数据<br />
            Added a data monitoring task for data at register addresses
            </summary>
            <param name="monitor">监视地址对象</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.RemoveSubcrption(HslCommunication.ModBus.ModBusMonitorAddress)">
            <summary>
            移除一个数据监视的任务<br />
            Remove a data monitoring task
            </summary>
            <param name="monitor">监视地址对象</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.OnRegisterBeforWrite(System.UInt16,System.Int16,System.Int16)">
            <summary>
            在数据变更后，进行触发是否产生订阅<br />
            Whether to generate a subscription after triggering data changes
            </summary>
            <param name="address">数据地址</param>
            <param name="before">修改之前的数</param>
            <param name="after">修改之后的数</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CheckModbusMessageLegal(System.Byte[])">
            <summary>
            检测当前的Modbus接收的指定是否是合法的<br />
            Check if the current Modbus received designation is valid
            </summary>
            <param name="buffer">缓存数据</param>
            <returns>是否合格</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ReadFromModbusCore(System.Byte[])">
            <summary>
            Modbus核心数据交互方法，允许重写自己来实现，报文只剩下核心的Modbus信息，去除了MPAB报头信息<br />
            The Modbus core data interaction method allows you to rewrite it to achieve the message. 
            Only the core Modbus information is left in the message, and the MPAB header information is removed.
            </summary>
            <param name="modbusCore">核心的Modbus报文</param>
            <returns>进行数据交互之后的结果</returns>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.StartModbusRtu(System.String)">
            <summary>
            启动modbus-rtu的从机服务，使用默认的参数进行初始化串口，9600波特率，8位数据位，无奇偶校验，1位停止位<br />
            Start the slave service of modbus-rtu, initialize the serial port with default parameters, 9600 baud rate, 8 data bits, no parity, 1 stop bit
            </summary>
            <param name="com">串口信息</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.StartModbusRtu(System.String,System.Int32)">
            <summary>
            启动modbus-rtu的从机服务，使用默认的参数进行初始化串口，8位数据位，无奇偶校验，1位停止位<br />
            Start the slave service of modbus-rtu, initialize the serial port with default parameters, 8 data bits, no parity, 1 stop bit
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.StartModbusRtu(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            启动modbus-rtu的从机服务，使用自定义的初始化方法初始化串口的参数<br />
            Start the slave service of modbus-rtu and initialize the parameters of the serial port using a custom initialization method
            </summary>
            <param name="inni">初始化信息的委托</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.CloseModbusRtu">
            <summary>
            关闭modbus-rtu的串口对象<br />
            Close the serial port object of modbus-rtu
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.SerialPort_DataReceived(System.Object,System.IO.Ports.SerialDataReceivedEventArgs)">
            <summary>
            接收到串口数据的时候触发
            </summary>
            <param name="sender">串口对象</param>
            <param name="e">消息</param>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.ModbusUdpNet">
            <summary>
            Modbus-Udp协议的客户端通讯类，方便的和服务器进行数据交互，支持标准的功能码，也支持扩展的功能码实现，地址采用富文本的形式，详细见备注说明<br />
            The client communication class of Modbus-Udp protocol is convenient for data interaction with the server. It supports standard function codes and also supports extended function codes. 
            The address is in rich text. For details, see the remarks.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="remarks"/>
            </remarks>
            <example>
            <inheritdoc cref="T:HslCommunication.ModBus.ModbusTcpNet" path="example"/>
            </example>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.#ctor">
            <summary>
            实例化一个MOdbus-Udp协议的客户端对象<br />
            Instantiate a client object of the MOdbus-Udp protocol
            </summary>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.#ctor(System.String,System.Int32,System.Byte)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.#ctor(System.String,System.Int32,System.Byte)"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.AddressStartWithZero">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.AddressStartWithZero"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.Station">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.Station"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.DataFormat">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.DataFormat"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.IsStringReverse">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.IsStringReverse"/>
        </member>
        <member name="P:HslCommunication.ModBus.ModbusUdpNet.MessageId">
            <inheritdoc cref="P:HslCommunication.ModBus.ModbusTcpNet.MessageId"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadDiscrete(System.String)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusUdpNet.ReadDiscrete(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadModBus(HslCommunication.Core.Address.ModbusAddress,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteMask(System.String,System.UInt16,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteMask(System.String,System.UInt16,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegister(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.WriteOneRegister(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.WriteOneRegister(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.ModBus.ModbusTcpNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.ModBus.ModbusUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.ModBus.MonitorAddress">
            <summary>
            监视使用的数据缓存
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.ValueOrigin">
            <summary>
            原有的值
            </summary>
        </member>
        <member name="F:HslCommunication.ModBus.MonitorAddress.ValueNew">
            <summary>
            新的值
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttApplicationMessage">
            <summary>
            Mqtt的一次完整消息内容，包含主题，负载数据，消息等级。<br />
            Mqtt's complete message content, including subject, payload data, message level.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.QualityOfServiceLevel">
            <summary>
            这个字段表示应用消息分发的服务质量等级保证。分为，最多一次，最少一次，正好一次，只发不推送。<br />
            This field indicates the quality of service level guarantee for application message distribution. Divided into, at most once, at least once, exactly once
            </summary>
            <remarks>
            在实际的开发中的情况下，最多一次是最省性能的，正好一次是最消耗性能的，如果应有场景为推送实时的数据，那么，最多一次的性能是最高的
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Topic">
            <summary>
            主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。<br />
            The Topic Name is used to identify which information channel the payload data should be published to.
            </summary>
            <remarks>
            UTF-8编码字符串中的字符数据必须是按照Unicode规范 [Unicode] 定义的和在RFC3629 [RFC3629] 中重申的有效的UTF-8格式。特别需要指出的是，
            这些数据不能包含字符码在U+D800和U+DFFF之间的数据。如果服务端或客户端收到了一个包含无效UTF-8字符的控制报文，它必须关闭网络连接 [MQTT-1.5.3-1].
            
            PUBLISH报文中的主题名不能包含通配符 [MQTT-3.3.2-2]。
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Payload">
            <summary>
            有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。<br />
            The payload contains application messages to be published. The content and format of the data is application specific.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttApplicationMessage.Retain">
            <summary>
            该消息是否在服务器端进行保留，详细的说明参照文档的备注<br />
            Whether the message is retained on the server. For details, refer to the remarks of the document.
            </summary>
            <remarks>
            如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端必须存储这个应用消息和它的服务质量等级（QoS），
            以便它可以被分发给未来的主题名匹配的订阅者 [MQTT-3.3.1-5]。一个新的订阅建立时，对每个匹配的主题名
            ，如果存在最近保留的消息，它必须被发送给这个订阅者 [MQTT-3.3.1-6]。如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，
            它必须丢弃之前为那个主题保留的任何消息。它应该将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都可以选择丢弃它 — 如果这种情况发生了，
            那个主题将没有保留消息 [MQTT-3.3.1-7]
            </remarks>
        </member>
        <member name="M:HslCommunication.MQTT.MqttApplicationMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient">
            <summary>
            Mqtt协议的客户端实现，支持订阅消息，发布消息，详细的使用例子参考api文档<br />
            The client implementation of the Mqtt protocol supports subscription messages and publishing messages. For detailed usage examples, refer to the api documentation. 
            </summary>
            <remarks>
            这是一个MQTT的客户端实现，参照MQTT协议的3.1.1版本设计实现的。服务器可以是其他的组件提供的，其他的可以参考示例<br />
            This is an MQTT client implementation, designed and implemented with reference to version 3.1.1 of the MQTT protocol. The server can be provided by other components.
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test2" title="带用户名密码的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test3" title="连接示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test4" title="发布示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test5" title="订阅示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test8" title="网络重连示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            实例化一个默认的对象
            </summary>
            <param name="options">配置信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectServer">
            <summary>
            连接服务器，如果连接失败，请稍候重试。<br />
            Connect to the server. If the connection fails, try again later.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.PublishMessage(HslCommunication.MQTT.MqttApplicationMessage)">
            <summary>
            发布一个MQTT协议的消息到服务器。该消息包含主题，负载数据，消息等级，是否保留信息。<br />
            Publish an MQTT protocol message to the server. The message contains the subject, payload data, message level, and whether to retain information.
            </summary>
            <param name="message">消息</param>
            <returns>发布结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test4" title="发布示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String)">
            <summary>
            从服务器订阅一个或多个主题信息<br />
            Subscribe to one or more topics from the server
            </summary>
            <param name="topic">主题信息</param>
            <returns>订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test5" title="订阅示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String[])">
            <inheritdoc cref="M:HslCommunication.MQTT.MqttClient.SubscribeMessage(System.String)"/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String[])">
            <summary>
            取消订阅多个主题信息，取消之后，当前的订阅数据就不在接收到，除非服务器强制推送。<br />
            Unsubscribe from multiple topic information. After cancellation, the current subscription data will not be received unless the server forces it to push it.
            </summary>
            <param name="topics">主题信息</param>
            <returns>取消订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test7" title="订阅示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.UnSubscribeMessage(System.String)">
            <summary>
            取消订阅置顶的主题信息
            </summary>
            <param name="topic">主题信息</param>
            <returns>取消订阅结果</returns>
            <example>
            参照 <see cref="T:HslCommunication.MQTT.MqttClient"/> 的示例说明。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MQTTClient.cs" region="Test7" title="订阅示例" />
            </example>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient.MqttMessageReceiveDelegate">
            <summary>
            当接收到Mqtt订阅的信息的时候触发<br />
            Triggered when receiving Mqtt subscription information
            </summary>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnMqttMessageReceived">
            <summary>
            当接收到Mqtt订阅的信息的时候触发
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttClientApplicationMessage">
            <summary>
            来自客户端的一次消息的内容，当前类主要是在MQTT的服务端进行使用<br />
            The content of a message from the client. The current class is mainly used on the MQTT server
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttClientApplicationMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.ClientId">
            <summary>
            客户端的Id信息<br />
            Client Id information
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.UserName">
            <summary>
            当前的客户端的用户名<br />
            Username of the current client
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.IsCancelPublish">
            <summary>
            获取或设置当前的消息是否取消发布，默认False，也就是发布出去<br />
            Get or set whether the current message is unpublished, the default is False, which means it is published
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttClientApplicationMessage.CreateTime">
            <summary>
            当前消息的生成时间<br />
            The generation time of the current message
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttConnectionOptions">
            <summary>
            连接MQTT服务器的一些参数信息，适用<see cref="T:HslCommunication.MQTT.MqttClient"/>消息发布订阅客户端以及<see cref="T:HslCommunication.MQTT.MqttSyncClient"/>同步请求客户端。<br />
            Some parameter information for connecting to the MQTT server is applicable to the <see cref="T:HslCommunication.MQTT.MqttClient"/> message publishing and subscription client and the <see cref="T:HslCommunication.MQTT.MqttSyncClient"/> synchronization request client.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttConnectionOptions.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.IpAddress">
            <summary>
            Mqtt服务器的ip地址<br />
            IP address of Mqtt server
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.Port">
            <summary>
            端口号。默认1883<br />
            The port number. Default 1883
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.ClientId">
            <summary>
            客户端的id的标识<br />
            ID of the client
            </summary>
            <remarks>
            实际在传输的时候，采用的是UTF8编码的方式来实现。
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.ConnectTimeout">
            <summary>
            连接到服务器的超时时间，默认是5秒，单位是毫秒<br />
            The timeout period for connecting to the server, the default is 5 seconds, the unit is milliseconds
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.Credentials">
            <summary>
            登录服务器的凭证，包含用户名和密码，可以为空<br />
            The credentials for logging in to the server, including the username and password, can be null
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.KeepAlivePeriod">
            <summary>
            设置的参数，最小单位为1s，当超过设置的时间间隔没有发送数据的时候，必须发送PINGREQ报文，否则服务器认定为掉线。<br />
            The minimum unit of the set parameter is 1s. When no data is sent beyond the set time interval, the PINGREQ message must be sent, otherwise the server considers it to be offline.
            </summary>
            <remarks>
            保持连接（Keep Alive）是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，
            两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，
            客户端必须发送一个PINGREQ报文，详细参见 [MQTT-3.1.2-23]
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.KeepAliveSendInterval">
            <summary>
            获取或是设置心跳时间的发送间隔。默认30秒钟<br />
            Get or set the heartbeat time interval. 30 seconds by default
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttConnectionOptions.CleanSession">
            <summary>
            是否清理会话，如果清理会话（CleanSession）标志被设置为1，客户端和服务端必须丢弃之前的任何会话并开始一个新的会话。
            会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据不能被任何之后的会话重用 [MQTT-3.1.2-6]。默认为清理会话。<br />
            Whether to clean the session. If the CleanSession flag is set to 1, the client and server must discard any previous session and start a new session. 
            The session only lasts as long as the network connection. The state data associated with this session cannot be reused by any subsequent sessions [MQTT-3.1.2-6]. 
            The default is to clean up the session.
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttControlMessage">
            <summary>
            定义了Mqtt的相关的控制报文的信息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.CONNECT">
            <summary>
            连接标识
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.CONNACK">
            <summary>
            连接返回的标识
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBLISH">
            <summary>
            发布消息
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBACK">
            <summary>
            QoS 1消息发布收到确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBREC">
            <summary>
            发布收到（保证交付第一步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBREL">
            <summary>
            发布释放（保证交付第二步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PUBCOMP">
            <summary>
            QoS 2消息发布完成（保证交互第三步）
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.SUBSCRIBE">
            <summary>
            客户端订阅请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.SUBACK">
            <summary>
            订阅请求报文确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.UNSUBSCRIBE">
            <summary>
            客户端取消订阅请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.UNSUBACK">
            <summary>
            取消订阅报文确认
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PINGREQ">
            <summary>
            心跳请求
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.PINGRESP">
            <summary>
            心跳响应
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.DISCONNECT">
            <summary>
            客户端断开连接
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttControlMessage.REPORTPROGRESS">
            <summary>
            报告进度
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttCredential">
            <summary>
            Mqtt协议的验证对象，包含用户名和密码<br />
            Authentication object of Mqtt protocol, including username and password
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.#ctor(System.String,System.String)">
            <summary>
            实例化指定的用户名和密码的对象<br />
            Instantiates an object with the specified username and password
            </summary>
            <param name="name">用户名</param>
            <param name="pwd">密码</param>
        </member>
        <member name="P:HslCommunication.MQTT.MqttCredential.UserName">
            <summary>
            获取或设置用户名<br />
            Get or set username
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttCredential.Password">
            <summary>
            获取或设置密码<br />
            Get or set password
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttCredential.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttHelper">
            <summary>
            Mqtt协议的辅助类，提供了一些协议相关的基础方法，方便客户端和服务器端一起调用。<br />
            The auxiliary class of the Mqtt protocol provides some protocol-related basic methods for the client and server to call together.
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.CalculateLengthToMqttLength(System.Int32)">
            <summary>
            根据数据的总长度，计算出剩余的数据长度信息<br />
            According to the total length of the data, calculate the remaining data length information
            </summary>
            <param name="length">数据的总长度</param>
            <returns>计算结果</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildMqttCommand(System.Byte,System.Byte,System.Byte[],System.Byte[])">
            <summary>
            将一个数据打包成一个mqtt协议的内容<br />
            Pack a piece of data into a mqtt protocol
            </summary>
            <param name="control">控制码</param>
            <param name="flags">标记</param>
            <param name="variableHeader">可变头的字节内容</param>
            <param name="payLoad">负载数据</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildSegCommandByString(System.String)">
            <summary>
            将字符串打包成utf8编码，并且带有2个字节的表示长度的信息<br />
            Pack the string into utf8 encoding, and with 2 bytes of length information
            </summary>
            <param name="message">文本消息</param>
            <returns>打包之后的信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraMsgFromBytes(System.Byte[],System.Int32@)">
            <summary>
            从MQTT的缓存信息里，提取文本信息<br />
            Extract text information from MQTT cache information
            </summary>
            <param name="buffer">Mqtt的报文</param>
            <param name="index">索引</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraIntFromBytes(System.Byte[],System.Int32@)">
            <summary>
            从MQTT的缓存信息里，提取长度信息<br />
            Extract length information from MQTT cache information
            </summary>
            <param name="buffer">Mqtt的报文</param>
            <param name="index">索引</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildIntBytes(System.Int32)">
            <summary>
            从MQTT的缓存信息里，提取长度信息<br />
            Extract length information from MQTT cache information
            </summary>
            <param name="data">数据信息</param>
            <returns>值</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildConnectMqttCommand(HslCommunication.MQTT.MqttConnectionOptions,System.String)">
            <summary>
            创建MQTT连接服务器的报文信息<br />
            Create MQTT connection server message information
            </summary>
            <param name="connectionOptions">连接配置</param>
            <param name="protocol">协议的内容</param>
            <returns>返回是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.CheckConnectBack(System.Byte,System.Byte[])">
            <summary>
            根据服务器返回的信息判断当前的连接是否是可用的<br />
            According to the information returned by the server to determine whether the current connection is available
            </summary>
            <param name="code">功能码</param>
            <param name="data">数据内容</param>
            <returns>是否可用的连接</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.GetMqttCodeText(System.Int32)">
            <summary>
            获取当前的错误的描述信息<br />
            Get a description of the current error
            </summary>
            <param name="status">状态信息</param>
            <returns>描述信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildPublishMqttCommand(HslCommunication.MQTT.MqttPublishMessage)">
            <summary>
            创建Mqtt发送消息的命令<br />
            Create Mqtt command to send messages
            </summary>
            <param name="message">封装后的消息内容</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildPublishMqttCommand(System.String,System.Byte[])">
            <summary>
            创建Mqtt发送消息的命令<br />
            Create Mqtt command to send messages
            </summary>
            <param name="topic">主题消息内容</param>
            <param name="payload">数据负载</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildSubscribeMqttCommand(HslCommunication.MQTT.MqttSubscribeMessage)">
            <summary>
            创建Mqtt订阅消息的命令<br />
            Command to create Mqtt subscription message
            </summary>
            <param name="message">订阅的主题</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.BuildUnSubscribeMqttCommand(HslCommunication.MQTT.MqttSubscribeMessage)">
            <summary>
            创建Mqtt取消订阅消息的命令<br />
            Create Mqtt unsubscribe message command
            </summary>
            <param name="message">订阅的主题</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttHelper.ExtraMqttReceiveData(System.Byte,System.Byte[])">
            <summary>
            解析从MQTT接受的客户端信息，解析成实际的Topic数据及Payload数据<br />
            Parse the client information received from MQTT and parse it into actual Topic data and Payload data
            </summary>
            <param name="mqttCode">MQTT的命令码</param>
            <param name="data">接收的MQTT原始的消息内容</param>
            <returns>解析的数据结果信息</returns>
        </member>
        <member name="T:HslCommunication.MQTT.MqttPublishMessage">
            <summary>
            Mqtt发送的消息封装对象，是对 <see cref="T:HslCommunication.MQTT.MqttApplicationMessage"/> 对象的封装，添加了序号，还有是否重发的信息<br />
            The message encapsulation object sent by Mqtt is an encapsulation of the <see cref="T:HslCommunication.MQTT.MqttApplicationMessage"/> object, with the serial number added, and whether to retransmit
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttPublishMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.IsSendFirstTime">
            <summary>
            是否第一次发送数据信息<br />
            Whether to send data information for the first time
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.Identifier">
            <summary>
            当前的消息的标识符，当质量等级为0的时候，不需要重发以及考虑标识情况<br />
            The identifier of the current message, when the quality level is 0, do not need to retransmit and consider the identification situation
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttPublishMessage.Message">
            <summary>
            当前发布消息携带的mqtt的应用消息，包含主题，消息等级，负载。<br />
            The application message of mqtt carried in the current published message, including the subject, message level, and load.
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttQualityOfServiceLevel">
            <summary>
            Mqtt消息的质量等级<br />
            Mqtt message quality level
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.AtMostOnce">
            <summary>
            最多一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.AtLeastOnce">
            <summary>
            最少一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.ExactlyOnce">
            <summary>
            只有一次
            </summary>
        </member>
        <member name="F:HslCommunication.MQTT.MqttQualityOfServiceLevel.OnlyTransfer">
            <summary>
            消息只发送到服务器而不触发发布订阅，该消息质量等级只对HSL的MQTT服务器有效<br />
            The message is only sent to the server without triggering publish and subscribe, the message quality level is only valid for the HSL MQTT server
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer">
            <summary>
            一个Mqtt的服务器类对象，本服务器支持发布订阅操作，支持服务器从强制推送数据，指定客户端推送，支持同步网络访问的操作。从而定制化出自己的服务器，详细的使用说明可以参见代码api文档示例<br />
            An Mqtt server class object, this server supports publish and subscribe operations, supports the server to push data from the forced, specified client push, 
            and supports the operation of synchronous network access. In order to customize your own server, detailed instructions can be found in the code api documentation example
            </summary>
            <remarks>
            本MQTT服务器功能丰富，可以同时实现，用户名密码验证，在线客户端的管理，数据订阅推送，单纯的数据收发，心跳检测，同步数据访问，详细参照下面的示例说明
            </remarks>
            <example>
            最简单的使用，就是实例化，启动服务即可
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample1" title="简单的实例化" />
            当然了，我们可以稍微的复杂一点，加一个功能，验证连接的客户端操作
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample2" title="增加验证" />
            你也可以对clientid进行过滤验证，只要结果返回不是0，就可以了。接下来我们实现一个功能，所有客户端的发布的消息在控制台打印出来,
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample3" title="打印所有发布" />
            捕获客户端刚刚上线的时候，方便我们进行一些额外的操作信息。下面的意思就是返回一个数据，将数据发送到指定的会话内容上去
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample4" title="客户端上线信息" />
            下面演示如何从服务器端发布数据信息，包括多种发布的方法，消息是否驻留，详细看说明即可
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample5" title="服务器发布" />
            下面演示如何支持同步网络访问，当客户端是同步网络访问时，协议内容会变成HUSL，即被视为同步客户端，进行相关的操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttServerSample.cs" region="Sample6" title="同步访问支持" />
            如果需要查看在线信息，可以随时获取<see cref="P:HslCommunication.MQTT.MqttServer.OnlineCount"/>属性，如果需要查看报文信息，可以实例化日志，参考日志的说明即可。
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.#ctor">
            <summary>
            实例化一个MQTT协议的服务器<br />
            Instantiate a MQTT protocol server
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RetainTopicPayload(System.String,System.Byte[])">
            <summary>
            将消息进行驻留
            </summary>
            <param name="topic">消息的主题</param>
            <param name="payload">当前的数据负载</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(HslCommunication.MQTT.MqttSession,System.String,System.Byte[])">
            <summary>
            向指定的客户端发送主题及负载数据<br />
            Sends the topic and payload data to the specified client
            </summary>
            <param name="session">会话内容</param>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(System.String,System.Byte[],System.Boolean)">
            <summary>
            从服务器向订阅了指定的主题的客户端发送消息，默认消息不驻留<br />
            Sends a message from the server to a client that subscribes to the specified topic; the default message does not retain
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishAllClientTopicPayload(System.String,System.Byte[],System.Boolean)">
            <summary>
            向所有的客户端强制发送主题及负载数据，默认消息不驻留<br />
            Send subject and payload data to all clients compulsively, and the default message does not retain
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.PublishTopicPayload(System.String,System.String,System.Byte[],System.Boolean)">
            <summary>
            向指定的客户端ID强制发送消息，默认消息不驻留<br />
            Forces a message to the specified client ID, and the default message does not retain
            </summary>
            <param name="clientId">指定的客户端ID信息</param>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
            <param name="retain">指示消息是否驻留</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ReportProgress(HslCommunication.MQTT.MqttSession,System.String,System.String)">
            <summary>
            向客户端发布一个进度报告的信息，仅用于同步网络的时候才支持进度报告，将进度及消息发送给客户端，比如你的服务器需要分成5个部分完成，可以按照百分比提示给客户端当前服务器发生了什么<br />
            Publish the information of a progress report to the client. The progress report is only supported when the network is synchronized. 
            The progress and the message are sent to the client. For example, your server needs to be divided into 5 parts to complete. 
            You can prompt the client according to the percentage. What happened to the server
            </summary>
            <param name="session">当前的网络会话</param>
            <param name="topic">回发客户端的关键数据，可以是百分比字符串，甚至是自定义的任意功能</param>
            <param name="payload">数据消息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.RemoveAndCloseSession(HslCommunication.MQTT.MqttSession)">
            <summary>
            让MQTT客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。
            </summary>
            <param name="session">当前的会话信息</param>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.OnClientApplicationMessageReceiveDelegate">
            <summary>
            Mqtt的消息收到委托
            </summary>
            <param name="session">当前会话的内容</param>
            <param name="message">Mqtt的消息</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientApplicationMessageReceive">
             <summary>
             当收到客户端发来的<see cref="T:HslCommunication.MQTT.MqttClientApplicationMessage"/>消息时触发<br />
             Triggered when a <see cref="T:HslCommunication.MQTT.MqttClientApplicationMessage"/> message is received from the client
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.OnClientConnectedDelegate">
            <summary>
            当前mqtt客户端连接上服务器的事件委托
            </summary>
            <param name="session">当前的会话对象</param>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientConnected">
            <summary>
            Mqtt的客户端连接上来时触发<br />
            Triggered when Mqtt client connects
            </summary>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.OnClientDisConnected">
            <summary>
            Mqtt的客户端下线时触发<br />
            Triggered when Mqtt client connects
            </summary>
        </member>
        <member name="T:HslCommunication.MQTT.MqttServer.ClientVerificationDelegate">
            <summary>
            验证的委托
            </summary>
            <param name="clientId">客户端的id</param>
            <param name="userName">用户名</param>
            <param name="passwrod">密码</param>
            <returns>0则是通过，否则，就是连接失败</returns>
        </member>
        <member name="E:HslCommunication.MQTT.MqttServer.ClientVerification">
            <summary>
            当客户端连接时，触发的验证事件<br />
            Validation event triggered when the client connects
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.OnlineCount">
            <summary>
            获取当前的在线的客户端数量<br />
            Gets the number of clients currently online
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.OnlineSessions">
            <summary>
            获得当前所有的在线的MQTT客户端信息，包括异步的客户端及同步请求的客户端。<br />
            Obtain all current online MQTT client information, including asynchronous client and synchronous request client.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.MqttOnlineSessions">
            <summary>
            获得当前异步客户端在线的MQTT客户端信息。<br />
            Get the MQTT client information of the current asynchronous client online.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttServer.SyncOnlineSessions">
            <summary>
            获得当前同步客户端在线的MQTT客户端信息，如果客户端是短连接，将难以捕获在在线信息。<br />
            Obtain the MQTT client information of the current synchronization client online. If the client is a short connection, it will be difficult to capture the online information. <br />
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.GetAllRetainTopics">
            <summary>
            获取所有的驻留的消息的主题，如果消息发布的时候没有使用Retain属性，就无法通过本方法查到
            </summary>
            <returns>主题的数组</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSession">
            <summary>
            Mqtt的会话
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.#ctor(System.Net.IPEndPoint,System.String)">
            <summary>
            实例化一个默认的对象
            </summary>
            <param name="endPoint">远程客户端的IP地址</param>
            <param name="protocol">协议信息</param>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.EndPoint">
            <summary>
            远程的ip地址信息
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ClientId">
            <summary>
            当前接收的客户端ID信息
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ActiveTime">
            <summary>
            当前客户端的激活时间
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.OnlineTime">
            <summary>
            获取当前的客户端的上线时间
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.ActiveTimeSpan">
            <summary>
            两次活动的最小时间间隔
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.MqttSocket">
            <summary>
            当前客户端绑定的套接字对象
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.Topics">
            <summary>
            当前客户端订阅的所有的Topic信息
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.UserName">
            <summary>
            当前的用户名
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSession.Protocol">
            <summary>
            当前的协议信息，一般为MQTT，如果是同步客户端那么是HUSL
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.IsClientSubscribe(System.String)">
            <summary>
            检查当前的连接对象是否在
            </summary>
            <param name="topic">主题信息</param>
            <returns>是否包含的结果信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.AddSubscribe(System.String)">
            <summary>
            当前的会话信息新增一个订阅的信息
            </summary>
            <param name="topic">主题的信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.AddSubscribe(System.String[])">
            <summary>
            当前的会话信息新增一个订阅的信息
            </summary>
            <param name="topics">主题的信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.RemoveSubscribe(System.String)">
            <summary>
            移除会话信息的一个订阅的主题
            </summary>
            <param name="topic">主题</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.RemoveSubscribe(System.String[])">
            <summary>
            移除会话信息的一个订阅的主题
            </summary>
            <param name="topics">主题</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSubscribeMessage">
            <summary>
            订阅的消息类，用于客户端向服务器请求订阅的信息<br />
            Subscribed message class, used by the client to request subscription information from the server
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSubscribeMessage.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.QualityOfServiceLevel">
            <summary>
            这个字段表示应用消息分发的服务质量等级保证。分为，最多一次，最少一次，正好一次<br />
            This field indicates the quality of service guarantee for application message distribution. Divided into, at most once, at least once, exactly once
            </summary>
            <remarks>
            在实际的开发中的情况下，最多一次是最省性能的，正好一次是最消耗性能的，如果应有场景为推送实时的数据，那么，最多一次的性能是最高的
            </remarks>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.Identifier">
            <summary>
            当前的消息的标识符，当质量等级为0的时候，不需要重发以及考虑标识情况<br />
            The identifier of the current message, when the quality level is 0, do not need to retransmit and consider the identification situation
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSubscribeMessage.Topics">
            <summary>
            当前订阅的所有的主题的数组信息<br />
            Array information of all topics currently subscribed
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSubscribeMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.MQTT.MqttSyncClient">
            <summary>
            基于MQTT协议的同步访问的客户端程序，支持以同步的方式访问服务器的数据信息，并及时的反馈结果<br />
            The client program based on MQTT protocol for synchronous access supports synchronous access to the server's data information and timely feedback of results
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test" title="简单的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test2" title="带用户名密码的实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test3" title="连接示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test4" title="读取数据示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\MQTT\MqttSyncClientSample.cs" region="Test5" title="带进度报告示例" />
            </example>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(HslCommunication.MQTT.MqttConnectionOptions)">
            <summary>
            实例化一个MQTT的同步客户端<br />
            Instantiate an MQTT synchronization client
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址及端口来实例化一个同步的MQTT客户端<br />
            Instantiate a synchronized MQTT client with the specified IP address and port
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>
            通过指定的ip地址及端口来实例化一个同步的MQTT客户端<br />
            Instantiate a synchronized MQTT client with the specified IP address and port
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.Read(System.String,System.Byte[],System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <summary>
            从MQTT服务器同步读取数据，将payload发送到服务器，然后从服务器返回相关的数据，支持数据发送进度报告，服务器执行进度报告，接收数据进度报告操作<br />
            Synchronously read data from the MQTT server, send the payload to the server, and then return relevant data from the server, 
            support data transmission progress report, the server executes the progress report, and receives the data progress report
            </summary>
            <remarks>
            进度报告可以实现一个比较有意思的功能，可以用来数据的上传和下载，提供一个友好的进度条，因为网络的好坏通常是不确定的。
            </remarks>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
            <param name="sendProgress">发送数据给服务器时的进度报告，第一个参数为已发送数据，第二个参数为总发送数据</param>
            <param name="handleProgress">服务器处理数据的进度报告，第一个参数Topic自定义，通常用来传送操作百分比，第二个参数自定义，通常用来表示服务器消息</param>
            <param name="receiveProgress">从服务器接收数据的进度报告，第一个参数为已接收数据，第二个参数为总接收数据</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ReadString(System.String,System.String,System.Action{System.Int64,System.Int64},System.Action{System.String,System.String},System.Action{System.Int64,System.Int64})">
            <summary>
            从MQTT服务器同步读取数据，将指定编码的字符串payload发送到服务器，然后从服务器返回相关的数据，并转换为指定编码的字符串，支持数据发送进度报告，服务器执行进度报告，接收数据进度报告操作<br />
            Synchronously read data from the MQTT server, send the specified encoded string payload to the server, 
            and then return the data from the server, and convert it to the specified encoded string,
            support data transmission progress report, the server executes the progress report, and receives the data progress report
            </summary>
            <param name="topic">主题信息</param>
            <param name="payload">负载数据</param>
            <param name="sendProgress">发送数据给服务器时的进度报告，第一个参数为已发送数据，第二个参数为总发送数据</param>
            <param name="handleProgress">服务器处理数据的进度报告，第一个参数Topic自定义，通常用来传送操作百分比，第二个参数自定义，通常用来表示服务器消息</param>
            <param name="receiveProgress">从服务器接收数据的进度报告，第一个参数为已接收数据，第二个参数为总接收数据</param>
            <returns>服务器返回的数据信息</returns>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClient.ConnectionOptions">
            <summary>
            获取或设置当前的连接信息，客户端将根据这个连接配置进行连接服务器，在连接之前需要设置相关的信息才有效。<br />
            To obtain or set the current connection information, the client will connect to the server according to this connection configuration. 
            Before connecting, the relevant information needs to be set to be effective.
            </summary>
        </member>
        <member name="P:HslCommunication.MQTT.MqttSyncClient.StringEncoding">
            <summary>
            获取或设置使用字符串访问的时候，使用的编码信息，默认为UT8编码<br />
            Get or set the encoding information used when accessing with a string, the default is UT8 encoding
            </summary>
        </member>
        <member name="M:HslCommunication.MQTT.MqttSyncClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.NamespaceDoc">
            <summary>
            一个工业物联网的底层架构框架，专注于底层的技术通信及跨平台，跨语言通信功能，实现各种主流的PLC数据读写，实现modbus，机器人的各种协议读写等等，
            支持快速搭建工业上位机软件，组态软件，SCADA软件，工厂MES系统，助力企业工业4.0腾飞，实现智能制造，智慧工厂的目标。
            <br /><br />
            本组件付费开源，使用之前请认真的阅读本API文档，对于本文档中警告部分的内容务必理解，部署生产之前请详细测试，如果在测试的过程中，
            发现了BUG，或是有问题的地方，欢迎联系作者进行修改，或是直接在github上进行提问。未经测试，直接部署，对设备，工厂造成了损失，作者概不负责。
            <br /><br />
            官方网站：<a href="http://www.hslcommunication.cn/">http://www.hslcommunication.cn/</a>，包含组件的在线API地址以及一个MES DEMO的项目展示。
            <br /><br />
            <note type="important">
            本组件的目标是集成一个框架，统一所有的设备读写方法，抽象成统一的接口<see cref="T:HslCommunication.Core.IReadWriteNet"/>，对于上层操作只需要关注地址，读取类型即可，另一个目标是使用本框架轻松实现C#后台+C#客户端+web浏览器+android手机的全方位功能实现。
            </note>
            本库提供了C#版本和java版本和python版本，java，python版本的使用和C#几乎是一模一样的，都是可以相互通讯的。
            <br />
            在使用本通讯库之前，需要学会如何使用nuget来安装当前的通讯库，可以参考如下的博文：<a href="http://www.cnblogs.com/dathlin/p/7705014.html">http://www.cnblogs.com/dathlin/p/7705014.html</a>
            <br /><br />
            先整体介绍下如何使用本组件库的基本思路，基本上是引用库，从nuget安装的库会自动添加引用到项目中的，就可以直接进行using操作了，当然了在使用之前，需要先激活一下，激活的方式如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Active.cs" region="Sample1" title="激活示例" />
            在你的应用程序刚开起来的时候，激活一次即可，后续都不需要再重复激活了。接下来就可以开始写代码了。任何的设备的操作基本是相同的，实例化，配置参数（有些plc默认的参数即可），连接设备，读写操作，关闭
            <br />
            关于Hsl的日志功能，贯穿整个hslcommunication的项目，所有的网络类，都包含了<see cref="T:HslCommunication.LogNet.ILogNet"/>日志功能，当然你也可以继承接口实现你自己的日志，在hsl里提供了三种常见的简单实用的日志
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example1" title="单文件实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\LogNet\LogNetSingle.cs" region="Example4" title="日志基本的使用" />
            <br />
            再开始讲解基本的代码通讯之前，先来了解两个基本的概念，长连接，短连接。为了更好的说明当前的通信情况，我把所有的通信拆分为四个部分，连接，发，收，断开。<br />
            短连接：连接，发，收，断开，连接，发，收，断开，连接，发，收，断开，连接，发，收，断开...无限循环<br />
            长连接：连接，发，收，发，收，发，收，发，收，发，收，发，收，发，收，发，收，发，收....断开<br />
            然后我们来看看异常的情况，短连接的异常比较好处理，反正每次请求都是先连接，关键来看长连接的异常<br />
            长连接：连接，发，收，发，收...异常，连接，发，收，发，收，异常，连接，连接，连接...收，发，收，发，收，发，收，发，收....断开<br />
            这里第一个异常发生后，第二次读写立即连接上去并且成功，第二个异常触发后，一直读写失败，说明就是一直连接不上去。<br />
            对于HSL组件来说，不需要重复连接服务器或是plc，无论是短连接还是长连接，都只需要一直读写就OK了，对读写的结果进行判定，即使发生异常了，读写失败了，也要一直坚持，网络好的时候，读写会恢复成功的。<br /><br />
            我们以三菱的PLC为示例，其他的plc调用方式基本是一模一样的，就是调用的类不一样，参数配置不一样而已。以下的逻辑都是适用的。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            需要注意的事，在实际的开发中，我们的一个窗体程序（或是控制台，原理都是一样的），会定时或是不定时的去读写PLC的操作（调用Read或是Write方法），这个本身是没有任何问题的，
            但是总会有这样的需求，我们需要在界面上，或是系统里实时体现当前的PLC的在线情况，我相信不少小伙伴会有这样的问题的。所以就出现了下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Check Netstatus" title="检查连接状态" />
            实际这种操作是非常不可取的，为什么这么说，下面说说原因：<br />
            <note type="warning">
            首先说明下<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>方法里发生了什么？这个方法首先会关闭连接，然后重新连接，连接成功，就发送初始化指令（有些PLC就需要握手确认），初始化握手成功，才返回真正的成功！<br />
            那么这里为什么不行呢？因为Read和Write方法是有混合锁实现互斥操作的，这样的好处就是多线程调用互不影响，但是<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>方法，并没有互斥锁，如果调用的时候同时在读写，那就会导致异常，
            那么为什么没有加互斥锁呢？因为为了实现读写方法的时候，支持自动重连操作，所以连接方法已经在互斥锁了。如果再加互斥锁，会发生死锁，所以综合考虑，就设计成了现在的样子。
            </note>
            既然上面的代码不能使用，那么怎么来看当前的连接状态呢？这里有一点需要注意，<see cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ConnectServer"/>只需要调用0次或1次即可。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Check Netstatus2" title="检查连接状态" />
            如果你本来就在每秒读取PLC的数据信息了，那么连检测的定时器都不用写了，你每次读取数据的时候顺便判定下，结果就出来了。<br /><br />
            其他相关的代码示例需要到各自的目录里查找，下面只列举了一些常见的代码示例
            <list type="bullet">
                <item>Hsl组件日志相关示例参考<see cref="T:HslCommunication.LogNet.ILogNet"/></item>
                <item>三菱mc协议示例参考<see cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet"/></item>
                <item>西门子S7协议示例参考<see cref="T:HslCommunication.Profinet.Siemens.SiemensS7Net"/></item>
                <item>欧姆龙协议示例参考<see cref="T:HslCommunication.Profinet.Omron.OmronFinsNet"/></item>
                <item>罗克韦尔协议示例参考<see cref="T:HslCommunication.Profinet.AllenBradley.AllenBradleyNet"/></item>
                <item>Modbus协议示例参考<see cref="T:HslCommunication.ModBus.ModbusTcpNet"/></item>
                <item>MQTT服务器示例参考<see cref="T:HslCommunication.MQTT.MqttServer"/></item>
                <item>MQTT客户端示例参考<see cref="T:HslCommunication.MQTT.MqttClient"/></item>
                <item>WebSocket服务器示例参考<see cref="T:HslCommunication.WebSocket.WebSocketServer"/></item>
                <item>WebSocket客户端示例参考<see cref="T:HslCommunication.WebSocket.WebSocketClient"/>。</item>
                <item>WebApi示例参考<see cref="T:HslCommunication.Enthernet.HttpServer"/>。</item>
                <item>Redis示例参考<see cref="T:HslCommunication.Enthernet.Redis.RedisClient"/></item>
                <item>身份证阅读器串口版<see cref="T:HslCommunication.Profinet.IDCard.SAMSerial"/></item>
                <item>身份证阅读器网口版<see cref="T:HslCommunication.Profinet.IDCard.SAMTcpNet"/></item>
                <item>文件传送服务器<see cref="T:HslCommunication.Enthernet.UltimateFileServer"/></item>
            </list>
            <note type="important">
            相关的代码示例，可以翻阅左侧的命名空间，基本是按照功能来区分的，只要点进去多看看即可
            </note>
            </summary>
            <remarks>
            本软件著作权归Richard.Hu所有。
            <br />
            博客地址：<a href="https://www.cnblogs.com/dathlin/p/7703805.html">https://www.cnblogs.com/dathlin/p/7703805.html</a>
            <br />
            授权付费模式：超级VIP群 : 189972948
            <br />
            <list type="bullet">
                <item>本群提供专业版通讯库的所有更新版的 HslCommunication 源代码。包含 .Net Java Python 三大平台。</item>
                <item>本群支持对特殊需求而进行修改，更新源代码的服务，配合企业客户修复源代码错误的服务。</item>
                <item>本群成员拥有对通讯库商用的权利，拥有自己修改源代码并商业使用的权利，组件版权仍归属原作者。</item>
                <item>本群成员需要对源代码保密。禁止公开源代码，禁止对源代码的商业用途。</item>
                <item>本群成员可以免费获得官网的 MES DEMO源代码。</item>
                <item>本群成员可以免费体验作者采集框架程序。</item>
                <item>企业商业授权 企业付费 8000 rmb，公司即可拥有商用版权，支持任意的开发人员数量，项目数量，支持源代码更新，长期支持，商用软件必须冠名公司标识，官网显示合作伙伴logo。</item>
                <item>支持专业的一对一培训业务，一小时1000 rmb，一天8小时为5000 rmb</item>
            </list>
            
            付费二维码：<br />
            <img src="https://raw.githubusercontent.com/dathlin/HslCommunication/master/imgs/support.png" />
            </remarks>
            <revisionHistory>
                <revision date="2017-10-21" version="3.7.10" author="Richard.Hu">
                    <list type="bullet">
                        <item>正式发布库到互联网上去。</item>
                    </list>
                </revision>
                <revision date="2017-10-21" version="3.7.11" author="Richard.Hu">
                    <list type="bullet">
                        <item>添加xml文档</item>
                    </list>
                </revision>
                <revision date="2017-10-31" version="3.7.12" author="Richard.Hu">
                    <list type="bullet">
                        <item>重新设计西门子的数据读取机制，提供一个更改类型的方法。</item>
                    </list>
                </revision>
                <revision date="2017-11-06" version="3.7.13" author="Richard.Hu">
                    <list type="bullet">
                        <item>提供一个ModBus的服务端引擎。</item>
                    </list>
                </revision>
                <revision date="2017-11-07" version="3.7.14" author="Richard.Hu">
                    <list type="bullet">
                        <item>紧急修复了西门子批量访问时出现的BUG。</item>
                    </list>
                </revision>
                <revision date="2017-11-12" version="3.7.15" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善CRC16校验码功能，完善数据库辅助类方法。</item>
                    </list>
                </revision>
                <revision date="2017-11-13" version="3.7.16" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子访问类，提供一个批量bool数据写入，但该写入存在安全隐患，具体见博客。</item>
                    </list>
                </revision>
                <revision date="2017-11-21" version="4.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>与3.X版本不兼容，谨慎升级。如果要升级，主要涉及的代码包含PLC的数据访问和同步数据通信。</item>
                        <item>删除了2个类，OperateResultBytes和OperateResultString类，提供了更加强大方便的泛型继承类，多达10个泛型参数。地址见http://www.cnblogs.com/dathlin/p/7865682.html</item>
                        <item>将部分类从HslCommunication命名空间下移动到HslCommunication.Core下面。</item>
                        <item>提供了一个通用的ModBus TCP的客户端类，方便和服务器交互。</item>
                        <item>完善了HslCommunication.BasicFramework.SoftBaisc下面的辅助用的静态方法，提供了一些方便的数据转化，在上面进行公开。</item>
                    </list>
                </revision>
                <revision date="2017-11-24" version="4.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>更新了三菱的读取接口，提供了一个额外的字符串表示的方式，OperateResult&lt;byte[]&gt; read =  melsecNet.ReadFromPLC("M100", 5);</item>
                        <item>更新了西门子的数据访问类和modbus tcp类提供双模式运行，按照之前版本的写法是默认模式，每次请求重新创建网络连接，新增模式二，在代码里先进行连接服务器方法，自动切换到模式二，每次请求都共用一个网络连接，内部已经同步处理，加速数据访问，如果访问失败，自动在下次请求是重新连接，如果调用关闭连接服务器，自动切换到模式一。</item>
                    </list>
                </revision>
                <revision date="2017-11-25" version="4.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus tcp批量写入寄存器时，数据解析异常的BUG。</item>
                        <item>三菱访问器新增长连接模式。</item>
                        <item>三菱访问器支持单个M写入，在数组中指定一个就行。</item>
                        <item>三菱访问器提供了float[]数组写入的API。</item>
                        <item>三菱访问器支持F报警器，B链接继电器，S步进继电器，V边沿继电器，R文件寄存器读写，不过还需要大面积测试。</item>
                        <item>三菱访问器的读写地址支持字符串形式传入。</item>
                        <item>其他的细节优化。</item>
                        <item>感谢 hwdq0012 网友的测试和建议。</item>
                        <item>感谢 吃饱睡好 好朋友的测试</item>
                    </list>
                </revision>
                <revision date="2017-11-27" version="4.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱，西门子，Modbus tcp客户端内核优化重构。</item>
                        <item>三菱，西门子，Modbus tcp客户端提供统一的报文测试方法，该方法也是通信核心，所有API都是基于此扩展起来的。</item>
                        <item>三菱，西门子，Modbus tcp客户端提供了一些便捷的读写API，详细参见对应博客。</item>
                        <item>三菱的地址区分十进制和十六进制。</item>
                        <item>优化三菱的位读写操作。</item>
                    </list>
                </revision>
                <revision date="2017-11-28" version="4.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子读取的地址偏大会出现异常的BUG。</item>
                        <item>完善统一了所有三菱，西门子，modbus客户端类的读写方法，已经更新到博客。</item>
                    </list>
                </revision>
                <revision date="2017-12-02" version="4.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善日志记录，提供关键字记录操作。</item>
                        <item>三菱，西门子，modbus tcp客户端提供自定义数据读写。</item>
                        <item>modbus tcp服务端提供数据池功能，并支持数据订阅操作。</item>
                        <item>提供一个纵向的进度控件。</item>
                    </list>
                </revision>
                <revision date="2017-12-04" version="4.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>完善Modbus tcp服务器端的数据订阅功能。</item>
                        <item>进度条控件支持水平方向和垂直方向两个模式。</item>
                    </list>
                </revision>
                <revision date="2017-12-05" version="4.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>进度条控件修复初始颜色为空的BUG。</item>
                        <item>进度条控件文本锯齿修复。</item>
                        <item>按钮控件无法使用灰色按钮精灵破解。</item>
                    </list>
                </revision>
                <revision date="2017-12-13" version="4.1.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>modbus tcp提供读取short数组的和ushort数组方法。</item>
                    </list>
                </revision>
                <revision date="2017-12-13" version="4.1.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复流水号生成器无法生成不带日期格式的流水号BUG。</item>
                    </list>
                </revision>
                <revision date="2017-12-18" version="4.1.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>OperateResult成功时，消息为成功。</item>
                        <item>数据库辅助类API添加，方便的读取聚合函数。</item>
                        <item>日志类分析工具界面，显示文本微调。</item>
                    </list>
                </revision>
                <revision date="2017-12-25" version="4.1.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>进度条控件新增一个新的属性对象，是否使用动画。</item>
                    </list>
                </revision>
                <revision date="2017-12-27" version="4.1.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个饼图控件。</item>
                    </list>
                </revision>
                <revision date="2017-12-28" version="4.1.9" author="Richard.Hu">
                    <list type="bullet">
                        <item>饼图显示优化，新增是否显示百分比的选择。</item>
                    </list>
                </revision>
                <revision date="2017-12-31" version="4.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个仪表盘控件。</item>
                    </list>
                </revision>
                <revision date="2018-01-03" version="4.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>饼图控件新增一个是否显示占比很小的信息文本。</item>
                        <item>新增一个旋转开关控件。</item>
                        <item>新增一个信号灯控件。</item>
                    </list>
                </revision>
                <revision date="2018-01-05" version="4.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus tcp客户端读取 float, int, long,的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-01-08" version="4.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus tcp客户端读取某些特殊设备会读取不到数据的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-01-15" version="4.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>双模式的网络基类中新增一个读取超时的时间设置，如果为负数，那么就不验证返回。</item>
                    </list>
                </revision>
                <revision date="2018-01-24" version="4.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>信号灯控件显示优化。</item>
                        <item>Modbus Tcp服务端类修复内存暴涨问题。</item>
                        <item>winfrom客户端提供一个曲线控件，方便显示实时数据，多曲线数据。</item>
                    </list>
                </revision>
                <revision date="2018-02-05" version="4.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>优化modbus tcp客户端的访问类，支持服务器返回错误信息。</item>
                        <item>优化曲线控件，支持横轴文本显示，支持辅助线标记，详细见对应博客。</item>
                    </list>
                </revision>
                <revision date="2018-02-22" version="4.3.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件最新时间显示BUG修复。</item>
                        <item>Modbus tcp错误码BUG修复。</item>
                        <item>三菱访问类完善long类型读写。</item>
                        <item>西门子访问类支持1500系列，支持读取订货号。</item>
                    </list>
                </revision>
                <revision date="2018-03-05" version="4.3.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件增加一个新的属性，图标标题。</item>
                        <item>Modbus tcp服务器端的读写BUG修复。</item>
                        <item>西门子访问类重新支持200smart。</item>
                    </list>
                </revision>
                <revision date="2018-03-07" version="4.3.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Json组件更新至11.0.1版本。</item>
                        <item>紧急修复日志类的BeforeSaveToFile事件在特殊情况的触发BUG。</item>
                    </list>
                </revision>
                <revision date="2018-03-19" version="4.3.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus-tcp服务器接收异常的BUG。</item>
                        <item>修复SoftBasic.ByteTo[U]ShortArray两个方法异常。</item>
                    </list>
                </revision>
                <revision date="2018-04-05" version="5.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>网络核心层重新开发，完全的基于异步IO实现。</item>
                        <item>所有双模式客户端类进行代码重构，接口统一。</item>
                        <item>完善并扩充OperateResult对象的类型支持。</item>
                        <item>提炼一些基础的更加通用的接口方法，在SoftBasic里面。</item>
                        <item>支持欧姆龙PLC的数据交互。</item>
                        <item>支持三菱的1E帧数据格式。</item>
                        <item>不兼容升级，谨慎操作。</item>
                    </list>
                </revision>
                <revision date="2018-04-10" version="5.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>OperateResult静态方法扩充。</item>
                        <item>文件引擎提升缓存空间到100K，加速文件传输。</item>
                        <item>三菱添加读取单个bool数据。</item>
                        <item>Modbus-tcp客户端支持配置起始地址不是0的服务器。</item>
                        <item>其他代码优化。</item>
                    </list>
                </revision>
                <revision date="2018-04-14" version="5.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ComplexNet服务器代码精简优化，移除客户端的在线信息维护代码。</item>
                        <item>西门子访问类第一次握手信号18字节改为0x02。</item>
                        <item>更新JSON组件到11.0.2版本。</item>
                        <item>日志存储类优化，支持过滤存储特殊关键字的日志。</item>
                        <item>Demo项目新增控件介绍信息。</item>
                    </list>
                </revision>
                <revision date="2018-04-20" version="5.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Modbus-Tcp服务器的空异常。</item>
                        <item>修复西门子类写入float，double，long数据异常。</item>
                        <item>修复modbus-tcp客户端读写字符串颠倒异常。</item>
                        <item>修复三菱多读取数据字节的问题。</item>
                        <item>双模式客户端新增异形客户端模式，变成了三模式客户端。</item>
                        <item>提供异形modbus服务器和客户端Demo方便测试。</item>
                    </list>
                </revision>
                <revision date="2018-04-25" version="5.0.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus-tcp服务器同时支持RTU数据交互。</item>
                        <item>异形客户端新增在线监测，自动剔除访问异常设备。</item>
                        <item>modbus-tcp支持读取输入点。</item>
                        <item>所有客户端设备的连接超时判断增加休眠，降低CPU负载。</item>
                        <item>西门子批量读取上限为19个数组。</item>
                        <item>其他小幅度的代码优化。</item>
                    </list>
                </revision>
                <revision date="2018-04-30" version="5.0.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus相关的代码优化。</item>
                        <item>新增Modbus-Rtu客户端模式，配合服务器的串口支持，已经可以实现电脑本机的通讯测试了。</item>
                    </list>
                </revision>
                <revision date="2018-05-04" version="5.0.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>提炼数据转换基类，优化代码，修复WordReverse类对字符串的BUG，相当于修复modbus和omron读写字符串的异常。</item>
                        <item>新增一个全新的功能类，数据的推送类，轻量级的高效的订阅发布数据信息。具体参照Demo。</item>
                    </list>
                </revision>
                <revision date="2018-05-07" version="5.0.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器提供在线客户端数量属性。</item>
                        <item>所有服务器基类添加端口缓存。</item>
                        <item>双模式客户端完善连接失败，请求超时的消息提示。</item>
                        <item>修复双模式客户端某些特殊情况下的头子节NULL异常。</item>
                        <item>修复三菱交互类的ASCII协议下的写入数据异常。</item>
                    </list>
                </revision>
                <revision date="2018-05-12" version="5.0.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个埃夫特机器人的数据访问类。</item>
                        <item>双模式客户端的长连接支持延迟连接操作，通过一个新方法完成。</item>
                    </list>
                </revision>
                <revision date="2018-05-21" version="5.0.9" author="Richard.Hu">
                    <list type="bullet">
                        <item>优化ComplexNet客户端的代码。</item>
                        <item>更新埃夫特机器人的读取机制到最新版。</item>
                        <item>Modbus Rtu及串口基类支持接收超时时间设置，不会一直卡死。</item>
                        <item>Modbus Tcp及Rtu都支持带功能码输入，比如读取100地址，等同于03X100。（注意：该多功能地址仅仅适用于Read及相关的方法</item>
                    </list>
                </revision>
                <revision date="2018-05-22" version="5.0.10" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus Tcp及Rtu支持手动更改站号。也就是支持动态站号调整。</item>
                        <item>修复上个版本遗留的Modbus在地址偏移情况下会多减1的BUG。</item>
                    </list>
                </revision>
                <revision date="2018-06-05" version="5.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器支持串口发送数据时也会触发消息接收。</item>
                        <item>IReadWriteNet接口新增Read(string address,ushort length)方法。</item>
                        <item>提炼统一的设备基类，支持Read方法及其扩展的子方法。</item>
                        <item>修复埃夫特机器人的读取BUG。</item>
                        <item>三菱PLC支持读取定时器，计数器的值，地址格式为"T100"，"C100"。</item>
                        <item>新增快速离散的傅立叶频谱变换算法，并在Demo中测试三种周期信号。</item>
                    </list>
                </revision>
                <revision date="2018-06-16" version="5.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子fetch/write协议对db块，定时器，计数器读写的BUG。</item>
                        <item>埃夫特机器人修复tostring()的方法。</item>
                        <item>modbus客户端新增两个属性，指示是否字节颠倒和字符串颠倒，根据不同的服务器配置。</item>
                        <item>IReadWriteNet接口补充几个数组读取的方法。</item>
                        <item>新增一个全新的连接池功能类，详细请参见 https://www.cnblogs.com/dathlin/p/9191211.html </item>
                        <item>其他的小bug修复，细节优化。</item>
                    </list>
                </revision>
                <revision date="2018-06-27" version="5.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>IByteTransform接口新增bool[]数组转换的2个方法。</item>
                        <item>Modbus Server类新增离散输入数据池和输入寄存器数据池，可以在服务器端读写，在客户端读。</item>
                        <item>Modbus Tcp及Modbus Rtu及java的modbus tcp支持富地址表示，比如"s=2;100"为站号2的地址100信息。</item>
                        <item>Modbus Server修复一个偶尔出现多次异常下线的BUG。</item>
                        <item>其他注释修正。</item>
                    </list>
                </revision>
                <revision date="2018-07-13" version="5.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Modbus服务器新增数据大小端配置。</item>
                        <item>Modbus服务器支持数据存储本地及从本地加载。</item>
                        <item>修复modbus服务器边界读写bug。</item>
                        <item>ByteTransformBase的double转换bug修复。</item>
                        <item>修复ReverseWordTransform批量字节转换时隐藏的一些bug。</item>
                        <item>SoftBasic移除2个数据转换的方法。</item>
                        <item>修复modbus写入单个寄存器的高地位倒置的bug。</item>
                        <item>修复串口通信过程中字节接收不完整的异常。包含modbus服务器和modbus-rtu。</item>
                        <item>添加了.net 4.5项目，并且其他项目源代码引用该项目。添加了单元测试，逐步新增测试方法。</item>
                    </list>
                </revision>
                <revision date="2018-07-27" version="5.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>项目新增api文档，提供离线版和在线版，文档提供了一些示例代码。</item>
                        <item>modbus-rtu新增批量的数组读取方法。</item>
                        <item>modbus-rtu公开ByteTransform属性，方便的进行数据转换。</item>
                        <item>SoftMail删除发送失败10次不能继续发送的机制。</item>
                        <item>modbus server新增站号属性，站号不对的话，不响应rtu反馈。</item>
                        <item>modbus server修复读取65524和65535地址提示越界的bug。</item>
                        <item>Demo项目提供了tcp/ip的调试工具。</item>
                    </list>
                </revision>
                <revision date="2018-08-08" version="5.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>API文档中西门子FW协议示例代码修复。</item>
                        <item>modbus-rtu修复读取线圈和输入线圈的值错误的bug。</item>
                    </list>
                </revision>
                <revision date="2018-08-23" version="5.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>Demo中三菱A-1E帧，修复bool读取显示失败的BUG。</item>
                        <item>数据订阅类客户端连接上服务器后，服务器立即推送一次。</item>
                        <item>串口设备基类代码提炼，提供了多种数据类型的读写支持。</item>
                        <item>仪表盘新增属性IsBigSemiCircle，设置为true之后，仪表盘可显示大于半圆的视图。</item>
                        <item>提供了一个新的三菱串口类，用于采集FX系列的PLC，MelsecFxSerial</item>
                    </list>
                </revision>
                <revision date="2018-08-24" version="5.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复双模式基类的一个bug，支持不接受反馈数据。</item>
                        <item>修复三菱串口类的读写bug，包括写入位，和读取字和位。</item>
                        <item>相关代码重构优化。</item>
                    </list>
                </revision>
                <revision date="2018-09-08" version="5.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>串口基类接收数据优化，保证接收一次完整的数据内容。</item>
                        <item>新增一个容器罐子的控件，可以调整背景颜色。</item>
                        <item>OperateResult成功时的错误码调整为0。</item>
                        <item>修复modbus-tcp及modbus-rtu读取coil及discrete的1个位时解析异常的bug。</item>
                        <item>授权类公开一个属性，终极秘钥的属性，感谢 洛阳-LYG 的建议。</item>
                        <item>修复transbool方法在特殊情况下的bug</item>
                        <item>NetworkDeviceBase 写入的方法设置为了虚方法，允许子类进行重写。</item>
                        <item>SoftBasic: 新增三个字节处理的方法，移除前端字节，移除后端字节，移除两端字节。</item>
                        <item>新增串口应用的LRC校验方法。还未实际测试。</item>
                        <item>Siemens的s7协议支持V区自动转换，方便数据读取。</item>
                        <item>新增ab plc的类AllenBradleyNet，已测试读写，bool写入仍存在一点问题。</item>
                        <item>新增modbus-Ascii类，该类库还未仔细测试。</item>
                        <item>埃夫特机器人更新，适配最新版本数据采集。</item>
                        <item>其他的代码优化，重构精简</item>
                    </list>
                </revision>
                <revision date="2018-09-10" version="5.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复埃夫特机器人读取数据的bug，已测试通过。</item>
                        <item>ByteTransform数据转换层新增一个DataFormat属性，可选ABCD,BADC,CDAB,DCBA</item>
                        <item>三个modbus协议均适配了ByteTransform并提供了直接修改的属性，默认ABCD</item>
                        <item>注意：如果您的旧项目使用的Modbus类，请务必重新测试适配。给你带来的不便，敬请谅解。</item>
                    </list>
                </revision>
                <revision date="2018-09-21" version="5.3.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>所有显示字符串支持中英文，支持切换，默认为系统语言。</item>
                        <item>Json组件依赖设置为不依赖指定版本。</item>
                        <item>modbus-ascii类库测试通过。</item>
                        <item>新增松下的plc串口读写类，还未测试。</item>
                        <item>西门子s7类写入byte数组长度不受限制，原先大概250个字节左右。</item>
                        <item>demo界面进行了部分的中英文适配。</item>
                        <item>OperateResult类新增了一些额外的构造方法。</item>
                        <item>SoftBasic新增了几个字节数组操作相关的通用方法。</item>
                        <item>其他大量的细节的代码优化，重构。</item>
                    </list>
                </revision>
                <revision date="2018-09-27" version="5.3.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>DeviceNet层添加异步的API，支持async+await调用。</item>
                        <item>java修复西门子的写入成功却提示失败的bug。</item>
                        <item>java代码重构，和C#基本保持一致。</item>
                        <item>python版本发布，支持三菱，西门子，欧姆龙，modbus，数据订阅，同步访问。</item>
                        <item>其他的代码优化，重构精简。</item>
                    </list>
                </revision>
                <revision date="2018-10-20" version="5.4.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>python和java的代码优化，完善，添加三菱A-1E类。</item>
                        <item>修复仪表盘控件，最大值小于0会产生的特殊Bug。</item>
                        <item>NetSimplifyClient: 提供高级.net的异步版本方法。</item>
                        <item>serialBase: 新增初始化和结束的保护方法，允许重写实现额外的操作。</item>
                        <item>softBuffer: 添加一个线程安全的buffer内存读写。</item>
                        <item>添加西门子ppi协议类，针对s7-200，需要最终测试。</item>
                        <item>Panasonic: 修复松下plc的读取读取数据异常。</item>
                        <item>修复fx协议批量读取bool时意外的Bug。</item>
                        <item>NetSimplifyClient: 新增带用户int数据返回的读取接口。</item>
                    </list>
                </revision>
                <revision date="2018-10-24" version="5.4.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增一个温度采集模块的类，基于modbus-rtu实现，阿尔泰科技发展有限公司的DAM3601模块。</item>
                    </list>
                </revision>
                <revision date="2018-10-25" version="5.4.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱的mc协议新增支持读取ZR文件寄存器功能。</item>
                    </list>
                </revision>
                <revision date="2018-10-30" version="5.4.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复AB PLC的bool和byte写入失败的bug，感谢 北京-XLang 提供的思路。</item>
                    </list>
                </revision>
                <revision date="2018-11-1" version="5.5.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增西门子PPI通讯类库，支持200，200smart等串口通信，感谢 合肥-加劲 和 江阴-  ∮溪风-⊙_⌒ 的测试</item>
                    </list>
                </revision>
                <revision date="2018-11-5" version="5.5.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增三菱计算机链接协议通讯库，支持485组网，有效距离达50米，感谢珠海-刀客的测试。</item>
                        <item>串口协议的基类提供了检测当前串口是否处于打开的方法接口。</item>
                        <item>西门子S7协议新增槽号为3的s7-400的PLC选项，等待测试。</item>
                    </list>
                </revision>
                <revision date="2018-11-9" version="5.5.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子PPI写入bool方法名重载到了Write方法里。</item>
                        <item>松下写入bool方法名重载到了Write方法里。</item>
                        <item>修复CRC16验证码在某些特殊情况下的溢出bug。</item>
                        <item>西门子类添加槽号和机架号属性，只针对400PLC有效，初步测试可读写。</item>
                        <item>ab plc支持对数组的读写操作，支持数组长度为0-246，超过246即失败。</item>
                        <item>三菱的编程口协议修复某些特殊情况读取失败，却提示成功的bug。</item>
                        <item>串口基类提高缓存空间到4096，并在数据交互时捕获COM口的异常。</item>
                    </list>
                </revision>
                <revision date="2018-11-16" version="5.6.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复欧姆龙的数据格式错误，修改为CDAB。</item>
                        <item>新增一个瓶子的控件。</item>
                        <item>新增一个管道的控件。</item>
                        <item>初步新增一个redis的类，初步实现了读写关键字。</item>
                    </list>
                </revision>
                <revision date="2018-11-21" version="5.6.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>AB PLC读取数组过长时提示错误信息。</item>
                        <item>正式发布redis客户端，支持一些常用的操作，并提供一个浏览器。博客：https://www.cnblogs.com/dathlin/p/9998013.html </item>
                    </list>
                </revision>
                <revision date="2018-11-24" version="5.6.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>曲线控件的曲线支持隐藏其中的一条或是多条曲线，可以用来实现手动选择显示曲线的功能。</item>
                        <item>Redis功能块代码优化，支持通知服务器进行数据快照保存，包括同步异步。</item>
                        <item>Redis新增订阅客户端类，可以实现订阅一个或是多个频道数据。</item>
                    </list>
                </revision>
                <revision date="2018-11-30" version="5.6.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>串口数据接收的底层机制重新设计。</item>
                        <item>串口底层循环验证缓冲区是否有数据的间隔可更改，默认20ms。</item>
                        <item>串口底层新增一个清除缓冲区数据的方法。</item>
                        <item>串口底层新增一个属性，用于配置是否在每次读写前清除缓冲区的脏数据。</item>
                        <item>新增了一个SharpList类，用于超高性能的管理固定长度的数组。博客：https://www.cnblogs.com/dathlin/p/10042801.html </item>
                    </list>
                </revision>
                <revision date="2018-12-3" version="5.6.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase: 接收方法的一个多余对象删除。</item>
                        <item>修复UserDrum控件的默认的text生成，及复制问题。</item>
                        <item>UserDrum修复属性在设计界面没有注释的bug。</item>
                    </list>
                </revision>
                <revision date="2018-12-5" version="5.6.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复Demo程序在某些特殊情况下无法在线更新的bug。</item>
                        <item>修复曲线控件隐藏曲线时在某些特殊情况的不隐藏的bug。</item>
                        <item>modbus协议无论读写都支持富地址格式。</item>
                        <item>修复连接池清理资源的一个bug，感谢 泉州-邱蕃金</item>
                        <item>修复java的modbus代码读取线圈异常的操作。</item>
                        <item>Demo程序新增免责条款。</item>
                    </list>
                </revision>
                <revision date="2018-12-11" version="5.6.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复redis客户端对键值进行自增自减指令操作时的类型错误bug。</item>
                        <item>修复redis客户端对哈希值进行自增自减指令操作时的类型错误bug。</item>
                        <item>推送的客户端可选委托或是事件的方式，方便labview调用。</item>
                        <item>推送的客户端修复当服务器的关键字不存在时连接未关闭的Bug。</item>
                        <item>Demo程序里，欧姆龙测试界面新增数据格式功能。</item>
                    </list>
                </revision>
                <revision date="2018-12-19" version="5.6.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>ByteTransfer数据转换类新增了一个重载的构造方法。</item>
                        <item>Redis客户提供了一个写键值并发布订阅的方法。</item>
                        <item>AB-PLC支持槽号选择，默认为0。</item>
                        <item>PushNet推送服务器新增一个配置，可用于设置是否在客户端刚上线的时候推送缓存数据。</item>
                        <item>PushNet推送服务器对客户端的上下限管理的小bug修复。</item>
                        <item>本版本开始，组件将使用强签名。</item>
                        <item>本版本开始，组件的控件库将不再维护更新，所有的控件在新的控件库重新实现和功能增强，VIP群将免费使用控件库。</item>
                        <item>VIP群的进入资格调整为赞助200Rmb，谢谢支持。</item>
                    </list>
                </revision>
                <revision date="2018-12-27" version="5.7.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus服务器地址写入的bug，之前写入地址数据后无效，必须带x=3;100才可以。</item>
                        <item>修复极少数情况内核对象申请失败的bug，之前会引发资源耗尽的bug。</item>
                        <item>SoftBasic的ByteToBoolArray新增一个转换所有位的重载方法，不需要再传递位数。</item>
                        <item>埃夫特机器人新增旧版的访问类对象，达到兼容的目的。</item>
                        <item>Demo程序新增作者简介。</item>
                        <item>修复Demo程序的redis订阅界面在设置密码下无效的bug。</item>
                        <item>Demo程序的免责界面新增demo在全球的使用情况。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2018-12-31" version="5.7.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复modbus服务器地址读取的bug，之前读取地址数据后无效，必须带x=3;100才可以。</item>
                        <item>NetPush功能里，当客户端订阅关键字时，服务器即使没有该关键字，也成功。</item>
                        <item>三菱的通讯类支持所有的字读取。例如读取M100的short数据表示M100-M115。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-1-15" version="5.7.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复三菱A-1E协议的读取数据的BUG错误，给大家造成的不便，非常抱歉。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-7" version="5.7.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>欧姆龙读写机制更改，报警的异常不再视为失败，仍然可以解析数据。</item>
                        <item>Modbus地址优化，Modbus服务器的地址读写优化。</item>
                        <item>新增一个数据池类，SoftBuffer，主要用来缓存字节数组内存的，支持BCL数据类型读写。</item>
                        <item>Modbus服务器的数据池更新，使用了最新的数据池类SoftBuffer。</item>
                        <item>SoftBasic类新增一个GetEnumFromString方法，支持从字符串直接生成枚举值，已通过单元测试。</item>
                        <item>新增一个机器人的读取接口信息IRobotNet，统一化所有的机器人的数据读取。</item>
                        <item>Demo程序中增加modbus的服务器功能。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-13" version="5.7.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>日志存储的线程号格式化改为D3，也即三位有效数字。</item>
                        <item>日志存储事件BeforeSaveToFile里允许设置日志Cancel属性，强制当前的记录不存储。</item>
                        <item>JSON库更新到12.0.1版本。</item>
                        <item>SoftBasic新增一个GetTimeSpanDescription方法，用来将时间差转换成文本的方法。</item>
                        <item>调整日志分析控件不随字体变化而变化。</item>
                        <item>其他的代码精简优化。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-2-21" version="5.8.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SoftBasic修复AddArrayData方法批量添加数据异常的bug，导致曲线控件显示异常。</item>
                        <item>提炼一个公共的欧姆龙辅助类，准备为串口协议做基础的通用支持。</item>
                        <item>RedisHelper类代码优化精简，提炼部分的公共逻辑到NetSupport。</item>
                        <item>SoftBuffer: 新增读写单个的位操作，通过位的与或非来实现。</item>
                        <item>SiemensS7Server：新增一个s7协议的服务器，可以模拟PLC，进行通讯测试或是虚拟开发。</item>
                        <item>其他的代码精简优化。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-3-4" version="6.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子虚拟PLC的ToString()方法重新实现。</item>
                        <item>埃夫特机器人的json格式化修正换行符。</item>
                        <item>IReadWriteNet接口添加Write(address, bytes)的方法。</item>
                        <item>Modbus虚拟服务器修复写入位操作时影响后面3个位的bug。</item>
                        <item>SoftBuffer内存数据池类的SetValue(byte,index)的bug修复。</item>
                        <item>西门子虚拟PLC和Modbus服务器新增客户端管理，关闭时也即断开所有连接。</item>
                        <item>三菱编程口协议的读取结果添加错误说明，显示原始返回信号，便于分析。</item>
                        <item>三菱MC协议新增远程启动，停止，读取PLC型号的接口。</item>
                        <item>新增三菱MC协议的串口的A-3C协议支持，允许读写三菱PLC的数据。</item>
                        <item>新增欧姆龙HostLink协议支持，允许读写PLC数据。</item>
                        <item>新增基恩士PLC的MC协议支持，包括二进制和ASCII格式，支持读写PLC的数据。</item>
                        <item>所有PLC的地址说明重新规划，统一在API文档中查询。</item>
                        <item>注意：三菱PLC的地址升级，有一些地址格式进行了更改，比如定时器和计数器，谨慎更新，详细地址参考最新文档。</item>
                        <item>如果有公司使用了本库并愿意公开logo的，将在官网及git上进行统一显示，有意愿的联系作者。</item>
                        <item>VIP群将免费使用全新的控件库，谢谢支持。地址：https://github.com/dathlin/HslControlsDemo </item>
                    </list>
                </revision>
                <revision date="2019-3-10" version="6.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复代码注释上的一些bug，三菱的注释修复。</item>
                        <item>调整三菱和基恩士D区数据和W区数据的地址范围，原来只支持到65535。</item>
                        <item>SoftIncrementCount: 修复不持久化的序号自增类的数据复原的bug，并添加totring方法。</item>
                        <item>IRobot接口更改。针对埃夫特机器人进行重新实现。</item>
                        <item>RedisClient: 修复redis类在带有密码的情况下锁死的bug。</item>
                        <item>初步添加Kuka机器人的通讯类，等待测试。</item>
                        <item>西门子的s7协议读写字符串重新实现，根据西门子的底层存储规则来操作。</item>
                        <item>Demo的绝大多的界面进行重构。更友好的支持英文版的显示风格。</item>
                        <item>如果有公司使用了本库并愿意公开logo的，将在官网及git上进行统一显示，有意愿的联系作者。</item>
                    </list>
                </revision>
                <revision date="2019-3-21" version="6.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复西门子s7协议读写200smart字符串的bug。</item>
                        <item>重构优化NetworkBase及NetwordDoubleBase网络类的代码。</item>
                        <item>新增欧姆龙的FinsUdp的实现，DA1【PLC节点号】在配置Ip地址的时候自动赋值，不需要额外配置。</item>
                        <item>FinsTcp类的DA1【PLC节点号】在配置Ip地址的时候自动赋值，不需要额外配置。</item>
                    </list>
                </revision>
                <revision date="2019-3-28" version="6.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetPushServer推送服务器修复某些情况下的推送卡死的bug。</item>
                        <item>SoftBuffer内存数据类修复Double转换时出现的错误bug。</item>
                        <item>修复Kuka机器人读写数据错误的bug，已通过测试。</item>
                        <item>修复三菱的MelsecMcAsciiNet类写入bool值及数组会导致异常的bug，已通过单元测试。</item>
                        <item>SoftBasic新增从字符串计算MD5码的方法。</item>
                    </list>
                </revision>
                <revision date="2019-4-4" version="6.0.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复java的NetPushClient掉线重复连接的bug。</item>
                        <item>发布java的全新测试Demo。</item>
                        <item>Kuka机器人Demo修改帮助链接。</item>
                        <item>西门子新增s200的以太网模块连接对象。</item>
                        <item>修复文件引擎在上传文件时意外失败，服务器仍然识别为成功的bug。</item>
                    </list>
                </revision>
                <revision date="2019-4-17" version="6.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复日志存储自身异常时，时间没有初始化的bug。</item>
                        <item>NetworkBase: 新增UseSynchronousNet属性，默认为true，通过同步的网络进行读写数据，异步手动设置为false。</item>
                        <item>修复西门子的读写字符串的bug。</item>
                        <item>添加KeyenceNanoSerial以支持基恩士Nano系列串口通信。</item>
                        <item>其他的代码优化。</item>
                        <item>发布一个基于xamarin的安卓测试demo。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-4-24" version="6.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复基恩士MC协议读取D区数据索引不能大于100000的bug。</item>
                        <item>修复基恩士串口协议读写bool数据的异常bug。</item>
                        <item>修复数据推送服务器在客户端异常断开时的奔溃bug，界面卡死bug。</item>
                        <item>SoftNumericalOrder类新增数据重置和，最大数限制 。</item>
                        <item>ModbusTcp客户端公开属性SoftIncrementCount，可以强制消息号不变，或是最大值。</item>
                        <item>NetworkBase: 异步的方法针对Net451及standard版本重写。</item>
                        <term>modbus服务器的方法ReadFromModbusCore( byte[] modbusCore )设置为虚方法，可以继承重写，实现自定义返回。</term>
                        <item>串口基类serialbase的初始化方法新增多个重载方法，方便VB和labview调用。</item>
                        <item>NetworkBase: 默认的机制任然使用异步实现，UseSynchronousNet=false。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-4-25" version="6.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>紧急修复在NET451和Core里的异步读取的bug。</item>
                        <item>紧急修复PushNetServer的发送回调bug。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-6" version="6.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SoftBuffer缓存类支持bool数据的读写，bool数组的读写，并修复double读写的bug。</item>
                        <item>Modbus虚拟服务器代码重构实现，继承自NetworkDataServerBase类。</item>
                        <item>新增韩国品牌LS的Fast Enet协议</item>
                        <item>新增韩国品牌LS的Cnet协议</item>
                        <item>新增三菱mc协议的虚拟服务器，仅支持二进制格式的机制。</item>
                        <item>LogNet支持写入任意的字符串格式。</item>
                        <item>其他的注释添加及代码优化。</item>
                        <item>发布官方论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-9" version="6.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复三菱读写PLC位时的bug。</item>
                        <item>修复Modbus读写线圈及离散的变量bug。</item>
                        <item>强烈建议更新，不能使用6.2.0版本！或是回退更低的版本。</item>
                        <item>有问题先上论坛： http://bbs.hslcommunication.cn/ </item>
                    </list>
                </revision>
                <revision date="2019-5-10" version="6.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复上个版本modbus的致命bug，已通过单元测试。</item>
                        <item>新增松下的mc协议，demo已经新增，等待测试。</item>
                        <item>github源代码里的支持的型号需要大家一起完善。</item>
                    </list>
                </revision>
                <revision date="2019-5-31" version="6.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Ls的Fast Enet协议问题修复，感谢来自埃及朋友。</item>
                        <item>Ls的CEnet协议问题修复，感谢来自埃及朋友。</item>
                        <item>Ls新增虚拟的PLC服务器，感谢来自埃及朋友。</item>
                        <item>改进了机器码获取的方法，获取实际的硬盘串号。</item>
                        <item>日志的等级为None的情况，不再格式化字符串，原生写入日志。</item>
                        <item>IReadWriteNet接口测试西门子的写入，没有问题。</item>
                        <term>三菱及松下，基恩士的地址都调整为最大20亿长度，实际取决于PLC本身。</term>
                        <item>松下MC协议修复LD数据库的读写bug。</item>
                        <item>Redis的DEMO界面新增删除key功能。</item>
                    </list>
                </revision>
                <revision date="2019-6-3" version="6.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Redis新增读取服务器的时间接口，可用于客户端的时间同步。</item>
                    </list>
                </revision>
                <revision date="2019-6-6" version="6.2.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>西门子的SiemensS7Net类当读取PLC配置长度的DB块数据时，将提示错误信息。</item>
                    </list>
                </revision>
                <revision date="2019-6-22 " version="7.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>新增安川机器人通信类，未测试。</item>
                        <item>西门子的多地址读取的长度不再限制为19个，而是无限制个。</item>
                        <item>NetworkDoubleBase: 实现IDispose接口，方便手动释放资源。</item>
                        <item>SerialBase: 实现IDispose接口，方便手动释放资源。</item>
                        <item>NetSimplifyClient:新增一个async...await方法。</item>
                        <item>NetSimplifyClient:新增读取字符串数组。</item>
                        <item>ModbusServer:新增支持账户密码登录，用于构建安全的服务器，仅支持hsl组件的modbus安全访问。</item>
                        <item>NetSimplifyServer:新增支持账户密码登录。</item>
                        <item>新增永宏PLC的编程口协议。</item>
                        <item>新增富士PLC的串口通信，未测试。</item>
                        <item>新增欧姆龙PLC的CIP协议通讯。</item>
                        <item>初步添加OpenProtocol协议，还未完成，为测试。</item>
                        <item>MelsecMcNet:字单位的批量读取长度突破960长度的限制，支持读取任意长度。</item>
                        <item>MelsecMcAsciiNet:字单位的批量读取长度突破480长度的限制，支持读取任意长度。</item>
                        <item>AllenBradleyNet:读取地址优化，支持读取数组任意起始位置，任意长度，支持结构体嵌套读取。</item>
                        <item>其他大量的代码细节优化。</item>
                    </list>
                </revision>
                <revision date="2019-6-25" version="7.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>IReadWriteNet完善几个忘记添加的Write不同类型参数的重载方法。</item>
                        <item>IReadWriteNet新增ReadBool方法，Write(string address, bool value)方法，是否支持操作需要看plc是否支持，不支持返回操作不支持的错误。</item>
                        <item>OmronFinsNet:新增一个属性，IsChangeSA1AfterReadFailed，当设置为True时，通信失败后，就会自动修改SA1的值，这样就能快速链接上PLC了。</item>
                        <item>OmronFinsNet:新增读写E区的能力，地址示例E0.0，EF.100，E12.200。</item>
                        <item>新增HslDeviceAddress特性类，现在支持直接基于对象的读写操作，提供了一种更加便捷的读写数据的机制，详细的关注后续的论坛。</item>
                    </list>
                </revision>
                <revision date="2019-9-10" version="8.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>SimpleHybirdLock: 简单混合锁的性能优化，基元对象采用懒加载的机制实现，同时增加了高级混合锁的类，支持自旋，线程拥有权，在高竞争的情况下性能大幅增加。</item>
                        <item>NetSoftUpdateServer: 软件自动更新的服务器端支持传送指定目录下的文件及其子文件夹下的所有文件内容，都将更新到客户端的电脑上去。</item>
                        <item>AllenBradleyNet: 修复字符串的读写bug，支持读写任意长度的字符串信息。</item>
                        <item>MelsecFxSerial: 三菱编程口协议支持读写D1024以上地址的数据，感谢 厦门-Mr.T 的贡献。</item>
                        <item>PIDHelper: 新增一个Pid的辅助类，用于模拟pid的波形情况。</item>
                        <item>NetPushClient: 修改一个时间的注释，追加单位信息，时间的单位是毫秒。</item>
                        <item>XGBFastEnet: 感谢埃及的朋友，修复了一些bug信息。</item>
                        <item>MelsecFxSerialOverTcp: 新增基于网口透传的三菱的编程口通讯类。</item>
                        <item>MelsecFxLinksOverTcp: 新增基于网口透传的三菱的计算机链接协议的通讯类。</item>
                        <item>MelsecA3CNet1OverTcp: 新增基于网口透传的三菱的A-3C的协议的通讯类。</item>
                        <item>OmronHostLinkOverTcp: 新增基于网口透传的欧姆龙的hostLink协议的通讯类。</item>
                        <item>PanasonicMewtocolOverTcp: 新增基于网口透传的松下的Mewtocol协议的通讯类。</item>
                        <item>SiemensPPIOverTcp: 新增基于网口透传的西门子PPi协议的通讯类。</item>
                        <item>XGBCnetOverTcp: 新增基于网口透传的Lsis的XGBCnet协议的通讯类。</item>
                        <item>KeyenceNanoSerialOverTcp: 新增基于网口透传的基恩士的NanoSerial串口协议的通讯类。</item>
                        <item>FujiSPBOverTcp: 新增基于网口透传的富士的SPB串口协议的通讯类。</item>
                        <term>FatekProgramOverTcp: 新增基于网口透传的永宏plc的串口协议的通讯类。</term>
                        <item>ModbusRtuOverTcp: 新增基于网口透传的Modbus rtu协议的通讯类。</item>
                        <item>Modbus相关的功能类进行代码精简，重构，优化，api标准化为ReadBool,WriteBool,Read,Write，移除了一些特殊的方法api，本次升级不兼容。</item>
                        <item>FFTFilter: 新增一个基于FFT（快速离散傅立叶变换）的滤波功能，可以作为一个高级的曲线拟合方案，详细参照demo，感谢 北京-monk 网友的支持。</item>
                        <item>KnxUdp: 新增一个KnxUdp的数据通讯类，感谢上海-null的支持。</item>
                        <item>ABBWebApiClient: 新增ABB机器人的基于web api的访问机制的通讯类。</item>
                        <item>SickIcrTcpServer: 新增一个sick的条码读取类，支持被动连接，主动连接，经过测试，同时支持海康，基恩士，DATELOGIC扫码器。</item>
                        <item>Demo: Demo工具新增了一个基于tcp的服务器的测试界面。</item>
                        <item>本组件从v8.0.0开始进入付费模式，谨慎升级，未激活的将只能使用8小时，普通vip群发放激活码，仅支持个人用途使用，禁止破解，感谢对正版的支持。</item>
                        <item>个人商业用途及源代码需要申请加入超级vip群，群号：189972948，入群费：2400rmb。时间为无期限，永久支持，不限制项目数量。</item>
                        <item>企业商业用途需要加入超级vip群，群号：189972948，入群费：5000rmb，商业授权为10年，期间开放源代码，不限制开发人数，项目数量，企业logo在将官网展示。</item>
                        <item>今天是2019年9月10日，祝天下所有的教师节日快乐。</item>
                    </list>
                </revision>
                <revision date="2019-9-17" version="8.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>所有网口透传类对象完善实例化的方法，都新增一个指定ip及端口的实例方法。</item>
                        <item>ABBWebClient: 完善实例化方法，修改ToString的格式化内容，提炼了webapi的基类，开放ip地址和端口。</item>
                        <item>ABBWebClient: 新增提供了机器人自身IO，扩展IO，最新的报警日志的数据读取API。</item>
                        <item>NetSimplifyClient: 修复了当ReceiveTimeOut小于0，但是实际接收时会发生奔溃的bug。</item>
                        <item>NetPlainSocket: 新增一个基于socket的明文的网络发送和接收类，采用事件驱动的机制。</item>
                        <item>LogNet: 日志类对象新增一个特性，当日志的文件名设置为空的时候，将不会创建文件，仅仅触发 BeforSaveToFile 事件，方便日志显示。</item>
                        <item>XGBCnet: Lsis的plc的串口类修复一个bug，感谢埃及朋友的贡献。</item>
                        <item>SoftIncrementCount: 消息号自增类新增一个方法，重置当前的消息号。</item>
                        <item>PanasonicMewtocol: 修复松下的串口类读写单个bool时异常的bug，地址支持字+位的表示方式，R33=R2.1，方便大家输入测试。</item>
                        <item>MqttClient: 新增一个Mqtt协议的客户端类，支持用户名密码，支持发布，支持订阅，支持重连，欢迎一起测试。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-9-19" version="8.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ABBWebClient: abb机器人的api读取日志的接口新增一个参数，读取最近的日志数量。默认为10条。</item>
                        <item>MQTTClient: 修复mqtt客户端类的消息重复bug，修复发送空订阅的bug。</item>
                        <item>SiemensS7Net: 西门子的s7协议的类新增一个api，支持时间的读写，支持异步，时间格式和s7net一致。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-9-26" version="8.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase: 修复套接字网络授权失败时不关闭网络的bug。</item>
                        <item>SoftBasic: 新增一个数组数据格式化的方法信息。</item>
                        <item>MqttServer: 新增一个mqtt的服务器，初步支持订阅，发布订阅，强制发布订阅，在线客户端数量功能等等。</item>
                        <item>Demo: 所有的PLC的demo和modbus协议的demo，支持批量读取各种类型的数组数据。</item>
                        <item>Nuget: 新增本项目的图标，在nuget上搜索时会显示图标。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-7" version="8.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>ModbusUdp: 新增一个Modbus的基于udp的协议类，使用的tcp的报文的机制。</item>
                        <item>HttpServer: 新增一个http的服务器封装类，方便实现基于webapi的后台功能，集成GET，POST的接口操作。</item>
                        <item>Serial Ports: standard项目依赖官方串口库，实现所有的设备的串口支持，可应用于跨平台。</item>
                        <item>standard: 在nuget上提供.net standard2.1版本的库。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-11" version="8.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，修复了一些bug，支持了bool的操作。</item>
                        <item>Redis: 新增db块属性设置，修复短连接下切换db块无效的bug，因为db块是跟随连接的。</item>
                        <item>MQTT: 修复客户端和服务器的长度计算bug，支持和其他mqtt组件混合使用。</item>
                        <item>MQTT Demo: 优化demo功能，支持文本追加或是覆盖选择，文本格式化查看选择。</item>
                        <item>Http Server: 支持跨域属性选择，编码统一为utf-8，兼容浏览器和postman，demo中增加返回类型示例。</item>
                        <item>Modbus server及Lsis Server: 针对.net standard版本，开放串口。</item>
                        <item>个人商用认定调整，个人用户在一个自然年里所有使用本组件的项目销售总额小于3000元整的不算个人商用，获得激活码即可。</item>
                        <item>企业商用的使用年限及开放源代码年限调整为20年，感谢所有付费用户的支持。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-16" version="8.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，demo增加了bool操作。</item>
                        <item>Knx驱动：增加测试demo，完善驱动，测试通过，有需要的朋友可以查看信息。</item>
                        <item>IntegrationFileClient: 完善文件的收发类，新增重载的构造方法，传入ip地址及端口即可。</item>
                        <item>melsec: 三菱的MC协议部分错误代码关联了文本信息，在测试的时候即可弹出错误信息，方便排查，常见了已经绑定。</item>
                        <item>melsec: 新增3e协议的随机字批量读取操作，支持跨地址，跨数据类型混合交叉读取，一次即可读完。</item>
                        <item>fileserver: 修复linux下的bug，新增上传文件后的触发事件，将文件的信息都传递给调用者。</item>
                        <item>SiemensMpi: 添加MPI协议，并完善demo，等待测试。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-10-24" version="8.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>Lsis: 感谢埃及朋友的支持，demo完善了cpu类型的选择。</item>
                        <item>LogNet:新增移除关键字的接口方法，修复linux运行路径解析的bug，完善api文档的示例代码。</item>
                        <item>大量的细节优化，变量名称单次拼写错误的修复。</item>
                        <item>Modbus: 当地址为x=3;100时，读正常，写入异常的问题修复，功能码自动替换为0x10。</item>
                        <item>FileNet: 修复高并发下载时的下载异常的问题，调整指令头的超时时间。</item>
                        <item>AB plc: 公开一个新的api接口，运行配置一些比较高级的数据。</item>
                        <item>接下来计划：1.完善hsl的demo，api文档，准备基础的入门视频；2.开始完善java版本的代码，java版本只对超级VIP群开放。</item>
                        <item>本组件从v8.0.0开始进入付费授权模式，详细参考官方：http://www.hslcommunication.cn 。</item>
                    </list>
                </revision>
                <revision date="2019-12-3" version="8.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>三菱的MC协议支持读取SM和SD，特殊连接继电器，特殊寄存器。</item>
                        <item>PushNet优化相关代码。</item>
                        <item>MelsecMcUdp: 新增三菱的MC协议的UDP通讯类。</item>
                        <item>MelsecMcAsciiUdp: 新增三菱的MC协议的ASCII格式的UDP通讯类。</item>
                        <item>MelsecMcServer: 三菱的虚拟服务器修复数据存储加载的bug。</item>
                        <item>Serial: 串口的基类公开了一个Rts属性，用于某些串口无法读取的设备的情况。</item>
                        <item>OmronFinsServer: 新增欧姆龙的虚拟plc，支持和hsl自身的通讯，支持cio，h区，ar区，d区的通信，不支持E区。</item>
                        <item>AllenBradleyServer: 新增ab plc的虚拟plc，支持和hsl的自身的通讯，在demo里预设了4个变量值。不支持结构体和二维及以上数组读写。</item>
                        <item>Aline: 异形的服务器对象新增一个设置属性，是否反馈注册结果，默认为True。</item>
                        <item>SoftBasic: 数组格式化操作新增格式化的字符串说明。</item>
                        <item>Modbus: 调整Write( string address, bool value )采用05功能码写入，而参数为bool[]的话，采用0F功能码。</item>
                        <item>Modbus: 提供WriteOneRegister方法，写入单个的寄存器，使用06功能码。</item>
                        <item>LogNet: 日志在实例化的时候，添加对当前设置的目录的是否存在的检查，如果不存在，则自动创建目录。</item>
                        <item>Python: 大量代码更新，新增了一个欧姆龙的fins-tcp通信。</item>
                        <item>Java: 大量代码更新，新增了一个AB plc的读写类。</item>
                        <item>付费调整,，从2019年12月5日起，个人永久授权，2500rmb；企业永久授权：6500rmb，感谢支持，原先已经签合同的以合同价格为准。个人和企业均需签合同。是否含有商用权利以合同为准。</item>
                    </list>
                </revision>
                <revision date="2019-12-11" version="8.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Cip协议：cip协议开放Eip指令自定义输入，优化指令生成算法。</item>
                        <item>Cip协议：Write(string address, byte[] data)方法提示使用WriteTag信息。</item>
                        <item>NetworkDoubleBase: 修复bool异步读写提示不支持的bug，现在可以使用异步了。</item>
                        <item>SAMSerial：新增身份证阅读器的串口协议，支持读取身份证信息，头像信息还未解密。</item>
                        <item>SAMTcpNet：新增身份证阅读器的串口透传协议，支持读取身份证信息，头像信息还未解密。</item>
                        <item>BeckhoffAdsNet：新增倍福plc的协议，还未通过测试。</item>
                    </list>
                </revision>
                <revision date="2020-1-3" version="8.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>lsis的plc优化，感谢埃及朋友的提供的技术支持。</item>
                        <item>Panasonic: 松下的Mewtocol协议增加SR区的支持，解析地址的方法修改为Public，方便外面调用。</item>
                        <item>Panasonic: 松下的Mewtocol协议批量读取bool方法是按字为单位，读取长度按照位为单位，地址写Y0，Y1，不能写Y0.4。</item>
                        <item>ab-plc: 虚拟服务器修复上个版本造成的bug，导致读写数据成功，但是数据实际没有更改。</item>
                        <item>ab-plc: 支持超长的数组读取，可以一次性读取任意长度的数组内容，不再需要手动切片。</item>
                        <item>ab-plc: 新增一个api接口，可以遍历所有的ab-plc的变量名称。</item>
                        <item>beckoff: 倍福的plc通信通过测试，需要设置正确各种网络号才可以，优化了标签缓存。</item>
                        <item>java: java版本的ab-plc类优化，支持超长的数组读取。</item>
                        <item>python: python版本的代码新增ab-plc的读取类。</item>
                        <item>demo: 安卓的demo增加lsis，mqtt协议的界面。</item>
                        <item>Melsec: 三菱PLC的多块批量读取目前只支持字地址，后续继续优化。</item>
                        <item>其他的代码优化和重构。</item>
                        <item>java版本的源代码及demo，python版本的源代码及demo仅对商业授权用户开放，谢谢支持。</item>
                        <item>作者于2020年1月5日和王女士结婚，地址是浙江省金华市兰溪市马涧镇，欢迎有空的老铁们来坐坐，带红包就行。</item>
                    </list>
                </revision>
                <revision date="2020-2-13" version="9.0.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>宣布V9版本脱胎换骨，浴火重生，C#版本的组件库底层网络大幅重构，删除一直以来的伪异步，原先的通过改为纯同步，并从底层提供完整的异步方法。</item>
                        <item>注意：不兼容升级，影响范围，MQTT协议的事件，网络的同步设置，西门子的PPI协议取消WriteByte方法，改为和其他一样的Write(string address,byte value)重载了，升级请谨慎测试。</item>
                        <item>所有的PLC通讯类，机器人类通讯类，Modbus通讯类，身份证类，包括 IReadWriteNet 接口都实现了异步的操作，针对NET45以上及Standard平台。</item>
                        <item>MQTT协议修改触发的消息事件，返回session信息，支持自定义返回数据信息，支持当前消息的发布拦截操作，服务器主送发布的消息支持是否驻留，默认主题驻留。</item>
                        <item>新增websocket协议的服务器，客户端，问答客户端。支持直接从C#的后台发送数据到网页前端，支持订阅操作。详细见demo的操作。</item>
                        <item>ComplexNet,SimplifyNet,PushNet,FileNet这几个网络引擎代码优化，初步测试OK。</item>
                        <item>SoftBasic: 新增方法SpliceStringArray，用来合并字符串信息。增加了ByteToHexString的空校验。</item>
                        <item>HttpServer: 异步优化，修复读取数据时可能长度不足的bug。</item>
                        <item>YRC1000: 安川机器人修改无法读取的bug，目前已经测试通过，感谢网友的支持。</item>
                        <item>Java: 修复ab-plc读取失败的错误信息，原因来自一个强制转换失败的错误。</item>
                        <item>本版本改动较多，尽管我已经仔细测试过，但是仍然不可避免存在一些bug，欢迎大家使用，测试，有问题可以报告给我，相信hsl组件会变的更加强大。</item>
                        <item>本版本依然是商业授权的，如果需要测试，可以付费240rmb，加入vip群，可以将hsl用于测试环境和研究学术用途，欢迎大家加我的支付宝好友，hsl200909@163.com </item>
                        <item>加油，武汉！加油，中国！疫情之后，无人自动化工厂将会获得更大的关注和发展，我辈当自强。</item>
                    </list>
                </revision>
                <revision date="2020-2-19" version="9.0.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>底层的网络在对方关闭连接后，不再等待接收，直接返回对方已关闭的错误信息，提供通信的性能。</item>
                        <item>四个服务器类，complexserver, simplifyserver,mqttserver,websocketserver开发关闭客户端连接的方法，调用者可以手动操作关闭。</item>
                        <item>MQTT服务器新增一个客户端上线事件，包含客户端的会话参数，方便实现一些特殊的场景需求，在api文档中增加调用示例。</item>
                        <item>Websocket服务器新增一个客户端上线事件，包含客户端的会话参数，方便实现一些特殊的场景需求。</item>
                        <item>Websocket服务器添加0x0A的心跳返回，用于有些客户端的心跳验证操作。</item>
                        <item>RedisClient: redis相关的代码优化，调整，添加了异步api接口，本机性能测试不如同步，有待优化。</item>
                        <item>RedisClient: 新增基于特性的读写，自动组合键批量读取，组合哈希键批量读取操作，提升性能，详细参考api文档。写入操作不支持列表相关的特性。</item>
                        <item>Demo的写入byte操作的反射代码获取失败的bug修复。</item>
                    </list>
                </revision>
                <revision date="2020-2-25" version="9.0.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复websocket对某些浏览器的请求验证失败的bug，改为正则表达式验证，适用的范围更加广阔。</item>
                        <item>三菱的mc协议的错误信息更加明确化，将提供更加确切的错误描述，方便大家查找错误。</item>
                        <item>websocket客户端新增连接服务器成功的事件，方便实现类似订阅的功能。</item>
                        <item>Websocket服务器添加心跳检测功能，将会定期（可以自定义）发送心跳包给客户端，在检测客户端是否在线。</item>
                        <item>文件的服务器和客户端开放文件缓存大小的属性，默认100K，越大的话，性能越高，越占内存。</item>
                        <item>Modbus协议功能调整，Write(string,short)和Write(string,ushort)功能码调整为06，如果需要0x10功能码，使用Write(string,short[])和Write(string,ushort[])</item>
                        <item>新增汇川PLC的通讯类，基于modbus协议，但是实现了地址的自动解析，输入D100即可自动转为modbus的地址，包含AM系列，H3U系列，H5U系列等</item>
                        <item>在示例文档中，新增大量的代码说明，完善注释，如果有任何的问题，优先参考api文档。</item>
                        <item>官网新增一个来自上海亦仕智能科技有限公司 MES DEMO： http://111.229.255.209 账号SF  密码 123 </item>
                    </list>
                </revision>
                <revision date="2020-3-3" version="9.0.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>修复汇川PLC的地址示例文档写错的bug。</item>
                        <item>IReadWriteNet标准化字符串读写操作，新增定制编码的字符串读写。netDeviceBase移除之前的writeunicode的方法。这点如果有使用，谨慎更新。</item>
                        <item>串口基类和UDP基类的数据交互方法新增日志记录，对发送的数据和接收的数据写入debug等级的日志。</item>
                        <item>数据服务器（主要是三菱虚拟plc，西门子虚拟plc，modbus服务器等）实现IReadWriteNet接口。</item>
                        <item>关于ab-plc，新增MicroCip协议，适用于Micro800系列读写操作。</item>
                        <item>关于序号生成器类SoftIncrement，重置最大值的方法名称更新，添加了重置当前值，重置初始值，支持反向序列，跳跃序列的功能，详细参考api文档。</item>
                        <item>文件的服务器类，新增一些日志记录，关于文件何时被读取，何时读取结束的日志信息，等级为debug。</item>
                        <item>NuGet组件更新，json组件更新到12.0.3版本，IO.port更新到4.7.0版本。单元测试框架更新。</item>
                        <item>Demo的redis示例，支持不同的db块选择，当你选择数据后自动切换，键值类数据增加格式化显示。</item>
                        <item>NetworkBase: 网络基类的连接服务器改为如果连接立即失败(500ms内)，将会休眠100ms后，立即再尝试一次，提高连接的成功率。影响范围为所有客户端类。</item>
                        <item>三菱二进制MC协议：地址里面新增标签访问，缓冲存储器访问，扩展的地址访问的方式，目前开放二进制的mc协议，欢迎测试，顺利的话，完善写入和ascii格式的。</item>
                        <item>大量的代码注释添加，主流的常用的代码添加中英文注释，后续逐步全都改为中英文，方便国外客户阅读。</item>
                        <item>240元的普通vip群的激活码时间调整，改为20年，中间软件重启一次，就又是20年，感谢大家的理解和支持。</item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                    </list>
                </revision>
                <revision date="2020-3-15" version="9.1.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>MQTT: 服务器增加定时检测客户端在线情况，超过设置的时间不活跃，强制下线，开放OnlineSession属性，获取在线客户端，查看ip，端口，在线时间等信息。</item>
                        <item>WebSocket: 服务器开放OnlineSession属性，获取在线客户端，查看ip，端口，在线时间等信息。</item>
                        <item>Language: 组件的语言系统修复设置英文后，无法切换回中文的bug。</item>
                        <item>SoftBasic: 添加SpliceByteArray(params byte[][] bytes)方法，用来将任意个byte[]进行拼接成一个byte[]。</item>
                        <item>SoftBasic: 添加BoolOnByteIndex方法，用来获取byte数据的指定位的bool值。</item>
                        <item>Panasonic: 松下的mc地址和串口地址统一表示方式：R101=R10.1=[10*16+1]，R10.F=R10.15(这两种表示方式都可以)</item>
                        <item>发布基于HSL扩展组件HslCppExtension，将写入的重载方法名按照类型重写一遍，方便C++调用。</item>
                        <item>VC++的demo示例，新增写入数据的例子，基于扩展组件HslCppExtension实现，详细参照demo源代码。</item>
                        <item>SoftBasic: 针对byte数组的切割，选择头，尾，中间，移除头，尾的方法全部更改成泛型版本，方法名字已经变更，如果有调用，谨慎更新。</item>
                        <item>FanucInterfaceNet: 新增读取fanuc机器人的通讯类，支持读写任意地址数据的功能，详细参考api文档，写入操作谨慎测试。</item>
                        <item>FanucRobotServer: 新增fanuc机器人的虚拟服务器，方便进行测试，初始数据来自真实机器人，支持D,I,Q,AI,AQ,M数据区。</item>
                        <item>Fanuc: 目前测试通过的型号为R-30iB mate plus，其他型号暂时不清楚支持范围。</item>
                        <item>代码注释优化，api文档大量的更新，添加一些示例代码，包含如果检测状态，长短连接，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>三年磨一剑，直插工业互联网的心脏。软件开发之艰辛，如人饮水冷暖自知。感谢所有支持的朋友。</item>
                    </list>
                </revision>
                <revision date="2020-3-22" version="9.1.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>feat(SAM): 身份证阅读器修复在某些状态下接受数据不完整的bug，将校验数据的完整性。</item>
                        <item>feat(ab-plc): 虚拟服务器的地址支持小数点的形式，支持单个的bool读写，支持string的读写操作，和客户端的体验一致。</item>
                        <item>feat(softbasic): 方法针对数组切割的方法，增加扩展方法支持，byte[] a; byte[] b= a.RemoveBegin(2);意思就是移除最前面的2个元素。</item>
                        <item>feat(softbasic): Hex字符串和byte[]的转化也支持扩展方法。byte[] a.ToHexString()。</item>
                        <item>feat(melsec): 三菱的a-1e协议之前的，x,y地址采用8进制，先修改为自定义，如果要八进制，地址前面加0，例如X017，如果不加就是十六进制，例如X17，默认十六进制，升级需注意。</item>
                        <item>feat(melsec): 三菱的a-1e协议增加了F报警继电器，B链接继电器，W链接寄存器，定时器和计数器的线圈，触点，当前值的读取，地址参见api文档说明。</item>
                        <item>feat(melsec): 添加a-1e协议的ASCII版本，地址格式和二进制版本是一致的，支持的地址类型也是一致的，还未仔细测试，欢迎老铁们测试。</item>
                        <item>feat(melsec): 三菱的mc虚拟服务器支持二进制和ascii，实例化的时候选择，支持和HSL组件自身的通讯。</item>
                        <item>lsis: cnet和fenet地址的解析bug修复，感谢埃及朋友的支持。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业授权费：8000元，感谢老铁们询价，介绍人给与奖励。</item>
                    </list>
                </revision>
                <revision date="2020-3-29" version="9.1.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>ModbusAscii: 修复和rtu指令转换时的bug，之前会发生读写失败，目前已经在台达PLC上测试通过。</item>
                        <item>MelsecA1EAscii：修复三菱的A1E协议的ascii格式类写入单个bool异常的bug。</item>
                        <item>NetworkUdpServerBase：新增基于UDP协议的服务器基类，后台线程循环接收数据实现。</item>
                        <item>CipServer: 虚拟的ab-plc服务器新增字符串数组对象的读写操作，demo相关的完善。</item>
                        <item>HyundaiUdpNet: 新增现代机器人的姿态跟踪网络通讯类，</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业授权费：8000元，感谢老铁们询价，介绍人给与奖励。</item>
                    </list>
                </revision>
                <revision date="2020-4-6" version="9.1.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>HslExtension: 完善一些转化的api，方便数组和字符串转化，完善对象转JSON字符串。</item>
                        <item>LogNet：消息格式化文本的消息等级追随HSL的语言设定，如果是中文，就显示调试，信息，警告，错误，致命。</item>
                        <item>Redis: 修复ExpireKey，生存时间参数丢失的bug，完善了说明文档。</item>
                        <item>OmronCip: 欧姆龙的CIP协议的类库，修复数组读取的bug，修复字符串写入bug，字符串写入还需要测试。</item>
                        <item>Toledo：新增托利多电子秤的串口类及网口服务器类，方便接收标准的数据流，等待测试。</item>
                        <item>Java：增加了单元测试的内容，对一些已经完成的类添加单元测试。</item>
                        <item>Python：实现了python版本的HslCommunication程序，基于pyqt实现，初步添加了一些PLC的调试界面。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元。</item>
                    </list>
                </revision>
                <revision date="2020-4-20" version="9.1.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>ServerBase: 服务器对象基类完善客户端下线逻辑，精简相关的代码。</item>
                        <item>LogNet：设备网络通讯类及串口类在数据收发的时候增加日志的记录，可以设置PLC类的LogNet属性抓取相关的报文信息。</item>
                        <item>ModbusServer: Modbus服务器同时支持TCP,RTU,ASCII，其中RTU和ASCII共用一个串口，根据报文头是否为冒号区分。</item>
                        <item>ModbusAscii: 修复通讯的bug，已通过单元测试，支持和ModbusServer完美通讯，欢迎网友继续测试。</item>
                        <item>MelsecMcNet：三菱MC协议的数据地址新增对SB，SW，特殊链接继电器，寄存器的支持。</item>
                        <item>SiemensServer: 西门子S7虚拟服务器的DB块支持DB1.X，DB2.X，DB3.X，3以上的db块都是使用同一个的DB块。</item>
                        <item>HttpServer：自定义轻量级的WebApi服务器支持反射对象的方法名，简化定义API时定义大量的if...else...。</item>
                        <item>UdpNet：添加ConnectionId属性，使用的<seealso cref="M:HslCommunication.BasicFramework.SoftBasic.GetUniqueStringByGuidAndRandom"/>方法获取信息。</item>
                        <item>MelsecMcRNet：添加三菱R系列的MC协议二进制的实现，和标准的有一点区别，地址支持也不一样，欢迎测试Demo。</item>
                        <item>OmronCip：欧姆龙的读写数组已经测试通过，修改了读写字符串的逻辑实现，等待测试。</item>
                        <item>代码注释优化，使用前请仔细阅读下面的信息：http://api.hslcommunication.cn </item>
                        <item>http://www.hslcommunication.cn/MesDemo 官网的地址以后作为优秀的MES产品展示平台，欢迎大家关注。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元。</item>
                    </list>
                </revision>
                <revision date="2020-4-28" version="9.2.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>HttpServer: 当客户端发起request请求的时候，在日志记录的时候记录当前的请求的方式，GET,POST,OPTION等等。</item>
                        <item>MQTT: mqtt的消息等级追加一个新的等级，为OnlyTransfer等级，用来表示只发送服务器，不触发发布操作。</item>
                        <item>MqttServer: 配合Qos等级为OnlyTransfer时，进行相关的适配操作，并触发消息接收的事件。</item>
                        <item>MqttSyncClient: 新增MQTT的同步访问的客户端，协议头标记为HUSL，向HSL的mqtt服务器进行数据请求并等待反馈。尚未添加心跳程序。</item>
                        <item>MqttServer: 适配同步客户端实现功能，当客户端为同步客户端的时候，调试心跳验证。</item>
                        <item>至此，HSL的MQTT协议已经是兼容几大网络功能了，在线客户端管理，消息发布订阅，消息普通收发，同步网络访问。</item>
                        <item>IByteTransform接口属性新增IsStringReverseByteWord，相当于从ReverseByWord挪过来了，默认为false，如果为true，在解析字符串的时候将两两字节颠倒。</item>
                        <item>Omron: 欧姆的fins-tcp及fins-udp及hostlink的IByteTransform接口IsStringReverseByteWord调整为true默认颠倒。</item>
                        <item>SerialBase: 串口基类的打开串口方法调整返回类型OperateResult，在串口数据读取之前增加打开串口的Open方法，串口类也只需要一直读就可以了。</item>
                        <item>NetworkDoubleBase, SerialDeviceBase, NetworkUdpDeviceBase及相关的继承类，对所有的泛型进行了擦除，一律采用接口实现，之后将统一java,python代码。</item>
                        <item>FreedomTcp,FreedomUdp,FreeSerial: 添加基于自由协议的tcp，udp，串口协议，可以自由配置IByteTransform接口，可用来读取一些不常见的协议。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>SiemensS7: 单次读取之前是按照200字节进行拆分的，现在根据s7协议返回的报文来自动调整，1200系列是220字节，1500系列是920字节，其他等待测试。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-5-6" version="9.2.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Toledo: 托利多电子秤的字节触发的时候，传递出来携带原始的字节数组，方便自行处理，Demo界面优化，显示信息更加完善。</item>
                        <item>Lsis: Lsis的PLC通信类修复一些bug，感谢埃及朋友的提供的技术支持。</item>
                        <item>MqttSyncClient: 新增ReadString方法，以字符串的形式来和服务器交互，默认编码UTF8，当然也可以自己指定编码，本质还是读取字节数据。</item>
                        <item>WebsocketClient: websocket的客户端类，重新设计异常重连，网络异常时触发 OnNetworkError 事件，用户应该捕获事件，然后在事件里重连服务器，直到成功为止。</item>
                        <item>MqttClient: Mqtt客户端类，重新设计异常重连，网络异常时触发 OnNetworkError 事件，用户应该捕获事件，然后在事件里重连服务器，直到成功为止。</item>
                        <item>MqttSyncClient: 支持读取数据的进度回调功能，支持三种进度报告，数据上传到服务器的进度报告，服务器处理进度报告，数据返回到客户端的进度报告。</item>
                        <item>PanasonicMewtocol: 修复注释错误，L区的数据也可以进行L100F，L2.3访问。</item>
                        <item>DLT645: 初步添加电力规约协议的串口实现，目前只实现了读取数据，还未测试，等待后续的测试完善。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-5-11" version="9.2.2" author="Richard.Hu">
                    <list type="bullet">
                        <item>MqttClient: 上个版本开放的网络错误事件，如果不进行事件绑定，增加默认实现，每隔10秒去连接服务器，直到成功为止。</item>
                        <item>WebsocketClient: 上个版本开放的网络错误事件，如果不进行事件绑定，增加默认实现，每隔10秒去连接服务器，直到成功为止。</item>
                        <item>DLT645: 电力规约协议完善，等待后续的测试完善。</item>
                        <item>SerialBase: ReadBase提供一个重载的方法，ReadBase( byte[] send, bool sendOnly )支持单向发送，不接收数据返回。</item>
                        <item>SoftBasic: HexStringToBytes算法优化，性能提升，移除了转大写字母的步骤。</item>
                        <item>SiemensS7: 开放获取 pdu 数据长度属性，属性名称：PDULength</item>
                        <item>HslExtension: 增加IncreaseBy方法，但是测试发现不适用byte类型。</item>
                        <item>Omron-cip: 读写字符串仍然没有测试通过，请暂时不要调用。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-5-21" version="9.2.3" author="Richard.Hu">
                    <list type="bullet">
                        <item>IReadWriteNet接口新增一个属性，ConnectionId，用来表示设备的唯一ID。</item>
                        <item>ModbusTcpServer: Modbus的虚拟服务器支持0x16功能码，支持掩码写入操作，适用Tcp,Rtu,Ascii。</item>
                        <item>Modbus客户端(tcp+rtu+ascii+rtuovertcp) 新增掩码写入方法，WriteMask，bool写入时，假如Write("100.1", true)就使用掩码写入寄存器100的第1位为真。</item>
                        <item>RedisClient: redis的客户端新增Ping方法，DBSize方法获取key数量，FlushDB方法清除数据库所有key。</item>
                        <item>DTUServer: 新增一个DTU服务器，可以用来实现对plc的反向连接操作，根据设备的唯一号来识别。</item>
                        <item>Omron-cip: 读写字符串不成功的bug修复，已经测试通过。</item>
                        <item>WebsocketClient: 实例化时新增url的额外参数传递，("127.0.0.1", 1883, "/A/B?C=123456")，也可以使用"ws://127.0.0.1:1883/A/B?C=123456"。</item>
                        <item>WebsocketClient: 修复未连接服务器的时候，调用关闭方法将会引发发送异常的bug。</item>
                        <item>MqttServer: 修复NET35版本不支持同步访问的bug，新增一个客户端断开连接的事件，OnClientDisConnected事件。</item>
                        <item>VibrationSensor: 新增一个震动传感器的类，型号为苏州捷杰震动传感器VB31，支持获取速度，加速度，位移，温度信息。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-5-29" version="9.2.4" author="Richard.Hu">
                    <list type="bullet">
                        <item>Mewtocol: 松下的串口协议修复LD寄存器无法访问的bug，输入LD100，如果只输入L100，就是线圈。</item>
                        <item>Modbus: 修复写入寄存器指定位bool失败的bug，写入true的掩码改为 FF FE，00 01</item>
                        <item>Modbus：在ModbusRtuOverTcp里填写掩码写入的api方法。</item>
                        <item>ab-plc：CIP协议解析标签地址的编码从ASCII编码修改为UTF-8编码，支持中文的标签名访问。</item>
                        <item>omron-plc：CIP协议解析标签地址的编码从ASCII编码修改为UTF-8编码，支持中文的标签名访问。</item>
                        <item>Websocket: 连接的请求标头修改为GET ws://127.0.0.1:8800/ HTTP/1.1  就是带IP地址及端口信息</item>
                        <item>Redis：Redis的客户端添加对集合和有序集合操作的相关API方法，基本支持了所有需要的操作信息，单元测试通过。</item>
                        <item>Demo: 所有DEMO写入数据操作，新增Hex写入，输入1A 1B等十六进制数据，然后底层调用Write(string, byte[])方法。</item>
                        <item>Demo：Redis的功能菜单新增一个测试界面，用来同步两个不同的redis的数据，也可以同一个redis不同的db块数据。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-6-10" version="9.2.5" author="Richard.Hu">
                    <list type="bullet">
                        <item>CipServer: Cip的虚拟服务器的数据节点编码修改为UTF8编码，增加了一些可读性比较强的增加节点的api，支持赋值初始化数据。</item>
                        <item>Demo: Kuka机器人的连接问题，请参考下面地址：http://blog.davidrobot.com/2019/03/hsl_for_kuka.html?tdsourcetag=s_pctim_aiomsg </item>
                        <item>Redis: 增加读取TTL的api方法，方便的获取剩余的生存时间。</item>
                        <item>HttpServer: 修复Response为空时进行AppendHeader时发生的bug，进行二次校验。</item>
                        <item>VibrationSensorClient: 修复deme站号设置失效的bug，站号根据接收的数据动态调整，增加检测长时间未接收传感器数据，就选择重连的功能。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-6-28" version="9.2.6" author="Richard.Hu">
                    <list type="bullet">
                        <item>NetworkBase: 同步网络通信的超时检查不再开新的线程检查，使用socket自带的ReceiveTimeout来检查。</item>
                        <item>NetworkBase: 发送数据时，增加对发送数据的空检查，如果为空，就认为成功。</item>
                        <item>RedisClient: 新增修改密码的API接口，可以进行对redis的密码重置操作。</item>
                        <item>MqttServer: 当同步客户端 MqttSyncClient连接上来时，不进行触发上下线事件。</item>
                        <item>MqttServer：原先支持获取所有的在线客户端，现在新增获取异步客户端列表，获取同步客户端列表。</item>
                        <item>MqttSubscribeMessage: 类型拼写错误修复，如果使用这个类，请谨慎升级。</item>
                        <item>Keyence: 基恩士的MC协议，支持CC，TC的数据类型读取。</item>
                        <item>FanucSeries0i: 新增一个fanuc机床的数据通讯类，支持读取一些简单的数据，目前在Series0i-F上测试通过。</item>
                        <item>Cip: 修复ab-plc的标签地址解析为UTF-8编码，但是长度确实字符串的bug，现在支持中文编码。</item>
                        <item>其他的注释优化</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-7-8" version="9.2.7" author="Richard.Hu">
                    <list type="bullet">
                        <item>MqttServer: 修复MQTT服务器开启时，当用其他的mqtt客户端订阅时，会发生异常的bug，原因在于订阅质量没有回传。</item>
                        <item>WebsocketServer: websocket的服务器端新增一个客户端下线的事件，无论是正常关闭还是异常关闭，都会触发事件。</item>
                        <item>MqttClient: Mqtt的客户端新增一个连接成功的事件OnClientConnected，重连成功后也会触发。在该事件的订阅topic会在网络恢复后重新订阅。</item>
                        <item>NetworkDoubleBase: 当校验指令头失败的时候，返回的错误信息里追加，收发的报文，方便查找问题。</item>
                        <item>MelsecA1EAsciiNet: 修复读取bool时，长度为奇数时，会出现交替失败的bug，原因出自数据粘包。</item>
                        <item>WebsocketClient: 添加一个IsClosed属性，修复服务器强制断线导致客户端无限重连的bug。</item>
                        <item>OmronConnectedCipNet: 添加一个基于连接的CIP的读写类，等待测试。</item>
                        <item>其他的注释优化</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-7-20" version="9.2.8" author="Richard.Hu">
                    <list type="bullet">
                        <item>KeyenceNanoSerial: 基恩士的串口协议重新实现，实现IReadWrite接口，增加了单元测试。支持的地址需要查阅API文档信息。</item>
                        <item>OmronHostLinkCMode: 支持了欧姆龙的HOSTLINK协议的Cmode模式的实现，初步单元测试通过，等待测试。</item>
                        <item>MC协议：三菱MC协议的ZR区的地址进制从16进制改为10进制。</item>
                        <item>NetworkDoubleBase: 添加一个PING的方法IpAddressPing( ), 对设备当前的IP地址进行PING操作。</item>
                        <item>NetworkUdpBase: 添加一个PING的方法IpAddressPing( ), 对设备当前的IP地址进行PING操作。</item>
                        <item>yamaha: 添加一个雅马哈机器人协议的实现，初步实现了几个api，等待测试，测试通过继续完善。</item>
                        <item>DEMO: 主界面增加一个全国使用情况的分布图，统计DEMO的使用次数实现。</item>
                        <item>官网的备案失效了，重新备案需要点时间，请访问 http://118.24.36.220 然后去顶部的菜单找相应的入口。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-8-3" version="9.3.0" author="Richard.Hu">
                    <list type="bullet">
                        <item>Networkbase：核心网络底层的错误码调整，当读写操作因为网络问题失败时，返回错误码为负数-1，如果连续读写失败，就一直递减。</item>
                        <item>OmronConnectedCipNet: 地址解析修改为全部上29 00 报文。</item>
                        <item>FileNet: 两种文件服务器支持删除多个文件和删除文件夹的所有文件功能，客户端同步适配，初步测试通过。</item>
                        <item>NetSimplifyClient: 新增一个构造方法，可以传入IPAddress类型的ip地址。</item>
                        <item>MqttSyncClient: 新增一个构造方法，可以传入IPAddress类型的ip地址。</item>
                        <item>MqttClient: 修复一个连接反馈信号，解析判断服务器状态错误的bug，该bug导致MqttClient连接不是中国移动的OneNet物联网框架。</item>
                        <item>FFT: 傅立叶变换FFTValue方法添加一个可选参数，是否二次开放，波形中的毛刺频段会更加明显。</item>
                        <item>HttpServer: webapi的服务器完善注释，添加一个端口号的属性，获取当前配置端口号信息。</item>
                        <item>Active: 当前库激活失效的时候，返回的错误消息，携带当前的通信对象的实例化个数，方便查找授权失败的原因。</item>
                        <item>Abb机器人：abb机器人支持读取程序执行状态，任务列表功能，伺服状态，机器人位置数据。</item>
                        <item>ABB虚拟机器人：新增一个abb机器人的虚拟webapi的服务器，可以用来测试和ABB客户端的通信。</item>
                        <item>Demo: 数据转换的界面，新增一个显示指定的文件的二进制的内容的功能。当demo激活成功时，不显示时间及授权信息。</item>
                        <item>新增一篇全新的博文，介绍基于HSL的大一统网络架构实现，满足发布订阅，一对多通信，webapi等：https://www.cnblogs.com/dathlin/p/13416030.html。</item>
                        <item>官网备案成功了，地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。企业终身授权费：8000元(不含税)。</item>
                    </list>
                </revision>
                <revision date="2020-8-28" version="9.3.1" author="Richard.Hu">
                    <list type="bullet">
                        <item>Beckhoff: 倍福PLC新增读取设备信息和设备状态的api接口。在demo界面添加测试按钮，状态码检查优化，错误时返回报文信息。</item>
                        <item>FanucSeries0i: 修复fanuc机床的读取宏变量解析double数据时，为0的时候解析异常的bug。</item>
                        <item>ABBWebApiServer：ABB机器人的虚拟服务器支持用户名和密码设置，在客户端请求数据的时间，支持账户验证。</item>
                        <item>Demoserver: 优化根据IP地址获取物理地址的方法，获取不到或是奇怪字符将切换线路重新获取。</item>
                        <item>KukaTcpNet: 新增KukaTcp通讯类，支持多变量写入的api，在demo界面增加启动，复位，停止程序的操作。</item>
                        <item>.Net Framwork 2.0 支持2.0的框架的dll发布，通过nuget安装即可。</item>
                        <item>SimpleHybirdLock: 简单混合锁添加一个当前进入锁的次数的静态属性，可以查看当前共有多少锁，等待多少锁。</item>
                        <item>NetworkDeviceBase: 核心交互方便增加错误捕获，异常释放锁，再throw, YamahaRCX类完善异步方法</item>
                        <item>NetworkBase: 增加一个线程检查超时的次数统计功能。</item>
                        <item>InovanceH3U: 修复汇川的3U的PLC地址类型为SM,SD时解析异常的bug。</item>
                        <item>Demo: HslCommunication Test Demo支持PLC及一些连接对象的参数保存功能，使用英文冒号可以分类管理。</item>
                        <item>WebSocketSession: 新增url属性，如果客户端请求包含url信息，例如：ws://127.0.0.1:1883/A/B?C=123, 那么url就是这个值。</item>
                        <item>Demo: 测试的DEMO程序，支持连接参数存储，不用再每次打开程序重新输入IP地址，端口，站号等等信息，可以存储起来，还支持分类存储。</item>
                        <item>官网地址： http://www.hslcommunication.cn 官网的界面全新设计过，感谢浏览关注。</item>
                        <item>本软件已经申请软件著作权，软著登字第5219522号，任何盗用软件，破解软件，未经正式合同授权而商业使用均视为侵权。</item>
                        <item>HSL的目标是打造成工业互联网的利器，工业大数据的基础，打造边缘计算平台。</item>
                    </list>
                </revision>
            </revisionHistory>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AbStructHandle">
            <summary>
            结构体的句柄信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.Count">
            <summary>
            返回项数
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.TemplateObjectDefinitionSize">
            <summary>
            结构体定义大小
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.TemplateStructureSize">
            <summary>
            使用读取标记服务读取结构时在线路上传输的字节数
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.MemberCount">
            <summary>
            成员数量
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbStructHandle.StructureHandle">
            <summary>
            结构体的handle
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AbTagItem">
            <summary>
            AB PLC的每个的数据标签情况
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.InstanceID">
            <summary>
            实例ID
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.SymbolType">
            <summary>
            TAG类型（有时候可作为实例ID使用）
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.ArrayDimension">
            <summary>
            数据的维度信息，默认是0，标量数据，1代表1为数组
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AbTagItem.IsStruct">
            <summary>
            是否结构体数据
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper">
            <summary>
            AB PLC的辅助类，用来辅助生成基本的指令信息
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_DATA">
            <summary>
            CIP命令中的读取数据的服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_DATA">
            <summary>
            CIP命令中的写数据的服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_WRITE_DATA">
            <summary>
            CIP命令中的读并写的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_FRAGMENT">
            <summary>
            CIP命令中的读片段的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_WRITE_FRAGMENT">
            <summary>
            CIP命令中的写片段的数据服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_READ_LIST">
            <summary>
            CIP指令中读取数据的列表
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_MULTIREAD_DATA">
            <summary>
            CIP命令中的对数据读取服务
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Bool">
            <summary>
            bool型数据，一个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Byte">
            <summary>
            byte型数据，一个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Word">
            <summary>
            整型，两个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_DWord">
            <summary>
            长整型，四个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_LInt">
            <summary>
            特长整型，8个字节
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Real">
            <summary>
            实数数据，四个字节长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Double">
            <summary>
            实数数据，八个字节的长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_Struct">
            <summary>
            结构体数据，不定长度
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_String">
            <summary>
            字符串数据内容
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CIP_Type_BitArray">
            <summary>
            二进制数据内容
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ParseRequestPathCommand(System.Byte[])">
            <summary>
            从生成的报文里面反解出实际的数据地址，不支持结构体嵌套，仅支持数据，一维数组，不支持多维数据
            </summary>
            <param name="pathCommand">地址路径报文</param>
            <returns>实际的地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.GetEnumeratorCommand(System.UInt16)">
            <summary>
            获取枚举PLC数据信息的指令
            </summary>
            <param name="startInstance">实例的起始地址</param>
            <returns>结果数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.GetStructHandleCommand(System.UInt16)">
            <summary>
            获取获得结构体句柄的命令
            </summary>
            <param name="symbolType">包含地址的信息</param>
            <returns>命令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.GetStructItemNameType(System.UInt16,HslCommunication.Profinet.AllenBradley.AbStructHandle)">
            <summary>
            获取结构体内部数据结构的方法
            </summary>
            <param name="symbolType">地址</param>
            <param name="structHandle">句柄</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestHeader(System.UInt16,System.UInt32,System.Byte[])">
            <summary>
            将CommandSpecificData的命令，打包成可发送的数据指令
            </summary>
            <param name="command">实际的命令暗号</param>
            <param name="session">当前会话的id</param>
            <param name="commandSpecificData">CommandSpecificData命令</param>
            <returns>最终可发送的数据命令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequsetRead(System.String,System.Int32,System.Boolean)">
            <summary>
            打包生成一个请求读取数据的节点信息，CIP指令信息
            </summary>
            <param name="address">地址</param>
            <param name="length">指代数组的长度</param>
            <param name="isConnectedAddress">是否是连接模式下的地址，默认为false</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestReadSegment(System.String,System.Int32,System.Int32)">
            <summary>
            打包生成一个请求读取数据片段的节点信息，CIP指令信息
            </summary>
            <param name="address">节点的名称 -> Tag Name</param>
            <param name="startIndex">起始的索引位置，以字节为单位 -> The initial index position, in bytes</param>
            <param name="length">读取的数据长度，一次通讯总计490个字节 -> Length of read data, a total of 490 bytes of communication</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackRequestWrite(System.String,System.UInt16,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            根据指定的数据和类型，生成对应的数据
            </summary>
            <param name="address">地址信息</param>
            <param name="typeCode">数据类型</param>
            <param name="value">字节值</param>
            <param name="length">如果节点为数组，就是数组长度</param>
            <param name="isConnectedAddress">是否为连接模式的地址</param>
            <returns>CIP的指令信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandService(System.Byte[],System.Byte[][])">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="portSlot">PLC所在的面板槽号</param>
            <param name="cips">所有的cip打包指令信息</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCleanCommandService(System.Byte[],System.Byte[][])">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="portSlot">PLC所在的面板槽号</param>
            <param name="cips">所有的cip打包指令信息</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandGetAttributesAll(System.Byte[],System.UInt32)">
            <summary>
            打包一个读取所有特性数据的报文信息，需要传入slot
            </summary>
            <param name="portSlot">站号信息</param>
            <param name="sessionHandle">会话的ID信息</param>
            <returns>最终发送的报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandResponse(System.Byte[],System.Boolean)">
            <summary>
            根据数据创建反馈的数据信息
            </summary>
            <param name="data">反馈的数据信息</param>
            <param name="isRead">是否是读取</param>
            <returns>数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandSpecificData(System.Byte[][])">
            <summary>
            生成读取直接节点数据信息的内容
            </summary>
            <param name="service">cip指令内容</param>
            <returns>最终的指令值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandSingleService(System.Byte[])">
            <summary>
            将所有的cip指定进行打包操作。
            </summary>
            <param name="command">指令信息</param>
            <returns>包含服务的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.RegisterSessionHandle">
            <summary>
            向PLC注册会话ID的报文<br />
            Register a message with the PLC for the session ID
            </summary>
            <returns>报文信息 -> Message information </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.UnRegisterSessionHandle(System.UInt32)">
            <summary>
            获取卸载一个已注册的会话的报文<br />
            Get a message to uninstall a registered session
            </summary>
            <param name="sessionHandle">当前会话的ID信息</param>
            <returns>字节报文信息 -> BYTE message information </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.CheckResponse(System.Byte[])">
            <summary>
            初步检查返回的CIP协议的报文是否正确<br />
            Initially check whether the returned CIP protocol message is correct
            </summary>
            <param name="response">CIP的报文信息</param>
            <returns>是否正确的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据解析
            </summary>
            <param name="response">PLC的反馈数据</param>
            <param name="isRead">是否是返回的操作</param>
            <returns>带有结果标识的最终数据</returns>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue">
            <summary>
            AB PLC的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.Buffer">
            <summary>
            真实的数组缓存
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.IsArray">
            <summary>
            是否是数组的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue.TypeLength">
            <summary>
            单个单位的数据长度信息
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip">
            <summary>
            AB PLC的cip通信实现类，适用Micro800系列控制系统<br />
            AB PLC's cip communication implementation class, suitable for Micro800 series control system
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.PackCommandService(System.Byte[],System.Byte[][])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyMicroCip.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyNet">
            <summary>
            AB PLC的数据通信类，使用CIP协议实现，适用1756，1769等型号，支持使用标签的形式进行读写操作，支持标量数据，一维数组，二维数组，三维数组等等。如果是局部变量，那么使用 Program:MainProgram.[变量名]。<br />
            The data communication class of AB PLC is implemented using the CIP protocol. It is suitable for 1756, 1769 and other models. 
            It supports reading and writing in the form of tags, scalar data, one-dimensional array, two-dimensional array, 
            three-dimensional array, and so on. If it is a local variable, use the Program:MainProgram.[Variable name].
            </summary>
            <remarks>
            thanks 江阴-  ∮溪风-⊙_⌒ help test the dll
            <br />
            thanks 上海-null 测试了这个dll
            <br />
            <br />
            默认的地址就是PLC里的TAG名字，比如A，B，C；如果你需要读取的数据是一个数组，那么A就是默认的A[0]，如果想要读取偏移量为10的数据，那么地址为A[10]，
            多维数组同理，使用A[10,10,10]的操作。
            <br />
            <br />
            假设你读取的是局部变量，那么使用 Program:MainProgram.变量名
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a communication object for a Allenbradley PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.SessionHandle">
            <summary>
            The current session handle, which is determined by the PLC when communicating with the PLC handshake
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Slot">
            <summary>
            Gets or sets the slot number information for the current plc, which should be set before connections
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.PortSlot">
            <summary>
            port and slot information
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.CipCommand">
            <summary>
            获取或设置整个交互指令的控制码，默认为0x6F，通常不需要修改<br />
            Gets or sets the control code of the entire interactive instruction. The default is 0x6F, and usually does not need to be modified.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[],System.Int32[])">
            <summary>
            创建一个读取标签的报文指定<br />
            Build a read command bytes
            </summary>
            <param name="address">the address of the tag name</param>
            <param name="length">Array information, if not arrays, is 1 </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildReadCommand(System.String[])">
            <summary>
            创建一个读取多标签的报文<br />
            Build a read command bytes
            </summary>
            <param name="address">The address of the tag name </param>
            <returns>Message information that contains the result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.BuildWriteCommand(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Create a written message instruction
            </summary>
            <param name="address">The address of the tag name </param>
            <param name="typeCode">Data type</param>
            <param name="data">Source Data </param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Message information that contains the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String,System.UInt16)">
            <summary>
            Read data information, data length for read array length information
            </summary>
            <param name="address">Address format of the node</param>
            <param name="length">In the case of arrays, the length of the array </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[])">
            <summary>
            Bulk read Data information
            </summary>
            <param name="address">Name of the node </param>
            <returns>Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Read(System.String[],System.Int32[])">
            <summary>
            批量读取数据信息，数据长度为读取的数组长度信息<br />
            Bulk read data information, data length for read array length information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="length">如果是数组，就为数组长度 -> In the case of arrays, the length of the array </param>
            <returns>带有结果对象的结果数据 -> Result data with result object </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadSegment(System.String,System.Int32,System.Int32)">
            <summary>
            Read Segment Data Array form plc, use address tag name
            </summary>
            <param name="address">Tag name in plc</param>
            <param name="startIndex">array start index, uint byte index</param>
            <param name="length">array length, data item length</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadCipFromServer(System.Byte[][])">
            <summary>
            使用CIP报文和服务器进行核心的数据交换
            </summary>
            <param name="cips">Cip commands</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadEipFromServer(System.Byte[][])">
            <summary>
            使用EIP报文和服务器进行核心的数据交换
            </summary>
            <param name="eip">eip commands</param>
            <returns>Results Bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBool(System.String)">
            <summary>
            读取单个的bool数据信息<br />
            Read a single BOOL data information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadBoolArray(System.String)">
            <summary>
            批量读取的bool数组信息<br />
            Bulk read of bool array information
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)">
            <summary>
            读取PLC的byte类型的数据<br />
            Read the byte type of PLC data
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <returns>带有结果对象的结果数据 -> Result data with result info </returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.TagEnumerator">
            <summary>
            枚举当前的所有的变量名字，包含结构体信息，除去系统自带的名称数据信息<br />
            Enumerate all the current variable names, including structure information, except the name data information that comes with the system
            </summary>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.StructTagEnumerator(HslCommunication.Profinet.AllenBradley.AbTagItem)">
            <summary>
            枚举结构体的方法
            </summary>
            <param name="structTag">结构体的标签</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte[])">
            <summary>
            当前的PLC不支持该功能，需要调用 <see cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)"/> 方法来实现。<br />
            The current PLC does not support this function, you need to call the <see cref = "M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)" /> method to achieve it.
            </summary>
            <param name="address">地址</param>
            <param name="value">值</param>
            <returns>写入结果值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            使用指定的类型写入指定的节点数据<br />
            Writes the specified node data with the specified type
            </summary>
            <param name="address">节点的名称 -> Name of the node </param>
            <param name="typeCode">类型代码，详细参见<see cref="T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper"/>上的常用字段 ->  Type code, see the commonly used Fields section on the <see cref= "T:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper"/> in detail</param>
            <param name="value">实际的数据值 -> The actual data value </param>
            <param name="length">如果节点是数组，就是数组长度 -> If the node is an array, it is the array length </param>
            <returns>是否写入成功 -> Whether to write successfully</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt16[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt32[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Single[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Int64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.UInt64[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Double[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.PackCommandService(System.Byte[],System.Byte[][])">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyHelper.PackCommandService(System.Byte[],System.Byte[][])"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.AllenBradley.AllenBradleyServer">
            <summary>
            AB PLC的虚拟服务器，仅支持和HSL组件的完美通信，可以手动添加一些节点。<br />
            AB PLC's virtual server only supports perfect communication with HSL components. You can manually add some nodes.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.#ctor">
            <summary>
            实例化一个AB PLC协议的服务器<br />
            Instantiate an AB PLC protocol server
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.DataFormat">
            <summary>
            获取或设置当前的服务器的数据字节排序情况<br />
            Gets or sets the data byte ordering of the current server
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,HslCommunication.Profinet.AllenBradley.AllenBradleyItemValue)">
            <summary>
            向服务器新增一个新的Tag值<br />
            Add a new tag value to the server
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Boolean)">
            <summary>
            向服务器新增一个新的bool类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type bool to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16)">
            <summary>
            向服务器新增一个新的short类型的Tag值，并赋予初始化的值<br />
            Add a new short tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int16[])">
            <summary>
            向服务器新增一个新的short数组的Tag值，并赋予初始化的值<br />
            Add a new short array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16)">
            <summary>
            向服务器新增一个新的ushort类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of ushort type to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt16[])">
            <summary>
            向服务器新增一个新的ushort数组的Tag值，并赋予初始化的值<br />
            Add a new ushort array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32)">
            <summary>
            向服务器新增一个新的int类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of type int to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int32[])">
            <summary>
            向服务器新增一个新的int数组的Tag值，并赋予初始化的值<br />
            Add a new Tag value of the int array to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32)">
            <summary>
            向服务器新增一个新的uint类型的Tag值，并赋予初始化的值<br />
            Add a new uint tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt32[])">
            <summary>
            向服务器新增一个新的uint数组的Tag值，并赋予初始化的值<br />
            Add a new uint array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64)">
            <summary>
            向服务器新增一个新的long类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of type long to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Int64[])">
            <summary>
            向服务器新增一个新的long数组的Tag值，并赋予初始化的值<br />
            Add a new Long array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64)">
            <summary>
            向服务器新增一个新的ulong类型的Tag值，并赋予初始化的值<br />
            Add a new Ulong type Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.UInt64[])">
            <summary>
            向服务器新增一个新的ulong数组的Tag值，并赋予初始化的值<br />
            Add a new Ulong array Tag value to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single)">
            <summary>
            向服务器新增一个新的float类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type float to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Single[])">
            <summary>
            向服务器新增一个新的float数组的Tag值，并赋予初始化的值<br />
            Add a new Tag value of the float array to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double)">
            <summary>
            向服务器新增一个新的double类型的Tag值，并赋予初始化的值<br />
            Add a new tag value of type double to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.Double[])">
            <summary>
            向服务器新增一个新的double数组的Tag值，并赋予初始化的值<br />
            Add a new double array Tag value to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.String,System.Int32)">
            <summary>
            向服务器新增一个新的string类型的Tag值，并赋予初始化的值<br />
            Add a new Tag value of string type to the server and assign the initial value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
            <param name="maxLength">字符串的最长值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.AddTagValue(System.String,System.String[],System.Int32)">
            <summary>
            向服务器新增一个新的string数组的Tag值，并赋予初始化的值<br />
            Add a new String array Tag value to the server and assign the initialized value
            </summary>
            <param name="key">Tag名称</param>
            <param name="value">值信息</param>
            <param name="maxLength">字符串的最长值</param>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.AllenBradley.AllenBradleyNet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFromCipCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。
            </summary>
            <param name="cipAll">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadFloat(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ReadDouble(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.AllenBradley.AllenBradleyServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo">
            <summary>
            Ads设备的相关信息，主要是版本号，设备名称<br />
            Information about Ads devices, primarily version numbers, device names.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.#ctor(System.Byte[])">
            <summary>
            根据原始的数据内容来实例化一个对象<br />
            Instantiate an object based on the original data content
            </summary>
            <param name="data">原始的数据内容</param>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Major">
            <summary>
            主版本号<br />
            Main Version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Minor">
            <summary>
            次版本号<br />
            Minor Version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.Build">
            <summary>
            构建版本号<br />
            Build version
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.AdsDeviceInfo.DeviceName">
            <summary>
            设备的名字<br />
            Device Name
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet">
            <summary>
            倍福的ADS协议，支持读取倍福的地址数据，关于端口号的选择，TwinCAT2，端口号801；TwinCAT3，端口号为851<br />
            Beckhoff ’s ADS protocol supports reading Beckhoff ’s address data. For the choice of port number, TwinCAT2, port number 801; TwinCAT3, port number 851
            </summary>
            <remarks>
            支持的地址格式分三种，第一种是绝对的地址表示，比如M100，I100，Q100；第二种是字符串地址，采用s=aaaa;的表示方式；第三种是绝对内存地址采用i=1000000;的表示方式
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址以及端口号实例化一个默认的对象<br />
            Instantiate a default object with the specified IP address and port number
            </summary>
            <param name="ipAddress">IP地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.IpAddress">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.UseTagCache">
            <summary>
            是否使用标签的名称缓存功能，默认为 <c>False</c><br />
            Whether to use tag name caching. The default is <c>False</c>
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.SetTargetAMSNetId(System.String)">
            <summary>
            目标的地址，举例 192.168.0.1.1.1；也可以是带端口号 192.168.0.1.1.1:801<br />
            The address of the destination, for example 192.168.0.1.1.1; it can also be the port number 192.168.0.1.1.1: 801
            </summary>
            <remarks>
            Port：1: AMS Router; 2: AMS Debugger; 800: Ring 0 TC2 PLC; 801: TC2 PLC Runtime System 1; 811: TC2 PLC Runtime System 2; <br />
            821: TC2 PLC Runtime System 3; 831: TC2 PLC Runtime System 4; 850: Ring 0 TC3 PLC; 851: TC3 PLC Runtime System 1<br />
            852: TC3 PLC Runtime System 2; 853: TC3 PLC Runtime System 3; 854: TC3 PLC Runtime System 4; ...
            </remarks>
            <param name="amsNetId">AMSNet Id地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.SetSenderAMSNetId(System.String)">
            <summary>
            设置原目标地址 举例 192.168.0.100.1.1；也可以是带端口号 192.168.0.100.1.1:34567<br />
            Set the original destination address Example: 192.168.0.100.1.1; it can also be the port number 192.168.0.100.1.1: 34567
            </summary>
            <param name="amsNetId">原地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandle(System.String)">
            <summary>
            根据当前标签的地址获取到内存偏移地址<br />
            Get the memory offset address based on the address of the current label
            </summary>
            <param name="address">带标签的地址信息，例如s=A,那么标签就是A</param>
            <returns>内存偏移地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.TransValueHandle(System.String)">
            <summary>
            将字符串的地址转换为内存的地址，其他地址则不操作<br />
            Converts the address of a string to the address of a memory, other addresses do not operate
            </summary>
            <param name="address">地址信息，s=A的地址转换为i=100000的形式</param>
            <returns>地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsDeviceInfo">
            <summary>
            读取Ads设备的设备信息。主要是版本号，设备名称<br />
            Read the device information of the Ads device. Mainly version number, device name
            </summary>
            <returns>设备信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadAdsState">
            <summary>
            读取Ads设备的状态信息，其中<see cref="P:HslCommunication.OperateResult`2.Content1"/>是Ads State，<see cref="P:HslCommunication.OperateResult`2.Content2"/>是Device State<br />
            Read the status information of the Ads device, where <see cref="P:HslCommunication.OperateResult`2.Content1"/> is the Ads State, and <see cref="P:HslCommunication.OperateResult`2.Content2"/> is the Device State
            </summary>
            <returns>设备状态信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.WriteAdsState(System.Int16,System.Int16,System.Byte[])">
            <summary>
            写入Ads的状态，可以携带数据信息，数据可以为空<br />
            Write the status of Ads, can carry data information, and the data can be empty
            </summary>
            <param name="state">ads state</param>
            <param name="deviceState">device state</param>
            <param name="data">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReleaseSystemHandle(System.UInt32)">
            <summary>
            释放当前的系统句柄，该句柄是通过<see cref="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadValueHandle(System.String)"/>获取的
            </summary>
            <param name="handle">句柄</param>
            <returns>是否释放成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Read(System.String,System.UInt16)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A</param>
            <param name="length">长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte[])">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadBool(System.String,System.UInt16)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">PLC的地址信息，例如 M10</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Boolean[])">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ReadByte(System.String)">
            <summary>
            读取PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            Read PLC data, there are three formats of address, one: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.Write(System.String,System.Byte)">
            <summary>
            写入PLC的数据，地址共有三种格式，一：I,Q,M数据信息，举例M0,M100；二：内存地址，i=100000；三：标签地址，s=A<br />
            There are three formats for the data written into the PLC. One: I, Q, M data information, such as M0, M100; two: memory address, i = 100000; three: tag address, s = A
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildAmsHeaderCommand(System.UInt16,System.Byte[])">
            <summary>
            根据命令码ID，消息ID，数据信息组成AMS的命令码
            </summary>
            <param name="commandId">命令码ID</param>
            <param name="data">数据内容</param>
            <returns>打包之后的数据信息，没有填写AMSNetId的Target和Source内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildReadDeviceInfoCommand">
            <summary>
            构建读取设备信息的命令报文
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildReadStateCommand">
            <summary>
            构建读取状态的命令报文
            </summary>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildWriteControlCommand(System.Int16,System.Int16,System.Byte[])">
            <summary>
            构建写入状态的命令报文
            </summary>
            <param name="state">Ads state</param>
            <param name="deviceState">Device state</param>
            <param name="data">Data</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildReadCommand(System.String,System.Int32,System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildReadWriteCommand(System.String,System.Int32,System.Boolean,System.Byte[])">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBit">是否是位信息</param>
            <param name="value">写入的数值</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildWriteCommand(System.String,System.Boolean[],System.Boolean)">
            <summary>
            构建写入的指令信息
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据</param>
            <param name="isBit">是否是位信息</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.BuildReleaseSystemHandle(System.UInt32)">
            <summary>
            构建释放句柄的报文信息，当获取了变量的句柄后，这个句柄就被释放
            </summary>
            <param name="handle">句柄信息</param>
            <returns>报文的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.CheckResponse(System.Byte[])">
            <summary>
            检查从PLC的反馈的数据报文是否正确
            </summary>
            <param name="response">反馈报文</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.PackAmsTcpHelper(System.Byte[])">
            <summary>
            将实际的包含AMS头报文和数据报文的命令，打包成实际可发送的命令
            </summary>
            <param name="command">命令信息</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            分析当前的地址信息，根据结果信息进行解析出真实的偏移地址
            </summary>
            <param name="address">地址</param>
            <param name="isBit">是否位访问</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.StrToAdsBytes(System.String)">
            <summary>
            将字符串名称转变为ADS协议可识别的字节数组
            </summary>
            <param name="value">值</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Beckhoff.BeckhoffAdsNet.StrToAMSNetId(System.String)">
            <summary>
            将字符串的信息转换为AMS目标的地址
            </summary>
            <param name="amsNetId">目标信息</param>
            <returns>字节数组</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId" -->
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadDeviceInfo">
            <summary>
            读取PLC的名字和版本号等信息<br />
            Reads the name and the version number of the ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.Read">
            <summary>
            可以读ADS的设备读取数据<br />
            With ADS Read data can be read from an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.Write">
            <summary>
            将ADS数据写入到ADS的设备里去<br />
            With ADS Write data can be written to an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadState">
            <summary>
            读取ADS设备里的设备状态信息和ADS状态<br />
            Reads the ADS status and the device status of an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.WriteControl">
            <summary>
            更改ADS设备的设备状态信息和ADS状态<br />
            Changes the ADS status and the device status of an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.AddDeviceNotification">
            <summary>
            在ADS设备里面创建一个通知对象<br />
            A notification is created in an ADS device
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.DeleteDeviceNotification">
            <summary>
            删除ADS设备里的一个通知对象<br />
            One before defined notification is deleted in an ADS device.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.DeviceNotification">
            <summary>
            从ADS设备订阅一个数据的通知，将会发送到客户端<br />
            Data will carry forward independently from an ADS device to a Client
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Beckhoff.BeckhoffCommandId.ReadWrite">
            <summary>
            在写入的时候进行同时的读取<br />
            With ADS ReadWrite data will be written to an ADS device. Additionally, data can be read from the ADS device.
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.FatekProgram">
            <summary>
            台湾永宏公司的编程口协议，具体的地址信息请查阅api文档信息<br />
            The programming port protocol of Taiwan Yonghong company, please refer to the api document for specific address information
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.FATEK.FatekProgram.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgram.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.FATEK.FatekProgramOverTcp">
            <summary>
            台湾永宏公司的编程口协议，此处是基于tcp的实现，地址信息请查阅api文档信息<br />
            The programming port protocol of Taiwan Yonghong company, here is the implementation based on TCP, please refer to the API information for the address information
            </summary>
            <remarks>
            其所支持的地址形式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>RT</term>
                <term>RT100,RT200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>RC</term>
                <term>RC100,RC200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor">
            <summary>
            实例化默认的构造方法<br />
            Instantiate the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Station">
            <summary>
            PLC的站号信息，需要和实际的设置值一致，默认为1<br />
            The station number information of the PLC needs to be consistent with the actual setting value. The default is 1.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的字节数据，以字为单位，支持读取X,Y,M,S,D,T,C,R,RT,RC具体的地址范围需要根据PLC型号来确认<br />
            Read PLC byte data in batches, in word units. Supports reading X, Y, M, S, D, T, C, R, RT, RC. The specific address range needs to be confirmed according to the PLC model.
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C,R,RT,RC具体的地址范围需要根据PLC型号来确认<br />
            The data written to the PLC in batches, in units of words, that is, at least 2 bytes of information, supporting X, Y, M, S, D, T, C, R, RT, and RC. The specific address range needs to be based on the PLC model To confirm
            </summary>
            <param name="address">地址信息，举例，D100，R200，RC100，RT200</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,M,S,T,C，具体的地址范围取决于PLC的类型<br />
            Read bool data in batches. The supported types are X, Y, M, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">地址信息，比如X10，Y17，M100</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,M,S,T,C，具体的地址范围取决于PLC的类型<br />
            Write arrays of type bool in batches. The supported types are X, Y, M, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.FatekAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLCd的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            创建一条别入bool数据的指令信息，需要指定一些参数
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.FATEK.FatekProgramOverTcp.GetErrorDescriptionFromCode(System.Char)">
            <summary>
            根据错误码获取到真实的文本信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomSerial">
            <summary>
            基于串口的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Serial.SerialDeviceBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample5" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample6" title="读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomTcpNet">
            <summary>
            基于TCP/IP协议的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample1" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample2" title="连接及读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址及端口号来实例化自由的TCP协议
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomTcpNet.AnalysisAddress(System.String)">
            <summary>
            分析地址的方法，会转换成一个数据报文和数据结果偏移的信息
            </summary>
            <param name="address">地址信息</param>
            <returns>报文结果内容</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Freedom.FreedomUdpNet">
            <summary>
            基于UDP/IP协议的自由协议，需要在地址里传入报文信息，也可以传入数据偏移信息，<see cref="P:HslCommunication.Core.Net.NetworkUdpDeviceBase.ByteTransform"/>默认为<see cref="T:HslCommunication.Core.RegularByteTransform"/>
            </summary>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample3" title="实例化" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\FreedomExample.cs" region="Sample4" title="读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址及端口号来实例化自由的TCP协议
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Freedom.FreedomUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPB">
            <summary>
            富士PLC的SPB协议，详细的地址信息见api文档说明<br />
            Fuji PLC's SPB protocol. For detailed address information, see the api documentation.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Fuji.FujiSPBOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPB.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPB.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Fuji.FujiSPBOverTcp">
            <summary>
            富士PLC的SPB协议，详细的地址信息见api文档说明<br />
            Fuji PLC's SPB protocol. For detailed address information, see the api documentation.
            </summary>
            <remarks>
            其所支持的地址形式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor">
            <summary>
            使用默认的构造方法实例化对象<br />
            Instantiate the object using the default constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口来实例化一个对象<br />
            Instantiate an object with the specified IP address and port
            </summary>
            <param name="ipAddress">设备的Ip地址</param>
            <param name="port">设备的端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Station">
            <summary>
            PLC的站号信息<br />
            PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,L,M,D,TN,CN,TC,CC,R具体的地址范围需要根据PLC型号来确认<br />
            Read PLC data in batches, in units of words. Supports reading X, Y, L, M, D, TN, CN, TC, CC, R. The specific address range needs to be confirmed according to the PLC model.
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持读取X,Y,L,M,D,TN,CN,TC,CC,R具体的地址范围需要根据PLC型号来确认<br />
            The data written to the PLC in batches, in units of words, that is, a minimum of 2 bytes of information. It supports reading X, Y, L, M, D, TN, CN, TC, CC, and R. The specific address range needs to be based on PLC model to confirm
            </summary>
            <param name="address">地址信息，举例，D100，R200，RC100，RT200</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.FujikAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLCd的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Fuji.FujiSPBOverTcp.GetErrorDescriptionFromCode(System.String)">
            <summary>
            根据错误码获取到真实的文本信息
            </summary>
            <param name="code">错误码</param>
            <returns>错误的文本描述</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue">
            <summary>
            振动传感器的加速度值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedX">
            <summary>
            X轴的实时加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedY">
            <summary>
            Y轴的实时加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.AcceleratedSpeedZ">
            <summary>
            Z轴的实时加速度
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorActualValue.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient">
            <summary>
            Geniitek-VB31 型号的智能无线振动传感器，来自苏州捷杰传感器技术有限公司
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip，端口来实例化一个默认的对象
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectServer">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadStatus">
            <summary>
            设置读取震动传感器的状态数据<br />
            Set to read the status data of the shock sensor
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadActual">
            <summary>
            设置读取震动传感器的实时加速度<br />
            Set the real-time acceleration of the vibration sensor
            </summary>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.SetReadStatusInterval(System.Int32)">
            <summary>
            设置当前的震动传感器的数据发送间隔为指定的时间，单位为秒<br />
            Set the current vibration sensor data transmission interval to the specified time in seconds
            </summary>
            <param name="seconds">时间信息，单位为秒</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnPeekValueReceiveDelegate">
            <summary>
            震动传感器峰值数据事件委托<br />
            Shock sensor peak data event delegation
            </summary>
            <param name="peekValue">峰值信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnPeekValueReceive">
             <summary>
             接收到震动传感器峰值数据时触发<br />
             Triggered when peak data of vibration sensor is received
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnActualValueReceiveDelegate">
            <summary>
            震动传感器实时数据事件委托<br />
            Vibration sensor real-time data event delegation
            </summary>
            <param name="actualValue">实际信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnActualValueReceive">
             <summary>
             接收到震动传感器实时数据时触发<br />
             Triggered when real-time data from shock sensor is received
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Geniitek.VibrationSensorClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ConnectTimeOut">
            <summary>
            获取或设置当前客户端的连接超时时间，默认10,000毫秒，单位ms<br />
            Gets or sets the connection timeout of the current client. The default is 10,000 milliseconds. The unit is ms.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.CheckSeconds">
            <summary>
            获取或设置当前的客户端假死超时检查时间，单位为秒，默认60秒，60秒内没有接收到传感器的数据，则强制重连。
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorClient.Address">
            <summary>
            当前设备的地址信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.BulidLongMessage(System.UInt16,System.Byte,System.Byte[])">
            <summary>
            根据地址，命令，数据，创建向传感器发送的数据信息
            </summary>
            <param name="address">设备地址</param>
            <param name="cmd">命令</param>
            <param name="data">数据信息</param>
            <returns>原始的数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorClient.CheckXor(System.Byte[])">
            <summary>
            检查当前的数据是否XOR校验成功
            </summary>
            <param name="data">数据信息</param>
            <returns>校验结果</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage">
            <summary>
            完整的数据报文信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorLongMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue">
            <summary>
            振动传感器的峰值数据类
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedX">
            <summary>
            X轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedY">
            <summary>
            Y轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.AcceleratedSpeedZ">
            <summary>
            Z轴的加速度，单位 m/s2
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedX">
            <summary>
            X轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedY">
            <summary>
            Y轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SpeedZ">
            <summary>
            Z轴的速度，单位 mm/s
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetX">
            <summary>
            X轴的位置，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetY">
            <summary>
            Y轴的位移，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.OffsetZ">
            <summary>
            Z轴的位移，单位 um
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.Temperature">
            <summary>
            温度，单位 摄氏度
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.Voltage">
            <summary>
            电压，单位 伏特
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorPeekValue.SendingInterval">
            <summary>
            数据的发送间隔，单位秒
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage">
            <summary>
            短消息的报文内容
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.ProtocolHeadBytesLength">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ProtocolHeadBytesLength"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.HeadBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.HeadBytes"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.ContentBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.ContentBytes"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.CheckHeadBytesLegal(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.CheckHeadBytesLegal(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.GetContentLengthByHeadBytes">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetContentLengthByHeadBytes"/>
        </member>
        <member name="M:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.GetHeadBytesIdentity">
            <inheritdoc cref="M:HslCommunication.Core.IMessage.INetMessage.GetHeadBytesIdentity"/>
        </member>
        <member name="P:HslCommunication.Profinet.Geniitek.VibrationSensorShortMessage.SendBytes">
            <inheritdoc cref="P:HslCommunication.Core.IMessage.INetMessage.SendBytes"/>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.IdentityCard">
            <summary>
            身份证的信息类
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Name">
            <summary>
            名字
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Sex">
            <summary>
            性别
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Id">
            <summary>
            身份证号
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Nation">
            <summary>
            民族
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Birthday">
            <summary>
            生日
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Address">
            <summary>
            地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Organ">
            <summary>
            发证机关
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.ValidityStartDate">
            <summary>
            有效期日期的起始日期
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.ValidityEndDate">
            <summary>
            有效期日期的结束日期
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.IDCard.IdentityCard.Portrait">
            <summary>
            头像信息
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.IdentityCard.ToString">
            <summary>
            返回表示当前对象的字符串
            </summary>
            <returns>字符串</returns>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.SAMSerial">
            <summary>
            基于SAM协议的串口通信类，支持读取身份证的数据信息，详细参见API文档<br />
            Network class implemented by Tcp based on the SAM protocol, which supports reading ID card data information, 
            see API documentation for details
            </summary>
            <example>
            在使用之前需要实例化当前的对象，然后根据实际的情况填写好串口的信息，否则连接不上去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample1" title="实例化操作" />
            在实际的读取，我们一般放在后台进行循环扫描的操作，参见下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample2" title="基本的读取操作" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SPReceived(System.IO.Ports.SerialPort,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ReadSafeModuleNumber">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckSafeModuleStatus">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatus"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SearchCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.SelectCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ReadCard">
            <inheritdoc cref="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCard"/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.PackToSAMCommand(System.Byte[])">
            <summary>
            将指令进行打包成可以发送的数据对象
            </summary>
            <param name="command">命令信息</param>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.BuildReadCommand(System.Byte,System.Byte,System.Byte[])">
            <summary>
            根据SAM的实际的指令，来生成实际的指令信息
            </summary>
            <param name="cmd">命令码</param>
            <param name="para">参数信息</param>
            <param name="data">数据内容</param>
            <returns>字符串的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckADSCommandCompletion(System.Collections.Generic.List{System.Byte})">
            <summary>
            检查当前的接收数据信息是否一条完整的数据信息
            </summary>
            <param name="input">输入的信息</param>
            <returns>是否接收完成</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.CheckADSCommandAndSum(System.Byte[])">
            <summary>
            检查当前的指令是否是正确的
            </summary>
            <param name="input">输入的指令信息</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ExtractSafeModuleNumber(System.Byte[])">
            <summary>
            提炼安全的模块数据信息
            </summary>
            <param name="data">数据</param>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.ExtractIdentityCard(System.Byte[])">
            <summary>
            从数据中提取出真实的身份证信息
            </summary>
            <param name="data">原始数据内容</param>
            <returns>包含结果对象的身份证数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetNationText(System.Int32)">
            <summary>
            根据民族的代号来获取到民族的文本描述信息
            </summary>
            <param name="nation">民族代码</param>
            <returns>民族的文本信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetNationEnumerator">
            <summary>
            枚举当前的所有的民族信息，共计五十六个民族
            </summary>
            <returns>枚举信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMSerial.GetErrorDescription(System.Int32)">
            <summary>
            获取错误的文本信息
            </summary>
            <param name="err">错误号</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.IDCard.SAMTcpNet">
            <summary>
            基于SAM协议的Tcp实现的网络类，支持读取身份证的数据信息，通过透传的形式实现，除了初始化和串口类不一致，调用方法是几乎一模一样的，详细参见API文档<br />
            The network class implemented by Tcp based on the SAM protocol supports reading ID card data information and is implemented in the form of transparent transmission. 
            Except for the inconsistency between the initialization and the serial port class, the calling method is almost the same. 
            See the API documentation for details
            </summary>
            <example>
            在使用之前需要实例化当前的对象，然后根据实际的情况填写好串口的信息，否则连接不上去。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample3" title="实例化操作" />
            在实际的读取，我们一般放在后台进行循环扫描的操作，参见下面的代码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample4" title="基本的读取操作" />
            当然也支持全异步的操作了，就是方法的名称改改
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample5" title="实例化操作" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SAMSerialSample.cs" region="Sample6" title="基本的读取操作" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            通过指定的ip地址以及端口来实例化对象<br />
            Instantiate the object with the specified IP address and port
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadSafeModuleNumber">
            <summary>
            读取身份证设备的安全模块号<br />
            Read the security module number of the ID device
            </summary>
            <returns>结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.CheckSafeModuleStatus">
            <summary>
            检测安全模块状态<br />
            Detecting Security Module Status
            </summary>
            <returns>返回是否检测成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SearchCard">
            <summary>
            寻找卡片，并返回是否成功<br />
            Find cards and return success
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.SelectCard">
            <summary>
            选择卡片，并返回是否成功<br />
            Select card and return success
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ReadCard">
            <summary>
            读取卡片，如果成功的话，就返回身份证的所有的信息<br />
            Read the card, if successful, return all the information of the ID cards
            </summary>
            <returns>是否寻找成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.IDCard.SAMTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceAMSerial">
            <summary>
            汇川的串口通信协议，适用于AM400、 AM400_800、 AC800 等系列，底层走的是MODBUS-RTU协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is applicable to AM400, AM400_800, AC800 and other series. The bottom layer is MODBUS-RTU protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Inovance.InovanceAMTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.#ctor(System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来初始化<br />
            Specify the server address, port number, and client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceAMTcp">
            <summary>
            汇川的网络通信协议，适用于AM400、 AM400_800、 AC800 等系列，底层走的是MODBUS-TCP协议，地址说明参见标记<br />
            Huichuan's network communication protocol is applicable to AM400, AM400_800, AC800 and other series. The bottom layer is MODBUS-TCP protocol. For the address description, please refer to mark
            </summary>
            <remarks>
            AM400_800 的元件有 Q 区，I 区，M 区这三种，分别都可以按位，按字节，按字和按双字进行访问，在本组件的条件下，仅支持按照位，字访问。<br />
            对于AM400_800系列的地址表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>输出</term>
                <term>Q</term>
                <term>Q0.0-Q8191.7 或是 Q0-Q65535</term>
                <term>8 或是 10</term>
                <term>位读写</term>
              </item>
              <item>
                <term>输入</term>
                <term>I</term>
                <term>IX0.0-IX8191.7 或是 I0-I65535</term>
                <term>8 或是 10</term>
                <term>位读写</term>
              </item>
              <item>
                <term>M寄存器</term>
                <term>M</term>
                <term>MW0-MW65535</term>
                <term>10</term>
                <term>按照字访问的</term>
              </item>
            </list>
            针对AM600的TCP还支持下面的两种地址读写
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0.0-SM8191.7 或是 SM0-SM65535</term>
                <term>10</term>
                <term>位读写</term>
              </item>
              <item>
                <term></term>
                <term>SD</term>
                <term>SDW0-SDW65535</term>
                <term>10</term>
                <term>字读写</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.#ctor">
            <summary>
            实例化一个安川AM400-AM800系列的网络通讯协议<br />
            Instantiate a network communication protocol of Yaskawa AM400-AM800 series
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来实例化一个安川AM400-AM800系列的网络通讯协议<br />
            Specify the server address, port number, and client's own station number to instantiate a Yaskawa AM400-AM800 series network communication protocol
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Read(System.String,System.UInt16)">
            <summary>
            按字读取汇川PLC的数据信息，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SDW100地址数据<br />
            Read Huichuan PLC's data information by word. For the case of AM400_800, you can enter MW0 and MW100. For AM600, it also supports SDW0 and SDW100 address data.
            </summary>
            <param name="address">PLC的真实的地址信息，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SD2100地址数据</param>
            <param name="length">读取的数据的长度，按照字为单位</param>
            <returns>包含是否成功的结果对象信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Byte[])">
            <summary>
            按字写入汇川PLC的数据信息，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SDW100地址数据<br />
            Write the data information of Huichuan PLC by word. For the case of AM400_800, you can enter MW0 and MW100. For AM600, it also supports SDW0 and SDW100 address data.
            </summary>
            <param name="address">PLC的真实的地址信息，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SD2100地址数据</param>
            <param name="value">等待写入的原始数据，长度为2的倍数</param>
            <returns>是否写入成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            按位读取汇川PLC的数据信息，对于AM400_800的情况，可以输入QX0.1，IX0.1，对于AM600而言，还支持SMX0.1地址数据<br />
            Read the data of Huichuan PLC bit by bit. For the case of AM400_800, you can enter QX0.1 and IX0.1. For AM600, it also supports SMX0.1 address data.
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于AM400_800的情况，可以输入QX0.1，IX0.1，对于AM600而言，还支持SMX0.1地址数据</param>
            <param name="length">等待读取的长度，按照位为单位</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Boolean[])">
            <summary>
            按位写入汇川PLC的数据信息，对于AM400_800的情况，可以输入QX0.1，对于AM600而言，还支持SMX0.1地址数据<br />
            Write the data information of Huichuan PLC bit by bit. For AM400_800, you can enter QX0.1. For AM600, it also supports SMX0.1 address data
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于AM400_800的情况，可以输入QX0.1，对于AM600而言，还支持SMX0.1地址数据</param>
            <param name="values">等待写入的原始数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Boolean)">
            <summary>
            写入汇川PLC一个bool数据，对于AM400_800的情况，可以输入QX0.1，对于AM600而言，还支持SMX0.1地址数据<br />
            Write a bool data of Huichuan PLC. For the case of AM400_800, you can enter QX0.1. For AM600, it also supports SMX0.1 address data.
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于AM400_800的情况，可以输入QX0.1，对于AM600而言，还支持SMX0.1地址数据</param>
            <param name="value">bool数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.Int16)">
            <summary>
            写入汇川PLC的一个字数据，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SDW100地址数据<br />
            Write one word data of Huichuan PLC. For the case of AM400_800, you can enter MW0 and MW100. For AM600, it also supports SDW0 and SDW100 address data.
            </summary>
            <param name="address">汇川PLC的真实地址，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SD2100地址数据</param>
            <param name="value">short数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.Write(System.String,System.UInt16)">
            <summary>
            写入汇川PLC的一个字数据，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SDW100地址数据<br />
            Write one word data of Huichuan PLC. For the case of AM400_800, you can enter MW0 and MW100. For AM600, it also supports SDW0 and SDW100 address data.
            </summary>
            <param name="address">汇川PLC的真实地址，对于AM400_800的情况，可以输入MW0，MW100，对于AM600而言，还支持SDW0，SD2100地址数据</param>
            <param name="value">ushort数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceAMTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceH3USerial">
            <summary>
            汇川的串口通信协议，适用于H3U, XP 等系列，底层走的是MODBUS-TCP协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is suitable for H3U, XP and other series. 
            The bottom layer is MODBUS-TCP protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Inovance.InovanceH3UTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3USerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceH3UTcp">
            <summary>
            汇川的网络通信协议，适用于H3U, XP 等系列，底层走的是MODBUS-TCP协议，地址说明参见标记<br />
            Huichuan's network communication protocol is suitable for H3U, XP and other series. The bottom layer is MODBUS-TCP protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            本组件适用的系列为H3U 系列和 XP 系列 PLC（H2UXP、 H2SXP、 H1UXP、 H1SXP 等系列） 其中XP 系列控制器不支持以太网通讯<br />
            H3U 系列控制器支持 M/SM/S/T/C/X/Y 等 bit 型变量（也称线圈） 的访问、 D/SD/R/T/C 等 word 型变量的访问；<br /><br />
            <c>我们先来看看H3U系列</c><br />
            线圈、 位元件、位变量地址定义
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M7679，M8000-M8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>SM</term>
                <term>SM0-SM1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X377 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y377 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>SD</term>
                <term>SD0-SD1023</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>R0-R32767</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C199,C200-C255</term>
                <term>10</term>
                <term>其实C200-C255的计数器是32位的</term>
              </item>
            </list>
            <c>我们再来看看XP系列，就是少了一点访问的数据类型，然后，地址范围也不一致</c><br />
            线圈、 位元件、位变量地址定义
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M3071，M8000-M8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X377 或者X0.0-X37.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y377 或者Y0.0-Y37.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            寄存器、 字元件、字变量地址定义：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D8511</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0-T255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0-C199,C200-C255</term>
                <term>10</term>
                <term>其实C200-C255的计数器是32位的</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.#ctor">
            <summary>
            实例化一个汇川H3U, XP 系列的网络通讯协议<br />
            Instantiate a network communication protocol of HuiChuan H3U, XP series
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来实例化一个汇川H3U, XP 系列的网络通讯协议<br />
            Specify the server address, port number, and client's own station number to instantiate a network communication protocol of Huichuan H3U, XP series
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Read(System.String,System.UInt16)">
            <summary>
            按字读取汇川PLC的数据信息，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0<br />
            Read Huichuan PLC's data information by word. For H3U, you can enter D0, SD0, R0, T0, C0 type addresses. For XP series, you can enter D0, T0, C0.
            </summary>
            <param name="address">PLC的真实的地址信息，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0</param>
            <param name="length">读取的数据的长度，按照字为单位</param>
            <returns>包含是否成功的结果对象信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Byte[])">
            <summary>
            按字写入汇川PLC的数据信息，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0<br />
            Write the data information of Huichuan PLC by word. For H3U, you can enter D0, SD0, R0, T0, and C0 type addresses. For XP series, you can enter D0, T0, and C0.
            </summary>
            <param name="address">PLC的真实的地址信息，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0</param>
            <param name="value">等待写入的原始数据，长度为2的倍数</param>
            <returns>是否写入成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            按位读取汇川PLC的数据信息，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0<br />
            Read the data information of Huichuan PLC bit by bit. For H3U, you can enter M0, SM0, S0, T0, C0, X0, Y0 type addresses. For XP series, you can enter M0, S0, T0, C0, X0. , Y0
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0</param>
            <param name="length">等待读取的长度，按照位为单位</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Boolean[])">
            <summary>
            按位写入汇川PLC的数据信息，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0<br />
            Write the data information of Huichuan PLC bit by bit. For H3U, you can enter M0, SM0, S0, T0, C0, X0, Y0 type addresses. For XP series, you can enter M0, S0, T0, C0, X0 , Y0
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0</param>
            <param name="values">等待写入的原始数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Boolean)">
            <summary>
            写入汇川PLC一个bool数据，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0<br />
            Write a bool data to Huichuan PLC. For H3U, you can enter M0, SM0, S0, T0, C0, X0, Y0 type address. For XP series, you can enter M0, S0, T0, C0, X0, Y0.
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，对于H3U情况，可以输入M0,SM0,S0,T0,C0,X0,Y0类型地址，对于XP系列而言，可以输入M0,S0,T0,C0,X0,Y0</param>
            <param name="value">bool数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.Int16)">
            <summary>
            写入汇川PLC的一个字数据，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0<br />
            Write one word data of Huichuan PLC. For H3U, you can enter D0, SD0, R0, T0, C0 type address. For XP series, you can enter D0, T0, C0
            </summary>
            <param name="address">汇川PLC的真实地址，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0</param>
            <param name="value">short数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.Write(System.String,System.UInt16)">
            <summary>
            写入汇川PLC的一个字数据，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0<br />
            Write one word data of Huichuan PLC. For H3U, you can enter D0, SD0, R0, T0, C0 type address. For XP series, you can enter D0, T0, C0
            </summary>
            <param name="address">汇川PLC的真实地址，对于H3U情况，可以输入D0,SD0,R0,T0,C0类型地址，对于XP系列而言，可以输入D0,T0,C0</param>
            <param name="value">ushort数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH3UTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceH5USerial">
            <summary>
            汇川的串口通信协议，适用于H5U 系列，底层走的是MODBUS-RTU协议，地址说明参见标记<br />
            Huichuan's serial communication protocol is suitable for H5U series. The bottom layer is MODBUS-RTU protocol. 
            For the address description, please refer to the mark
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Inovance.InovanceH5UTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.#ctor">
            <summary>
            实例化一个汇川串口协议的客户端对象<br />
            Instantiate a client object of Huichuan serial protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.#ctor(System.Byte)">
            <summary>
            指定客户端自己的站号来初始化<br />
            Specify the client's own station number to initialize
            </summary>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5USerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceH5UTcp">
            <summary>
            汇川的网络通信协议，适用于H5U 系列，底层走的是MODBUS-TCP协议，地址说明参见标记<br />
            Huichuan's network communication protocol is suitable for H5U series. 
            The bottom layer is MODBUS-TCP protocol. For the address description, please refer to the mark
            </summary>
            <remarks>
            H5U 系列控制器支持 M/B/S/X/Y 等 bit 型变量（也称线圈） 的访问、 D/R 等 word 型变量的访问；<br />
            其中 M/B/S/X/Y 等 bit 型变量的访问， 是以不同的地址偏移来区分的， D/R 等 word 型变量的访问， 也是以不同的地址偏移来区分的；<br />
            H5U 控制器内部 W 元件， 不支持通信访问。<br /><br />
            我们来看看本组件支持的地址类型及范围，首先是位操作的地址
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄电器</term>
                <term>M</term>
                <term>M0-M7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>B</term>
                <term>B0-B32767</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>S0-S4095</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入</term>
                <term>X</term>
                <term>X0-X1777 或者X0.0-X177.7</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出</term>
                <term>Y</term>
                <term>Y0-Y1777 或者Y0.0-Y177.7</term>
                <term>8</term>
                <term></term>
              </item>
            </list>
            然后是字操作的地址
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D0-D7999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>R0-R32767</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.#ctor">
            <summary>
            实例化一个安川H5U 系列的网络通讯协议<br />
            Instantiate a network communication protocol of Yaskawa H5U series
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            指定服务器地址，端口号，客户端自己的站号来实例化一个安川H5U 系列的网络通讯协议<br />
            Specify the server address, port number, and client's own station number to instantiate a Yaskawa H5U series network communication protocol
            </summary>
            <param name="ipAddress">服务器的Ip地址</param>
            <param name="port">服务器的端口号</param>
            <param name="station">客户端自身的站号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Read(System.String,System.UInt16)">
            <summary>
            按字读取汇川PLC的数据信息，可以输入D0,R0 类型地址<br />
            Read Huichuan PLC's data information by word, you can enter D0, R0 type address
            </summary>
            <param name="address">PLC的真实的地址信息，可以输入D0,R0 类型地址</param>
            <param name="length">读取的数据的长度，按照字为单位</param>
            <returns>包含是否成功的结果对象信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Byte[])">
            <summary>
            按字写入汇川PLC的数据信息，可以输入D0,R0 类型地址<br />
            Data information written into Huichuan PLC by word, can enter D0, R0 type
            </summary>
            <param name="address">PLC的真实的地址信息，可以输入D0,R0 类型地址</param>
            <param name="value">等待写入的原始数据，长度为2的倍数</param>
            <returns>是否写入成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            按位读取汇川PLC的数据信息，可以输入M0,B0,S0,X0,Y0<br />
            Read the data of Huichuan PLC bit by bit, you can enter M0, B0, S0, X0, Y0
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，可以输入M0,B0,S0,X0,Y0</param>
            <param name="length">等待读取的长度，按照位为单位</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Boolean[])">
            <summary>
            按位写入汇川PLC的数据信息，可以输入M0,B0,S0,X0,Y0<br />
            Write the data information of Huichuan PLC bit by bit, you can enter M0, B0, S0, X0, Y0
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，可以输入M0,B0,S0,X0,Y0</param>
            <param name="values">等待写入的原始数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Boolean)">
            <summary>
            写入汇川PLC一个bool数据，可以输入M0,B0,S0,X0,Y0<br />
            Write a bool data to Huichuan PLC, you can enter M0, B0, S0, X0, Y0
            </summary>
            <param name="address">汇川PLC的真实的位地址信息，可以输入M0,B0,S0,X0,Y0</param>
            <param name="value">bool数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.Int16)">
            <summary>
            写入汇川PLC的一个字数据，可以输入D0,R0 类型地址<br />
            Write a word of data to Huichuan PLC, you can enter D0, R0 type address
            </summary>
            <param name="address">汇川PLC的真实地址，可以输入D0,R0 类型地址</param>
            <param name="value">short数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.Write(System.String,System.UInt16)">
            <summary>
            写入汇川PLC的一个字数据，可以输入D0,R0 类型地址>br />
            Write a word of data to Huichuan PLC, you can enter D0, R0 type address
            </summary>
            <param name="address">汇川PLC的真实地址，可以输入D0,R0 类型地址</param>
            <param name="value">ushort数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceH5UTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Inovance.InovanceHelper">
            <summary>
            安川机器人的辅助类，提供一些地址解析的方法<br />
            Auxiliary class of Yaskawa robot, providing some methods of address resolution
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceAMAddress(System.String,System.Byte)">
            <summary>
            根据安川PLC的地址，解析出转换后的modbus协议信息
            </summary>
            <param name="address">安川plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceH3UAddress(System.String,System.Byte)">
            <summary>
            根据安川PLC的地址，解析出转换后的modbus协议信息，适用H3U系列
            </summary>
            <param name="address">安川plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Inovance.InovanceHelper.PraseInovanceH5UAddress(System.String,System.Byte)">
            <summary>
            根据安川PLC的地址，解析出转换后的modbus协议信息，适用H5U系列
            </summary>
            <param name="address">安川plc的地址信息</param>
            <param name="modbusCode">原始的对应的modbus信息</param>
            <returns>还原后的modbus地址</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceDataType">
            <summary>
            Keyence PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceDataType.#ctor(System.Byte,System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Keyence.KeyenceDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceDataType.CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet">
            <summary>
            基恩士PLC的数据通信类，使用QnA兼容3E帧的通信协议实现，使用ASCII的格式，地址格式需要进行转换成三菱的格式，详细参照备注说明<br />
            Keyence PLC's data communication class is implemented using QnA compatible 3E frame communication protocol. 
            It uses ascii format. The address format needs to be converted to Mitsubishi format.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Keyence.KeyenceMcNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceMcNet">
            <summary>
            基恩士PLC的数据通信类，使用QnA兼容3E帧的通信协议实现，使用二进制的格式，地址格式需要进行转换成三菱的格式，详细参照备注说明<br />
            Keyence PLC's data communication class is implemented using QnA compatible 3E frame communication protocol. 
            It uses binary format. The address format needs to be converted to Mitsubishi format.
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>KV-7500/7300</term>
                <term>KV-5500/5000/3000</term>
                <term>KV Nano</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>R00000~R99915</term>
                <term>R00000~R99915</term>
                <term>R00000～R59915</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term>B0000~B7FFF</term>
                <term>B0000~B3FFF</term>
                <term>B0000~B1FFF</term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>MR00000~MR99915</term>
                <term>MR00000~MR99915</term>
                <term>MR00000～MR59915</term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>LR00000~LR99915</term>
                <term>LR00000~LR99915</term>
                <term>LR00000～LR19915</term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>SM</term>
                <term>SM100,SM200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>CR0000~CR7915</term>
                <term>CR0000~CR3915</term>
                <term>CR0000～CR8915</term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>SD</term>
                <term>SD100,SD200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>CM0000~CM5999</term>
                <term>CM0000~CM5999</term>
                <term>CM0000～CM8999</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>DM00000~DM65534</term>
                <term>DM00000~DM65534</term>
                <term>DM00000～DM32767</term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>D</term>
                <term>D100000~D165534</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>EM00000~EM65534</term>
                <term>EM00000~EM65534</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>FM00000~FM32767</term>
                <term>FM00000~FM32767</term>
                <term>×</term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>ZF000000~ZF524287</term>
                <term>ZF000000~ZF131071</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term>W0000~7FFF</term>
                <term>W0000~3FFF</term>
                <term>W0000~3FFF</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>T0000~T3999</term>
                <term>T0000~T3999</term>
                <term>T000～T511</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>C0000~C3999</term>
                <term>C0000~C3999</term>
                <term>C000～C255</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor">
            <summary>
            实例化基恩士的Qna兼容3E帧协议的通讯对象<br />
            Instantiate Keyence Qna compatible 3E frame protocol communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化一个基恩士的Qna兼容3E帧协议的通讯对象<br />
            Specify an IP address and port number to instantiate a Keynes Qna compatible 3E frame protocol communication object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerial">
            <summary>
            基恩士KV上位链路串口通信的对象,适用于Nano系列串口数据,KV1000以及L20V通信模块，地址格式参考api文档<br />
            Keyence KV upper link serial communication object, suitable for Nano series serial data, and L20V communication module, please refer to api document for address format
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.#ctor">
            <summary>
            实例化基恩士的串口协议的通讯对象<br />
            Instantiate the communication object of Keyence's serial protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.InitializationOnOpen">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ExtraOnClose">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp">
            <summary>
            基恩士KV上位链路串口通信的对象,适用于Nano系列串口数据,以及L20V通信模块，本类是基于tcp通信方式的类<br />
            Keyence KV upper link serial communication object, suitable for Nano series serial data and L20V communication module, this class is a class based on TCP communication method
            </summary>
            <remarks>
            当读取Bool的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>继电器</term>
                <term>R</term>
                <term>R0,R100</term>
                <term>0-59915</term>
                <term></term>
              </item>
              <item>
                <term>控制继电器</term>
                <term>CR</term>
                <term>CR0,CR100</term>
                <term>0-3915</term>
                <term></term>
              </item>
              <item>
                <term>内部辅助继电器</term>
                <term>MR</term>
                <term>MR0,MR100</term>
                <term>0-99915</term>
                <term></term>
              </item>
              <item>
                <term>锁存继电器</term>
                <term>LR</term>
                <term>LR0,LR100</term>
                <term>0-99915</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>0-3999</term>
                <term>通断</term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>0-3999</term>
                <term>通断</term>
              </item>
              <item>
                <term>高速计数器</term>
                <term>CTH</term>
                <term>CTH0,CTH1</term>
                <term>0-1</term>
                <term>通断</term>
              </item>
            </list>
            读取数据的地址如下：
            
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据存储器</term>
                <term>DM</term>
                <term>DM0,DM100</term>
                <term>0-65534</term>
                <term></term>
              </item>
              <item>
                <term>控制存储器</term>
                <term>CM</term>
                <term>CM0,CM100</term>
                <term>0-11998</term>
                <term></term>
              </item>
              <item>
                <term>临时数据存储器</term>
                <term>TM</term>
                <term>TM0,TM100</term>
                <term>0-511</term>
                <term></term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>EM</term>
                <term>EM0,EM100</term>
                <term>0-65534</term>
                <term></term>
              </item>
              <item>
                <term>扩展数据存储器</term>
                <term>FM</term>
                <term>FM0,FM100</term>
                <term>0-32766</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z1,Z5</term>
                <term>1-12</term>
                <term></term>
              </item>
              <item>
                <term>数字微调器</term>
                <term>AT</term>
                <term>AT0,AT5</term>
                <term>0-7</term>
                <term></term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>0-3999</term>
                <term>当前值(current value), 读int</term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>0-3999</term>
                <term>当前值(current value), 读int</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来初始化对象<br />
            Initialize the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址数据</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ExtraOnDisconnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ConnectCmd">
            <summary>
            连接PLC的命令报文<br />
            Command message to connect to PLC
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.DisConnectCmd">
            <summary>
            断开PLC连接的命令报文<br />
            Command message to disconnect PLC
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            建立读取PLC数据的指令，需要传入地址数据，以及读取的长度，地址示例参照类的说明文档<br />
            To create a command to read PLC data, you need to pass in the address data, and the length of the read. For an example of the address, refer to the class documentation
            </summary>
            <param name="address">软元件地址</param>
            <param name="length">读取长度</param>
            <returns>是否建立成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            建立写入PLC数据的指令，需要传入地址数据，以及写入的数据信息，地址示例参照类的说明文档<br />
            To create a command to write PLC data, you need to pass in the address data and the written data information. For an example of the address, refer to the class documentation
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的数据</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.BuildWriteCommand(System.String,System.Boolean)">
            <summary>
            建立写入bool数据的指令，针对地址类型为 R,CR,MR,LR<br />
            Create instructions to write bool data, address type is R, CR, MR, LR
            </summary>
            <param name="address">软元件地址</param>
            <param name="value">转换后的数据</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.CheckPlcReadResponse(System.Byte[])">
            <summary>
            校验读取返回数据状态，主要返回的第一个字节是不是E<br />
            Check the status of the data returned from reading, whether the first byte returned is E
            </summary>
            <param name="ack">反馈信息</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.CheckPlcWriteResponse(System.Byte[])">
            <summary>
            校验写入返回数据状态，检测返回的数据是不是OK<br />
            Verify the status of the returned data written and check whether the returned data is OK
            </summary>
            <param name="ack">反馈信息</param>
            <returns>是否成功的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ExtractActualBoolData(System.String,System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼Bool操作<br />
            Refine Bool operation from data fed back from PLC
            </summary>
            <param name="addressType">地址的数据类型</param>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.ExtractActualData(System.String,System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作<br />
            Refining operation from data fed back from PLC
            </summary>
            <param name="addressType">地址的数据类型</param>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Keyence.KeyenceNanoSerialOverTcp.KvAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的Keyence地址类型<br />
            Parse data addresses into different keyence address types
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode">
            <summary>
            Knx协议
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode.ReturnData">
            <summary>
            返回数据的委托
            </summary>
            <param name="data"></param>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.Return_data_msg">
            <summary>
            返回需要写入KNX总线的应答报文（应答数据）
            </summary>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.Set_knx_data">
            <summary>
            返回需要写入的KNX系统的报文（写入数据）
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxCode.GetData">
            <summary>
            获取数据的委托
            </summary>
            <param name="addr"></param>
            <param name="len"></param>
            <param name="data"></param>
        </member>
        <member name="E:HslCommunication.Profinet.Knx.KnxCode.GetData_msg">
            <summary>
            返回从knx系统得到的数据
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.SequenceCounter">
            <summary>
            序号计数
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.Channel">
            <summary>
            通道
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxCode.IsConnect">
            <summary>
            连接状态
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Disconnect_knx(System.Byte,System.Net.IPEndPoint)">
            <summary>
            关闭KNX连接
            </summary>
            <param name="channel">通道号</param>
            <param name="IP_PROT">本机IP</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Handshake(System.Net.IPEndPoint)">
            <summary>
            返回握手报文
            </summary>
            <param name="IP_PROT">本机ip地址</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.KNX_check(System.Byte[])">
            <summary>
            KNX报文解析
            </summary>
            <param name="in_data"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Knx_Write(System.Int16,System.Byte,System.Byte[])">
            <summary>
            写入数据到KNX系统
            </summary>
            <param name="addr">地址</param>
            <param name="len">长度</param>
            <param name="data">数据</param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Knx_Resd_step1(System.Int16)">
            <summary>
            从KNX获取数据
            </summary>
            <param name="addr"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.knx_server_is_real(System.Net.IPEndPoint)">
            <summary>
            连接保持（每隔1s发送一次到设备）
            </summary>
            <param name="IP_PROT"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Return_status">
            <summary>
            返回连接状态
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Extraction_of_Channel(System.Byte[])">
            <summary>
            从握手回复报文获取通道号
            </summary>
            <param name="in_data"></param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Read_com_CEMI(System.Byte[])">
            <summary>
            解析控制包头和CEMI
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxCode.Read_CEMI(System.Byte[])">
             <summary>
            具体解析CEMI 
             </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Knx.KnxUdp">
            <summary>
            Knx驱动，具体的用法参照demo
            </summary>
            <remarks>
            感谢上海NULL提供的技术支持
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.Channel">
            <summary>
            通道号（由设备发来）
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.RouEndpoint">
            <summary>
            远程ip地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.LocalEndpoint">
            <summary>
            本机IP地址
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.LogNet">
            <summary>
            系统的日志信息
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.IsConnect">
            <summary>
            当前的状态是否连接中
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Knx.KnxUdp.KnxCode">
            <summary>
            通信指令类
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.ConnectKnx">
            <summary>
            和KNX网络进行握手并开始监听
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.KeepConnection">
            <summary>
            保持KNX连接
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.DisConnectKnx">
            <summary>
            关闭连接
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.SetKnxData(System.Int16,System.Byte,System.Byte[])">
            <summary>
            将报文写入KNX系统
            </summary>
            <param name="addr">地址</param>
            <param name="len">长度</param>
            <param name="data">数据</param>
        </member>
        <member name="M:HslCommunication.Profinet.Knx.KnxUdp.ReadKnxData(System.Int16)">
            <summary>
            读取指定KNX组地址
            </summary>
            <param name="addr">地址</param>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSCpuInfo">
            <summary>
            It is determined to be the XGK/I/R series through a reserved area
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSCpuStatus">
            <summary>
            Cpu status
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.RUN">
            <summary>
            运行中
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.STOP">
            <summary>
            运行停止
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.ERROR">
            <summary>
            错误状态
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.LSIS.LSCpuStatus.DEBUG">
            <summary>
            调试模式
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.FlagBit">
            <summary>
            using FlagBit in Marker for Byte<br />
            M0.0=1;M0.1=2;M0.2=4;M0.3=8;==========================>M0.7=128
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.LSisServer">
            <summary>
            LSisServer
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.#ctor(System.String)">
            <summary>
            LSisServer  
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.LSisServer.SetCpuType">
            <summary>
            set plc
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ReadBool(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.CheckAddress(System.String)">
            <summary>
            Check the intput string address
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.StartSerialPort(System.String)">
            <summary>
            使用默认的参数进行初始化串口，9600波特率，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.StartSerialPort(System.String,System.Int32)">
            <summary>
            使用默认的参数进行初始化串口，8位数据位，无奇偶校验，1位停止位
            </summary>
            <param name="com">串口信息</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.StartSerialPort(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            使用自定义的初始化方法初始化串口的参数
            </summary>
            <param name="inni">初始化信息的委托</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.CloseSerialPort">
            <summary>
            关闭串口
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.SerialPort_DataReceived(System.Object,System.IO.Ports.SerialDataReceivedEventArgs)">
            <summary>
            接收到串口数据的时候触发
            </summary>
            <param name="sender">串口对象</param>
            <param name="e">消息</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.LSisServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBCnet">
            <summary>
            XGB Cnet I/F module supports Serial Port.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.LSIS.XGBCnetOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBCnet.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ReadCoil(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteCoil(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.LSIS.XGBCnet.WriteCoil(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBCnetOverTcp">
            <summary>
            XGB Cnet I/F module supports Serial Port. On Tcp/ip implementation
            </summary>
            <remarks>
            Address example likes the follow
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>*</term>
                <term>P</term>
                <term>PX100,PB100,PW100,PD100,PL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>M</term>
                <term>MX100,MB100,MW100,MD100,ML100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>L</term>
                <term>LX100,LB100,LW100,LD100,LL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>K</term>
                <term>KX100,KB100,KW100,KD100,KL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>F</term>
                <term>FX100,FB100,FW100,FD100,FL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>TX100,TB100,TW100,TD100,TL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>CX100,CB100,CW100,CD100,CL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>DX100,DB100,DW100,DD100,DL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>SX100,SB100,SW100,SD100,SL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>QX100,QB100,QW100,QD100,QL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>IX100,IB100,IW100,ID100,IL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>N</term>
                <term>NX100,NB100,NW100,ND100,NL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>U</term>
                <term>UX100,UB100,UW100,UD100,UL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Z</term>
                <term>ZX100,ZB100,ZW100,ZD100,ZL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>RX100,RB100,RW100,RD100,RL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Station">
            <summary>
            PLC Station No.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String)">
            <summary>
            ReadCoil, same as ReadBool
            </summary>
            <param name="address">address, for example: MX100, PX100</param>
            <returns>Result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ReadCoil(System.String,System.UInt16)">
            <summary>
            ReadCoil, same as ReadBool
            </summary>
            <param name="address">address, for example: MX100, PX100</param>
            <param name="length">array length</param>
            <returns>result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start Address</param>
            <param name="value">value for write</param>
            <returns>whether write is success</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            AnalysisAddress IX0.0.0 QX0.0.0  MW1.0  MB1.0
            </summary>
            <param name="address"></param>
            <param name="QI"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.AnalysisAddress(System.String)">
            <summary>
            AnalysisAddress
            </summary>
            <param name="address">start address</param>
            <returns>analysis result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildReadByteCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            reading address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="length">read length</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildReadOneCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            One reading address Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: MX100, PX100</param>
            <param name="length">read length</param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            build read command. 
            </summary>
            <param name="station">station</param>
            <param name="address">start address</param>
            <param name="length">address length</param>
            <returns> command</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildWriteByteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildWriteOneCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of One
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            write data to address  Type of ReadByte
            </summary>
            <param name="station">plc station</param>
            <param name="address">address, for example: M100, D100, DW100</param>
            <param name="value">source value</param>
            <returns>command bytes</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBCnetOverTcp.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            Extract actual data form plc response
            </summary>
            <param name="response">response data</param>
            <param name="isRead">read</param>
            <returns>result</returns>
        </member>
        <member name="T:HslCommunication.Profinet.LSIS.XGBFastEnet">
            <summary>
            XGB Fast Enet I/F module supports open Ethernet. It provides network configuration that is to connect LSIS and other company PLC, PC on network
            </summary>
            <remarks>
            Address example likes the follow
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>*</term>
                <term>P</term>
                <term>PX100,PB100,PW100,PD100,PL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>M</term>
                <term>MX100,MB100,MW100,MD100,ML100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>L</term>
                <term>LX100,LB100,LW100,LD100,LL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>K</term>
                <term>KX100,KB100,KW100,KD100,KL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>*</term>
                <term>F</term>
                <term>FX100,FB100,FW100,FD100,FL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>T</term>
                <term>TX100,TB100,TW100,TD100,TL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>C</term>
                <term>CX100,CB100,CW100,CD100,CL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>D</term>
                <term>DX100,DB100,DW100,DD100,DL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>S</term>
                <term>SX100,SB100,SW100,SD100,SL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Q</term>
                <term>QX100,QB100,QW100,QD100,QL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>I</term>
                <term>IX100,IB100,IW100,ID100,IL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>N</term>
                <term>NX100,NB100,NW100,ND100,NL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>U</term>
                <term>UX100,UB100,UW100,UD100,UL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>Z</term>
                <term>ZX100,ZB100,ZW100,ZD100,ZL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term></term>
                <term>R</term>
                <term>RX100,RB100,RW100,RD100,RL100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor">
            <summary>
            Instantiate a Default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor(System.String,System.Int32)">
            <summary>
            Instantiate a object by ipaddress and port
            </summary>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">the port of the plc, default is 2004</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.#ctor(System.String,System.String,System.Int32,System.Byte)">
            <summary>
            Instantiate a object by ipaddress, port, cpuType, slotNo
            </summary>
            <param name="CpuType">CpuType</param>
            <param name="ipAddress">the ip address of the plc</param>
            <param name="port">he port of the plc, default is 2004</param>
            <param name="slotNo">slot number</param>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.SetCpuType">
            <summary>
            set plc
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuType">
            <summary>
            CPU TYPE
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuError">
            <summary>
            Cpu is error
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.LSCpuStatus">
            <summary>
            RUN, STOP, ERROR, DEBUG
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.BaseNo">
            <summary>
            FEnet I/F module’s Base No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.SlotNo">
            <summary>
            FEnet I/F module’s Slot No.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CpuInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.LSIS.XGBFastEnet.CompanyID">
            <summary>
            
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadCoil(System.String,System.UInt16)">
            <summary>
            ReadCoil
            </summary>
            <param name="address">Start address</param>
            <param name="length">read address length</param>
            <returns>Whether to read the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ReadByte(System.String)">
            <summary>
            Read single byte value from plc
            </summary>
            <param name="address">Start address</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Byte)">
            <summary>
            Write single byte value to plc
            </summary>
            <param name="address">Start address</param>
            <param name="value">value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.WriteCoil(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.Write(System.String,System.Boolean)">
            <summary>
            WriteCoil
            </summary>
            <param name="address">Start address</param>
            <param name="value">bool value</param>
            <returns>Whether to write the successful</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.CalculateAddressStarted(System.String,System.Boolean)">
            <summary>
            AnalysisAddress IX0.0.0 QX0.0.0  MW1.0  MB1.0
            </summary>
            <param name="address">start address</param>
            <param name="QI">is Q or I data</param>
            <returns>int address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.IsHex(System.String)">
            <summary>
            NumberStyles HexNumber
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            AnalysisAddress
            </summary>
            <param name="address">start address</param>
            <param name="IsReadWrite">is read or write operate</param>
            <returns>analysis result</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetDataTypeToAddress(System.String)">
            <summary>
            Get DataType to Address
            </summary>
            <param name="address">address</param>
            <returns>dataType</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.ExtractActualData(System.Byte[])">
            <summary>
            Returns true data content, supports read and write returns
            </summary>
            <param name="response">response data</param>
            <returns>real data</returns>
        </member>
        <member name="M:HslCommunication.Profinet.LSIS.XGBFastEnet.GetErrorDesciption(System.Byte)">
            <summary>
            get the description of the error code meanning
            </summary>
            <param name="code">code value</param>
            <returns>string information</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet">
            <summary>
            三菱PLC通讯协议，采用A兼容1E帧协议实现，使用ASCII码通讯，请根据实际型号来进行选取<br />
            Mitsubishi PLC communication protocol, implemented using A compatible 1E frame protocol, using ascii code communication, please choose according to the actual model
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecA1ENet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口来来实例化一个默认的对象<br />
            Specify the IP address and port to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.PLCNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecA1ENet.PLCNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">指示是否按照位成批的读出</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildWriteWordCommand(System.String,System.Byte[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.BuildWriteBoolCommand(System.String,System.Boolean[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.CheckResponseLegal(System.Byte[])">
            <summary>
            检测反馈的消息是否合法
            </summary>
            <param name="response">接收的报文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EAsciiNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1EDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1EDataType.#ctor(System.Byte[],System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.DataCode">
            <summary>
            类型的代号值（软元件代码，用于区分软元件类型，如：D，R）
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1EDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.X">
            <summary>
            X输入寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.Y">
            <summary>
            Y输出寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.M">
            <summary>
            M中间寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.S">
            <summary>
            S状态寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.F">
            <summary>
            F报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.B">
            <summary>
            B连接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TS">
            <summary>
            TS定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TC">
            <summary>
            TC定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.TN">
            <summary>
            TN定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CS">
            <summary>
            CS计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CC">
            <summary>
            CC计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.CN">
            <summary>
            CN计数器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.W">
            <summary>
            W链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecA1EDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA1ENet">
            <summary>
            三菱PLC通讯协议，采用A兼容1E帧协议实现，使用二进制码通讯，请根据实际型号来进行选取<br />
            Mitsubishi PLC communication protocol, implemented using A compatible 1E frame protocol, using binary code communication, please choose according to the actual model
            </summary>
            <remarks>
            本类适用于的PLC列表
            <list type="number">
            <item>FX3U(C) PLC   测试人sandy_liao</item>
            </list>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>动态</term>
                <term>√</term>
                <term>√</term>
                <term>地址前面带0就是8进制比如X010，不带则是16进制，X40</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>动态</term>
                <term>√</term>
                <term>√</term>
                <term>地址前面带0就是8进制比如Y020，不带则是16进制，Y40</term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B1A0,B2A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器触点</term>
                <term>TS</term>
                <term>TS0,TS100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器线圈</term>
                <term>TC</term>
                <term>TC0,TC100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器当前值</term>
                <term>TN</term>
                <term>TN0,TN100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器器触点</term>
                <term>CS</term>
                <term>CS0,CS100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器线圈</term>
                <term>CC</term>
                <term>CC0,CC100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器当前值</term>
                <term>CN</term>
                <term>CN0,CN100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W0,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            <see cref="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)"/> 方法一次读取的最多点数是256点。
            <note type="important">本通讯类由CKernal推送，感谢</note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口来来实例化一个默认的对象<br />
            Specify the IP address and port to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA1ENet.PLCNumber">
            <summary>
            PLC编号，默认为0xFF<br />
            PLC number, default is 0xFF
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取<see cref="T:System.Boolean"/>数组信息，需要指定地址和长度，地址示例M100，S100，B1A，如果是X,Y, X017就是8进制地址，Y10就是16进制地址。<br />
            Batch read <see cref="T:System.Boolean"/> array information, need to specify the address and length, return <see cref="T:System.Boolean"/> array. 
            Examples of addresses M100, S100, B1A, if it is X, Y, X017 is an octal address, Y10 is a hexadecimal address.
            </summary>
            <remarks>
            根据协议的规范，最多读取256长度的bool数组信息，如果需要读取更长的bool信息，需要按字为单位进行读取的操作。
            </remarks>
            <param name="address">数据地址</param>
            <param name="length">数据长度</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否成功，地址示例M100，S100，B1A，如果是X,Y, X017就是8进制地址，Y10就是16进制地址。<br />
            Batch write <see cref="T:System.Boolean"/> array data, return whether the write was successful. 
            Examples of addresses M100, S100, B1A, if it is X, Y, X017 is an octal address, Y10 is a hexadecimal address.
            </summary>
            <param name="address">起始地址</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildReadCommand(System.String,System.UInt16,System.Boolean,System.Byte)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">指示是否按照位成批的读出</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildWriteWordCommand(System.String,System.Byte[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.BuildWriteBoolCommand(System.String,System.Boolean[],System.Byte)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值</param>
            <param name="plcNumber">PLC编号</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.CheckResponseLegal(System.Byte[])">
            <summary>
            检测反馈的消息是否合法
            </summary>
            <param name="response">接收的报文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA1ENet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA3CNet1">
            <summary>
            基于Qna 兼容3C帧的格式一的通讯，具体的地址需要参照三菱的基本地址<br />
            Based on Qna-compatible 3C frame format one communication, the specific address needs to refer to the basic address of Mitsubishi.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNet1.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp">
            <summary>
            基于Qna 兼容3C帧的格式一的通讯，具体的地址需要参照三菱的基本地址，本类是基于tcp通讯的实现<br />
            Based on Qna-compatible 3C frame format one communication, the specific address needs to refer to the basic address of Mitsubishi. This class is based on TCP communication.
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.#ctor">
            <summary>
            实例化默认的对象<br />
            Instantiate the default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化对象<br />
            Specify the IP address and port number to instantiate the object
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Station">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            Read PLC data in batches, in units of words, supports reading X, Y, M, S, D, T, C. The specific address range needs to be confirmed according to the PLC model
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            The data written to the PLC in batches is in units of words, that is, at least 2 bytes of information. It supports X, Y, M, S, D, T, and C. The specific address range needs to be confirmed according to the PLC model.
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Read bool data in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Write arrays of type bool in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadHelper(System.String,System.UInt16,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="readCore">通信的载体信息</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.WriteHelper(System.String,System.Byte[],System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <param name="readCore">通信的载体信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadBoolHelper(System.String,System.UInt16,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <param name="readCore">通信的载体信息</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.WriteHelper(System.String,System.Boolean[],System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <param name="readCore">通信的载体信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteRunHelper(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            远程Run操作
            </summary>
            <param name="readCore">通信的载体信息</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.RemoteStopHelper(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            远程Stop操作
            </summary>
            <param name="readCore">通信的载体信息</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.ReadPlcTypeHelper(System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            读取PLC的型号信息
            </summary>
            <param name="readCore">通信的载体信息</param>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecA3CNet1OverTcp.PackCommand(System.Byte[],System.Byte)">
            <summary>
            将命令进行打包传送
            </summary>
            <param name="mcCommand">mc协议的命令</param>
            <param name="station">PLC的站号</param>
            <returns>最终的原始报文信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxLinks">
            <summary>
            三菱计算机链接协议，适用FX3U系列，FX3G，FX3S等等系列，通常在PLC侧连接的是485的接线口<br />
            Mitsubishi Computer Link Protocol, suitable for FX3U series, FX3G, FX3S, etc., usually the 485 connection port is connected on the PLC side
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Station"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.WaittingTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WaittingTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinks.SumCheck">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.SumCheck"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.StartPLC">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.StopPLC">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinks.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp">
            <summary>
            三菱计算机链接协议的网口版本，适用FX3U系列，FX3G，FX3S等等系列，通常在PLC侧连接的是485的接线口<br />
            Network port version of Mitsubishi Computer Link Protocol, suitable for FX3U series, FX3G, FX3S, etc., usually the 485 connection port is connected on the PLC side
            </summary>
            <remarks>
            支持的通讯的系列如下参考
            <list type="table">
                <listheader>
                    <term>系列</term>
                    <term>是否支持</term>
                    <term>备注</term>
                </listheader>
                <item>
                    <description>FX3UC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3U系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3GC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3G系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX3S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2N系列</description>
                    <description>部分支持(v1.06+)</description>
                    <description>通过监控D8001来确认版本号</description>
                </item>
                <item>
                    <description>FX1NC系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1N系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1S系列</description>
                    <description>支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0N系列</description>
                    <description>部分支持(v1.20+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0S系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX0系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2C系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX2(FX)系列</description>
                    <description>部分支持(v3.30+)</description>
                    <description></description>
                </item>
                <item>
                    <description>FX1系列</description>
                    <description>不支持</description>
                    <description></description>
                </item>
            </list>
            数据地址支持的格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X10,X20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>8</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor">
            <summary>
            实例化默认的对象<br />
            Instantiate the default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化默认的对象<br />
            Specify the IP address and port number to instantiate the default object
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Station">
            <summary>
            PLC的当前的站号，需要根据实际的值来设定，默认是0<br />
            The current station number of the PLC needs to be set according to the actual value. The default is 0.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.WaittingTime">
            <summary>
            报文等待时间，单位10ms，设置范围为0-15<br />
            Message waiting time, unit is 10ms, setting range is 0-15
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.SumCheck">
            <summary>
            是否启动和校验<br />
            Whether to start and sum verify
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Read(System.String,System.UInt16)">
            <summary>
            批量读取PLC的数据，以字为单位，支持读取X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            Read PLC data in batches, in units of words, supports reading X, Y, M, S, D, T, C. The specific address range needs to be confirmed according to the PLC model
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Byte[])">
            <summary>
            批量写入PLC的数据，以字为单位，也就是说最少2个字节信息，支持X,Y,M,S,D,T,C，具体的地址范围需要根据PLC型号来确认<br />
            The data written to the PLC in batches is in units of words, that is, at least 2 bytes of information. It supports X, Y, M, S, D, T, and C. The specific address range needs to be confirmed according to the PLC model.
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取bool类型数据，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Read bool data in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">地址信息，比如X10,Y17，注意X，Y的地址是8进制的</param>
            <param name="length">读取的长度</param>
            <returns>读取结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.Write(System.String,System.Boolean[])">
            <summary>
            批量写入bool类型的数组，支持的类型为X,Y,S,T,C，具体的地址范围取决于PLC的类型<br />
            Write arrays of type bool in batches. The supported types are X, Y, S, T, C. The specific address range depends on the type of PLC.
            </summary>
            <param name="address">PLC的地址信息</param>
            <param name="value">数据信息</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StartPLC">
            <summary>
            启动PLC<br />
            Start Plc
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.StopPLC">
            <summary>
            停止PLC<br />
            Stop PLC
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.FxAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.CalculateAcc(System.String)">
            <summary>
            计算指令的和校验码
            </summary>
            <param name="data">指令</param>
            <returns>校验之后的信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean,System.Boolean,System.Byte)">
            <summary>
            创建一条读取的指令信息，需要指定一些参数
            </summary>
            <param name="station">PLCd的站号</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <param name="isBool">是否位读取</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.BuildWriteBoolCommand(System.Byte,System.String,System.Boolean[],System.Boolean,System.Byte)">
            <summary>
            创建一条别入bool数据的指令信息，需要指定一些参数
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.BuildWriteByteCommand(System.Byte,System.String,System.Byte[],System.Boolean,System.Byte)">
            <summary>
            创建一条别入byte数据的指令信息，需要指定一些参数，按照字单位
            </summary>
            <param name="station">站号</param>
            <param name="address">地址</param>
            <param name="value">数组值</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.BuildStart(System.Byte,System.Boolean,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxLinksOverTcp.BuildStop(System.Byte,System.Boolean,System.Byte)">
            <summary>
            创建启动PLC的报文信息
            </summary>
            <param name="station">站号信息</param>
            <param name="sumCheck">是否和校验</param>
            <param name="waitTime">等待时间</param>
            <returns>是否创建成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxSerial">
            <summary>
            三菱的串口通信的对象，适用于读取FX系列的串口数据，支持的类型参考文档说明<br />
            Mitsubishi's serial communication object is suitable for reading serial data of the FX series. Refer to the documentation for the supported types.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="Usage" title="简单的使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp">
            <summary>
            三菱串口协议的网络版
            </summary>
            <remarks>
            字读写地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0-D511,D8000-D8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>TN</term>
                <term>TN10,TN20</term>
                <term>TN0-TN255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>CN</term>
                <term>CN10,CN20</term>
                <term>CN0-CN199,CN200-CN255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            位地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址范围</term>
                <term>地址进制</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>M0-M1023,M8000-M8255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X1,X20</term>
                <term>X0-X177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y10,Y20</term>
                <term>Y0-Y177</term>
                <term>8</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>S0-S999</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器触点</term>
                <term>TS</term>
                <term>TS10,TS20</term>
                <term>TS0-TS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>定时器线圈</term>
                <term>TC</term>
                <term>TC10,TC20</term>
                <term>TC0-TC255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器触点</term>
                <term>CS</term>
                <term>CS10,CS20</term>
                <term>CS0-CS255</term>
                <term>10</term>
                <term></term>
              </item>
              <item>
                <term>计数器线圈</term>
                <term>CC</term>
                <term>CC10,CC20</term>
                <term>CC0-CC255</term>
                <term>10</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="Usage" title="简单的使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.#ctor">
            <summary>
            实例化网络版的三菱的串口协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's serial protocol on the network
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化三菱的串口协议的通讯对象<br />
            Specify the IP address and port number to instantiate the communication object of Mitsubishi's serial protocol
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc/>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc/>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample2" title="Write示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果，该读取地址最好从0，16，32...等开始读取，这样可以读取比较长得数据数组<br />
            Read bit devices from Mitsubishi PLC in batches and return the read result. The read address should preferably be read from 0, 16, 32, etc., so that you can read the longer data array.
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
             <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.Write(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadHelper(System.String,System.UInt16,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            从三菱PLC中读取想要的数据，返回读取结果
            </summary>
            <param name="address">读取地址，，支持的类型参考文档说明</param>
            <param name="length">读取的数据长度</param>
            <param name="readCore">指定的通道信息</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ReadBoolHelper(System.String,System.UInt16,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            从三菱PLC中批量读取位软元件，返回读取结果，该读取地址最好从0，16，32...等开始读取，这样可以读取比较长得数据数组
            </summary>
            <param name="address">起始地址</param>
            <param name="length">读取的长度</param>
            <param name="readCore">指定的通道信息</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
             <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="ReadBool" title="Bool类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.WriteHelper(System.String,System.Byte[],System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型
            </summary>
            <param name="address">初始地址，支持的类型参考文档说明</param>
            <param name="value">原始的字节数据</param>
            <param name="readCore">指定的通道信息</param>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102，D103存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample2" title="Write示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecFxSerial.cs" region="WriteExample1" title="Write示例" />
            </example>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.WriteHelper(System.String,System.Boolean,System.Func{System.Byte[],HslCommunication.OperateResult{System.Byte[]}})">
            <summary>
            强制写入位数据的通断，支持的类型参考文档说明
            </summary>
            <param name="address">地址信息</param>
            <param name="value">是否为通</param>
            <param name="readCore">指定的通道信息</param>
            <returns>是否写入成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.CheckPlcReadResponse(System.Byte[])">
            <summary>
            检查PLC返回的读取数据是否是正常的
            </summary>
            <param name="ack">Plc反馈的数据信息</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.CheckPlcWriteResponse(System.Byte[])">
            <summary>
            检查PLC返回的写入的数据是否是正常的
            </summary>
            <param name="ack">Plc反馈的数据信息</param>
            <returns>检查结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.BuildWriteBoolPacket(System.String,System.Boolean)">
            <summary>
            生成位写入的数据报文信息，该报文可直接用于发送串口给PLC
            </summary>
            <param name="address">地址信息，每个地址存在一定的范围，需要谨慎传入数据。举例：M10,S10,X5,Y10,C10,T10</param>
            <param name="value"><c>True</c>或是<c>False</c></param>
            <returns>带报文信息的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.BuildReadWordCommand(System.String,System.UInt16)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.BuildReadBoolCommand(System.String,System.UInt16)">
            <summary>
            根据类型地址长度确认需要读取的指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="length">bool数组长度</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.BuildWriteWordCommand(System.String,System.Byte[])">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头
            </summary>
            <param name="address">起始地址</param>
            <param name="value">实际的数据信息</param>
            <returns>带有成功标志的指令数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ExtractActualData(System.Byte[])">
            <summary>
            从PLC反馈的数据进行提炼操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.ExtractActualBoolData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从PLC反馈的数据进行提炼bool数组操作
            </summary>
            <param name="response">PLC反馈的真实数据</param>
            <param name="start">起始提取的点信息</param>
            <param name="length">bool数组的长度</param>
            <returns>数据提炼后的真实数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.FxAnalysisAddress(System.String)">
            <summary>
            解析数据地址成不同的三菱地址类型
            </summary>
            <param name="address">数据地址</param>
            <returns>地址结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.FxCalculateWordStartAddress(System.String)">
            <summary>
            返回读取的地址及长度信息
            </summary>
            <param name="address">读取的地址信息</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecFxSerialOverTcp.FxCalculateBoolStartAddress(System.String)">
            <summary>
            返回读取的地址及长度信息，以及当前的偏置信息
            </summary><param name="address">读取的地址信息</param>
            <returns>带起始地址的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecHelper">
            <summary>
            所有三菱通讯类的通用辅助工具类，包含了一些通用的静态方法，可以使用本类来获取一些原始的报文信息。详细的操作参见例子
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.McA1EAnalysisAddress(System.String)">
            <summary>
            解析A1E协议数据地址
            </summary>
            <param name="address">数据地址</param>
            <returns>结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadMcCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildAsciiReadMcCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取Ascii格式的MC的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="isBit">是否进行了位读取操作</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildWriteWordCoreCommand(HslCommunication.Core.Address.McAddressData,System.Byte[])">
            <summary>
            以字为单位，创建数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildAsciiWriteWordCoreCommand(HslCommunication.Core.Address.McAddressData,System.Byte[])">
            <summary>
            以字为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildWriteBitCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildAsciiWriteBitCoreCommand(HslCommunication.Core.Address.McAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建ASCII数据写入的核心报文
            </summary>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadMcCoreExtendCommand(HslCommunication.Core.Address.McAddressData,System.UInt16,System.Boolean)">
            <summary>
            从三菱扩展地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="isBit">是否进行了位读取操作</param>
            <param name="extend">扩展指定</param>
            <param name="addressData">三菱Mc协议的数据地址</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadRandomWordCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            按字为单位随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadRandomCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildAsciiReadRandomWordCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            按字为单位随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildAsciiReadRandomCommand(HslCommunication.Core.Address.McAddressData[])">
            <summary>
            随机读取的指令创建
            </summary>
            <param name="address">地址数组</param>
            <returns>指令</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadTag(System.String[],System.UInt16[])">
            <summary>
            创建批量读取标签的报文数据信息
            </summary>
            <param name="tags">标签名</param>
            <param name="lengths">长度信息</param>
            <returns>报文名称</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.ExtraTagData(System.Byte[])">
            <summary>
            解析出标签读取的数据内容
            </summary>
            <param name="content">返回的数据信息</param>
            <returns>解析结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildReadMemoryCommand(System.String,System.UInt16)">
            <summary>
            读取本站缓冲寄存器的数据信息，需要指定寄存器的地址，和读取的长度
            </summary>
            <param name="address">寄存器的地址</param>
            <param name="length">数据长度</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.GetErrorDescription(System.Int32)">
            <summary>
            根据三菱的错误码去查找对象描述信息
            </summary>
            <param name="code">错误码</param>
            <returns>描述信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.BuildBytesFromAddress(System.Int32,HslCommunication.Profinet.Melsec.MelsecMcDataType)">
            <summary>
            从三菱的地址中构建MC协议的6字节的ASCII格式的地址
            </summary>
            <param name="address">三菱地址</param>
            <param name="type">三菱的数据类型</param>
            <returns>6字节的ASCII格式的地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Byte[])">
            <summary>
            将0，1，0，1的字节数组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.TransBoolArrayToByteData(System.Boolean[])">
            <summary>
            将bool的组压缩成三菱格式的字节数组来表示开关量的
            </summary>
            <param name="value">原始的数据字节</param>
            <returns>压缩过后的数据字节</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.FxCalculateCRC(System.Byte[])">
            <summary>
            计算Fx协议指令的和校验信息
            </summary>
            <param name="data">字节数据</param>
            <returns>校验之后的数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecHelper.CheckCRC(System.Byte[])">
            <summary>
            检查指定的和校验是否是正确的
            </summary>
            <param name="data">字节数据</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为ASCII通讯格式<br />
            Mitsubishi PLC communication class is implemented using Qna compatible 3E frame protocol. 
            The Ethernet module on the PLC side needs to be configured first. It must be ascii communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiNet.CheckResponseContent(System.Byte[])">
            <summary>
            检查反馈的内容是否正确的
            </summary>
            <param name="content">MC的反馈的内容</param>
            <returns>是否正确</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp">
            <summary>
            三菱PLC通讯类，采用UDP的协议实现，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为ascii通讯<br />
            Mitsubishi PLC communication class is implemented using UDP protocol and Qna compatible 3E frame protocol. 
            The Ethernet module needs to be configured first on the PLC side, and it must be ascii communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\MelsecAscii.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcAsciiUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcDataType">
            <summary>
            三菱PLC的数据类型，此处包含了几个常用的类型<br />
            Data types of Mitsubishi PLC, here contains several commonly used types
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcDataType.#ctor(System.Byte,System.Byte,System.String,System.Int32)">
            <summary>
            实例化一个三菱数据类型对象，如果您清楚类型代号，可以根据值进行扩展<br />
            Instantiate a Mitsubishi data type object, if you know the type code, you can expand according to the value
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.M">
            <summary>
            M内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SM">
            <summary>
            SM特殊继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.S">
            <summary>
            S步进继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.L">
            <summary>
            L锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.F">
            <summary>
            F报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.V">
            <summary>
            V边沿继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.B">
            <summary>
            B链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SB">
            <summary>
            SB特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.DX">
            <summary>
            DX直接访问输入
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.DY">
            <summary>
            DY直接访问输出
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.D">
            <summary>
            D数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SD">
            <summary>
            特殊链接存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.W">
            <summary>
            W链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SW">
            <summary>
            SW特殊链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.R">
            <summary>
            R文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Z">
            <summary>
            变址寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.ZR">
            <summary>
            文件寄存器ZR区
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TN">
            <summary>
            定时器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TS">
            <summary>
            定时器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.TC">
            <summary>
            定时器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SS">
            <summary>
            累计定时器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SC">
            <summary>
            累计定时器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.SN">
            <summary>
            累计定时器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CN">
            <summary>
            计数器的当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CS">
            <summary>
            计数器的触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.CC">
            <summary>
            计数器的线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_Y">
            <summary>
            Y输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_M">
            <summary>
            内部辅助继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_SM">
            <summary>
            控制继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_SD">
            <summary>
            控制存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_D">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_ZR">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_W">
            <summary>
            链路寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_TC">
            <summary>
            计时器（线圈）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Keyence_CC">
            <summary>
            计数器（线圈）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_X">
            <summary>
            输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_Y">
            <summary>
            输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_L">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_R">
            <summary>
            内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_DT">
            <summary>
            数据存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_LD">
            <summary>
            链接存储器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_TN">
            <summary>
            计时器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_TS">
            <summary>
            计时器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_CN">
            <summary>
            计数器（当前值）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_CS">
            <summary>
            计数器（接点）
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_SM">
            <summary>
            特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcDataType.Panasonic_SD">
            <summary>
            特殊链接存储器
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcNet">
            <summary>
            三菱PLC通讯类，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为二进制通讯<br />
            Mitsubishi PLC communication class is implemented using Qna compatible 3E frame protocol. 
            The Ethernet module on the PLC side needs to be configured first. It must be binary communication.
            </summary>
            <remarks>
            目前组件测试通过的PLC型号列表，有些来自于网友的测试
            <list type="number">
            <item>Q06UDV PLC  感谢hwdq0012</item>
            <item>fx5u PLC  感谢山楂</item>
            <item>Q02CPU PLC </item>
            <item>L02CPU PLC </item>
            </list>
            地址的输入的格式支持多种复杂的地址表示方式：
            <list type="number">
            <item>扩展的数据地址: 表示为 ext=1;W100  访问扩展区域为1的W100的地址信息</item>
            <item>缓冲存储器地址: 表示为 mem=32  访问地址为32的本站缓冲存储器地址</item>
            <item>基于标签的地址: 表示位 s=AAA  假如标签的名称为AAA，但是标签的读取是有条件的，详细参照<see cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/></item>
            <item>普通的数据地址，参照下面的信息</item>
            </list>
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
               <item>
                <term>锁存继电器</term>
                <term>L</term>
                <term>L100,L200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>报警器</term>
                <term>F</term>
                <term>F100,F200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>边沿继电器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>B</term>
                <term>B100,B1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>步进继电器</term>
                <term>S</term>
                <term>S100,S200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器</term>
                <term>R</term>
                <term>R100,R200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>ZR文件寄存器</term>
                <term>ZR</term>
                <term>ZR100,ZR2A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>变址寄存器</term>
                <term>Z</term>
                <term>Z100,Z200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的触点</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的线圈</term>
                <term>TC</term>
                <term>TC100,TC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>定时器的当前值</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的触点</term>
                <term>SS</term>
                <term>SS100,SS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的线圈</term>
                <term>SC</term>
                <term>SC100,SC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>累计定时器的当前值</term>
                <term>SN</term>
                <term>SN100,SN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的触点</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的线圈</term>
                <term>CC</term>
                <term>CC100,CC200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器的当前值</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor">
            <summary>
            实例化三菱的Qna兼容3E帧协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's Qna compatible 3E frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber">
            <summary>
            网络号，通常为0<br />
            Network number, usually 0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber">
            <summary>
            网络站号，通常为0<br />
            Network station number, usually 0
            </summary>
            <remarks>
            依据PLC的配置而配置，如果PLC配置了1，那么此处也填0，如果PLC配置了2，此处就填2，测试不通的话，继续测试0
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <summary>
            当前MC协议的分析地址的方法，对传入的字符串格式的地址进行数据解析。<br />
            The current MC protocol's address analysis method performs data parsing on the address of the incoming string format.
            </summary>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>解析后的数据信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，但是每个地址只能读取一个word，也就是2个字节的内容。收到结果后，需要自行解析数据<br />
            Randomly read PLC data information, which can be combined across addresses and types, but each address can only read one word, 
            which is the content of 2 bytes. After receiving the results, you need to parse the data yourself
            </summary>
            <param name="address">所有的地址的集合</param>
            <remarks>
            访问安装有 Q 系列 C24/E71 的站 QCPU 上位站 经由 Q 系列兼容网络系统 MELSECNET/H MELSECNET/10 Ethernet 的 QCPU 其他站 时
            访问点数········1≦ 字访问点数 双字访问点数 ≦192
            <br />
            访问 QnACPU 其他站 经由 QnA 系列兼容网络系统 MELSECNET/10 Ethernet 的 Q/QnACPU 其他站 时访问点数········1≦ 字访问点数 双字访问点数 ≦96
            <br />
            访问上述以外的 PLC CPU 其他站 时访问点数········1≦字访问点数≦10
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" /></example>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，每个地址是任意的长度。收到结果后，需要自行解析数据，目前只支持字地址，比如D区，W区，R区，不支持X，Y，M，B，L等等<br />
            Read the data information of the PLC randomly. It can be combined across addresses and types. Each address is of any length. After receiving the results, 
            you need to parse the data yourself. Currently, only word addresses are supported, such as D area, W area, R area. X, Y, M, B, L, etc
            </summary>
            <param name="address">所有的地址的集合</param>
            <param name="length">每个地址的长度信息</param>
            <remarks>
            实际测试不一定所有的plc都可以读取成功，具体情况需要具体分析
            <br />
            1 块数按照下列要求指定 120 ≧ 字软元件块数 + 位软元件块数
            <br />
            2 各软元件点数按照下列要求指定 960 ≧ 字软元件各块的合计点数 + 位软元件各块的合计点数
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16(System.String[])">
            <summary>
            随机读取PLC的数据信息，可以跨地址，跨类型组合，但是每个地址只能读取一个word，也就是2个字节的内容。收到结果后，自动转换为了short类型的数组<br />
            Randomly read PLC data information, which can be combined across addresses and types, but each address can only read one word, 
            which is the content of 2 bytes. After receiving the result, it is automatically converted to an array of type short.
            </summary>
            <param name="address">所有的地址的集合</param>
            <remarks>
            访问安装有 Q 系列 C24/E71 的站 QCPU 上位站 经由 Q 系列兼容网络系统 MELSECNET/H MELSECNET/10 Ethernet 的 QCPU 其他站 时
            访问点数········1≦ 字访问点数 双字访问点数 ≦192
            
            访问 QnACPU 其他站 经由 QnA 系列兼容网络系统 MELSECNET/10 Ethernet 的 Q/QnACPU 其他站 时访问点数········1≦ 字访问点数 双字访问点数 ≦96
            
            访问上述以外的 PLC CPU 其他站 时访问点数········1≦字访问点数≦10
            </remarks>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)">
            <summary>
            读取PLC的标签信息，需要传入标签的名称，读取的字长度，标签举例：A; label[1]; bbb[10,10,10]<br />
            To read the label information of the PLC, you need to pass in the name of the label, 
            the length of the word read, and an example of the label: A; label [1]; bbb [10,10,10]
            </summary>
            <param name="tag">标签名</param>
            <param name="length">读取长度</param>
            <returns>是否成功</returns>
            <remarks>
             不可以访问局部标签。<br />
             不可以访问通过GX Works2设置的全局标签。<br />
             为了访问全局标签，需要通过GX Works3的全局标签设置编辑器将“来自于外部设备的访问”的设置项目置为有效。(默认为无效。)<br />
             以ASCII代码进行数据通信时，由于需要从UTF-16将标签名转换为ASCII代码，因此报文容量将增加
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadTags(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadExtend(System.UInt16,System.String,System.UInt16)">
            <summary>
            读取扩展的数据信息，需要输入扩展值
            </summary>
            <param name="extend">扩展信息</param>
            <param name="address">地址</param>
            <param name="length">数据长度</param>
            <returns>返回结果</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadMemory(System.String,System.UInt16)">
            <summary>
            读取缓冲寄存器的数据信息，地址直接为偏移地址
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>读取的内容</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun">
            <summary>
            远程Run操作<br />
            Remote Run Operation
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop">
            <summary>
            远程Stop操作<br />
            Remote Stop operation
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset">
            <summary>
            远程Reset操作<br />
            Remote Reset Operation
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType">
            <summary>
            读取PLC的型号信息，例如 Q02HCPU<br />
            Read PLC model information, such as Q02HCPU
            </summary>
            <returns>返回型号的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset">
            <summary>
            LED 熄灭 出错代码初始化<br />
            LED off Error code initialization
            </summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.PackMcCommand(System.Byte[],System.Byte,System.Byte)">
            <summary>
            将MC协议的核心报文打包成一个可以直接对PLC进行发送的原始报文
            </summary>
            <param name="mcCore">MC协议的核心报文</param>
            <param name="networkNumber">网络号</param>
            <param name="networkStationNumber">网络站号</param>
            <returns>原始报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ExtractActualData(System.Byte[],System.Boolean)">
            <summary>
            从PLC反馈的数据中提取出实际的数据内容，需要传入反馈数据，是否位读取
            </summary>
            <param name="response">反馈的数据内容</param>
            <param name="isBit">是否位读取</param>
            <returns>解析后的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcNet.CheckResponseContent(System.Byte[])">
            <summary>
            检查从MC返回的数据是否是合法的。
            </summary>
            <param name="content">数据内容</param>
            <returns>是否合法</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcRDataType">
            <summary>
            三菱R系列的PLC的数据类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRDataType.#ctor(System.Byte[],System.Byte,System.String,System.Int32)">
            <summary>
            如果您清楚类型代号，可以根据值进行扩展
            </summary>
            <param name="code">数据类型的代号</param>
            <param name="type">0或1，默认为0</param>
            <param name="asciiCode">ASCII格式的类型信息</param>
            <param name="fromBase">指示地址的多少进制的，10或是16</param>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRDataType.DataCode">
            <summary>
            类型的代号值
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRDataType.DataType">
            <summary>
            数据的类型，0代表按字，1代表按位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRDataType.AsciiCode">
            <summary>
            当以ASCII格式通讯时的类型描述
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRDataType.FromBase">
            <summary>
            指示地址是10进制，还是16进制的
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.X">
            <summary>
            X输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.Y">
            <summary>
            Y输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.M">
            <summary>
            M内部继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.SM">
            <summary>
            特殊继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.L">
            <summary>
            锁存继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.F">
            <summary>
            报警器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.V">
            <summary>
            变址继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.S">
            <summary>
            S步进继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.B">
            <summary>
            链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.SB">
            <summary>
            特殊链接继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.DX">
            <summary>
            直接访问输入继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.DY">
            <summary>
            直接访问输出继电器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.D">
            <summary>
            数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.SD">
            <summary>
            特殊数据寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.W">
            <summary>
            链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.SW">
            <summary>
            特殊链接寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.R">
            <summary>
            文件寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.Z">
            <summary>
            变址寄存器
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LSTS">
            <summary>
            长累计定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LSTC">
            <summary>
            长累计定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LSTN">
            <summary>
            长累计定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.STS">
            <summary>
            累计定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.STC">
            <summary>
            累计定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.STN">
            <summary>
            累计定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LTS">
            <summary>
            长定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LTC">
            <summary>
            长定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LTN">
            <summary>
            长定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.TS">
            <summary>
            定时器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.TC">
            <summary>
            定时器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.TN">
            <summary>
            定时器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LCS">
            <summary>
            长计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LCC">
            <summary>
            长计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.LCN">
            <summary>
            长计数器当前值
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.CS">
            <summary>
            计数器触点
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.CC">
            <summary>
            计数器线圈
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Melsec.MelsecMcRDataType.CN">
            <summary>
            计数器当前值
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcRNet">
            <summary>
            三菱的R系列的MC协议，支持的地址类型和 <see cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet"/> 有区别，详细请查看对应的API文档说明
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.#ctor">
            <summary>
            实例化三菱R系列的Qna兼容3E帧协议的通讯对象<br />
            Instantiate the communication object of Mitsubishi's Qna compatible 3E frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个默认的对象<br />
            Specify the IP address and port number to instantiate a default object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRNet.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcRNet.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.AnalysisAddress(System.String)">
            <summary>
            分析三菱R系列的地址，并返回解析后的数据对象
            </summary>
            <param name="address">字符串地址</param>
            <returns>是否解析成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildReadMcCoreCommand(HslCommunication.Core.Address.McRAddressData,System.Boolean)">
            <summary>
            从三菱地址，是否位读取进行创建读取的MC的核心报文
            </summary>
            <param name="address">地址数据</param>
            <param name="isBit">是否进行了位读取操作</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildWriteWordCoreCommand(HslCommunication.Core.Address.McRAddressData,System.Byte[])">
            <summary>
            以字为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的数据地址</param>
            <param name="value">实际的原始数据信息</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcRNet.BuildWriteBitCoreCommand(HslCommunication.Core.Address.McRAddressData,System.Boolean[])">
            <summary>
            以位为单位，创建数据写入的核心报文
            </summary>
            <param name="address">三菱的地址信息</param>
            <param name="value">原始的bool数组数据</param>
            <returns>带有成功标识的报文对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcServer">
            <summary>
            三菱MC协议的虚拟服务器，支持M,X,Y,D,W的数据池读写操作，支持二进制及ASCII格式进行读写操作，需要在实例化的时候指定。<br />
            The Mitsubishi MC protocol virtual server supports M, X, Y, D, W data pool read and write operations, 
            and supports binary and ASCII format read and write operations, which need to be specified during instantiation.
            </summary>
            <remarks>
            如果你没有可以测试的三菱PLC，想要测试自己开发的上位机软件，或是想要在本机实现虚拟PLC，然后进行IO的输入输出练习，都可以使用本类来实现，先来说明下地址信息
            <br />
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>内部继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X100,X1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y100,Y1A0</term>
                <term>16</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D1000,D2000</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器</term>
                <term>W</term>
                <term>W100,W1A0</term>
                <term>16</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.#ctor(System.Boolean)">
            <summary>
            实例化一个默认参数的mc协议的服务器<br />
            Instantiate a mc protocol server with default parameters
            </summary>
            <param name="isBinary">是否是二进制，默认是二进制，否则是ASCII格式</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadFromMcCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。<br />
            The method that should be triggered when a message of the mc protocol is received, 
            allowing inheritance to be rewritten to implement custom return or data monitoring.
            </summary>
            <param name="mcCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ReadFromMcAsciiCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。<br />
            The method that should be triggered when a message of the mc protocol is received, 
            allowing inheritance to be rewritten to implement custom return or data monitoring.
            </summary>
            <param name="mcCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否托管对象</param>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.MelsecMcUdp">
            <summary>
            三菱PLC通讯类，采用UDP的协议实现，采用Qna兼容3E帧协议实现，需要在PLC侧先的以太网模块先进行配置，必须为二进制通讯<br />
            Mitsubishi PLC communication class is implemented using UDP protocol and Qna compatible 3E frame protocol. 
            The Ethernet module needs to be configured first on the PLC side, and it must be binary communication.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Melsec.MelsecMcNet" path="remarks"/>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="Usage2" title="简单的长连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample1" title="基本的读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample2" title="批量读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample3" title="随机字读取示例" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\melsecTest.cs" region="ReadExample4" title="随机批量字读取示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdp.NetworkNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkNumber"/>
        </member>
        <member name="P:HslCommunication.Profinet.Melsec.MelsecMcUdp.NetworkStationNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Melsec.MelsecMcNet.NetworkStationNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandom(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandom(System.String[],System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandom(System.String[],System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadRandomInt16(System.String[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadRandomInt16(System.String[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteRun">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteRun"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteStop">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteStop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.RemoteReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.RemoteReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ReadPlcType">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ReadPlcType"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ErrorStateReset">
            <inheritdoc cref="M:HslCommunication.Profinet.Melsec.MelsecMcNet.ErrorStateReset"/>
        </member>
        <member name="M:HslCommunication.Profinet.Melsec.MelsecMcUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Melsec.NamespaceDoc">
            <summary>
            在三菱的PLC通信的MC协议中，分为串行通信的报文和以太网接口的报文。<br />
            在串口通信中，共有以下几种帧，其中1C,2C,3C帧支持格式1，2，3，4，在C帧里支持格式5通信<br />
            <list type="number">
            <item>4C帧，QnA系列串行通信模块专用协议（Qna扩展帧）</item>
            <item>3C帧，QnA系列串行通信模块专用协议（Qna帧）</item>
            <item>2C帧，QnA系列串行通信模块专用协议（Qna简易帧）</item>
            <item>1C帧，A系列计算机链接模块专用协议</item>
            </list>
            在以太网通信中，共有以下几种帧，每种帧支持二进制和ASCII格式
            <list type="number">
            <item>4E帧，是3E帧上附加了“序列号”。</item>
            <item>3E帧，QnA系列以太网接口模块的报文格式，兼容SLMP的报文格式</item>
            <item>1E帧，A系列以太网接口模块的报文格式</item>
            </list>
            在以太网通信里，HSL主要针对1E帧协议和3E帧协议进行实现，
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronCipNet">
            <summary>
            欧姆龙PLC的CIP协议的类，支持NJ,NX,NY系列PLC，支持tag名的方式读写数据，假设你读取的是局部变量，那么使用 Program:MainProgram.变量名<br />
            Omron PLC's CIP protocol class, support NJ, NX, NY series PLC, support tag name read and write data, assuming you read local variables, then use Program: MainProgram. Variable name
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor">
            <summary>
            Instantiate a communication object for a OmronCipNet PLC protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor(System.String,System.Int32)">
            <summary>
            Specify the IP address and port to instantiate a communication object for a OmronCipNet PLC protocol
            </summary>
            <param name="ipAddress">PLC IpAddress</param>
            <param name="port">PLC Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.Write(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.WriteTag(System.String,System.UInt16,System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronCipNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsDataType">
            <summary>
            欧姆龙的Fins协议的数据类型
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsDataType.#ctor(System.Byte,System.Byte)">
            <summary>
            实例化一个Fins的数据类型
            </summary>
            <param name="bitCode">进行位操作的指令</param>
            <param name="wordCode">进行字操作的指令</param>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsDataType.BitCode">
            <summary>
            进行位操作的指令
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsDataType.WordCode">
            <summary>
            进行字操作的指令
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.DM">
            <summary>
            DM Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.CIO">
            <summary>
            CIO Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.WR">
            <summary>
            Work Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.HR">
            <summary>
            Holding Bit Area
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Omron.OmronFinsDataType.AR">
            <summary>
            Auxiliary Bit Area
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsNet">
            <summary>
            欧姆龙PLC通讯类，采用Fins-Tcp通信协议实现，支持的地址信息参见api文档信息。<br />
            Omron PLC communication class is implemented using Fins-Tcp communication protocol. For the supported address information, please refer to the api document information.
            </summary>
            <remarks>
            <note type="important">实例化之后，使用之前，需要初始化三个参数信息，具体见三个参数的说明：<see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA1"/>，<see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA1"/>，<see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2"/></note>
            <note type="important">第二个需要注意的是，当网络异常掉线时，无法立即连接上PLC，PLC对于当前的节点进行拒绝，如果想要支持在断线后的快速连接，就需要将
            <see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.IsChangeSA1AfterReadFailed"/>设置为<c>True</c>，详细的可以参考 <see cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.IsChangeSA1AfterReadFailed"/></note>
            <br />
            <note type="warning">如果在测试的时候报错误码64，经网友 上海-Lex 指点，是因为PLC中产生了报警，如伺服报警，模块错误等产生的，但是数据还是能正常读到的，屏蔽64报警或清除plc错误可解决</note>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>EM Area</term>
                <term>E</term>
                <term>E0.0,EF.200,E10.100</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor">
            <summary>
            实例化一个欧姆龙PLC Fins帧协议的通讯对象<br />
            Instantiate a communication object of Omron PLC Fins frame protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址和端口号来实例化一个欧姆龙PLC Fins帧协议的通讯对象<br />
            Specify the IP address and port number to instantiate a communication object of the Omron PLC Fins frame protocol
            </summary>
            <param name="ipAddress">PLCd的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.IpAddress">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.ICF">
            <summary>
            信息控制字段，默认0x80<br />
            Information control field, default 0x80
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.RSV">
            <summary>
            系统使用的内部信息<br />
            Internal information used by the system
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.GCT">
            <summary>
            网络层信息，默认0x02，如果有八层消息，就设置为0x07<br />
            Network layer information, default is 0x02, if there are eight layers of messages, set to 0x07
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DNA">
            <summary>
            PLC的网络号地址，默认0x00<br />
            PLC network number address, default 0x00
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA1">
            <summary>
            PLC的节点地址，这个值在配置了ip地址之后是默认赋值的，默认为Ip地址的最后一位<br />
            PLC node address. This value is assigned by default after the IP address is configured. The default is the last bit of the IP address.
            </summary>
            <remarks>
            <note type="important">假如你的PLC的Ip地址为192.168.0.10，那么这个值就是10</note>
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2">
            <summary>
            PLC的单元号地址，通常都为0<br />
            PLC unit number address, usually 0
            </summary>
            <remarks>
            <note type="important">通常都为0</note>
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SNA">
            <summary>
            上位机的网络号地址<br />
            Network number and address of the computer
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA1">
            <summary>
            上位机的节点地址，假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13<br />
            The node address of the upper computer. If your computer's IP address is 192.168.0.13, then this value is 13
            </summary>
            <remarks>
            <note type="important">假如你的电脑的Ip地址为192.168.0.13，那么这个值就是13</note>
            </remarks>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2">
            <summary>
            上位机的单元号地址<br />
            Unit number and address of the computer
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID">
            <summary>
            设备的标识号<br />
            Device identification number
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsNet.IsChangeSA1AfterReadFailed">
            <summary>
            如果设置为<c>True</c>，当数据读取失败的时候，会自动变更当前的SA1值，会选择自动增加，但不会和DA1一致，本值需要在对象实例化之后立即设置。<br />
            If it is set to <c> True </c>, when data reading fails, the current SA1 value will be automatically changed, and the automatic increase will be selected, but it will not be consistent with DA1. This value needs to be set immediately after the object is instantiated .
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据类型地址长度确认需要读取的指令头<br />
            Confirm the instruction header to be read according to the type address length
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <param name="isBit">是否是位读取</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据类型地址以及需要写入的数据来生成指令头<br />
            Generate instruction header based on type address and data to be writtens
            </summary>
            <param name="address">起始地址</param>
            <param name="value">真实的数据值信息</param>
            <param name="isBit">是否是位操作</param>
            <returns>带有成功标志的报文数据</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ExtraAfterReadFromCoreServer(HslCommunication.OperateResult)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中读取想要的数据，返回读取结果，读取长度的单位为字，地址格式为"D100","C100","W100","H100","A100"<br />
            Read the desired data from the Omron PLC and return the read result. The unit of the read length is word. The address format is "D100", "C100", "W100", "H100", "A100"
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的数据长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])">
            <summary>
            向PLC写入数据，数据格式为原始的字节类型，地址格式为"D100","C100","W100","H100","A100"<br />
            Write data to PLC, the data format is the original byte type, and the address format is "D100", "C100", "W100", "H100", "A100"
            </summary>
            <param name="address">初始地址</param>
            <param name="value">原始的字节数据</param>
            <returns>结果</returns>
            <example>
            假设起始地址为D100，D100存储了温度，100.6℃值为1006，D101存储了压力，1.23Mpa值为123，D102,D103存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)">
            <summary>
            从欧姆龙PLC中批量读取位软元件，地址格式为"D100.0","C100.0","W100.0","H100.0","A100.0"<br />
            Read bit devices in batches from Omron PLC with address format "D100.0", "C100.0", "W100.0", "H100.0", "A100.0"
            </summary>
            <param name="address">读取地址，格式为"D100","C100","W100","H100","A100"</param>
            <param name="length">读取的长度</param>
            <returns>带成功标志的结果数据对象</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])">
            <summary>
            向PLC中位软元件写入bool数组，返回是否写入成功，比如你写入D100,values[0]对应D100.0，地址格式为"D100.0","C100.0","W100.0","H100.0","A100.0"<br />
            Write the bool array to the PLC's median device and return whether the write was successful. For example, if you write D100, values [0] corresponds to D100.0 
            and the address format is "D100.0", "C100.0", "W100. 0 "," H100.0 "," A100.0 "
            </summary>
            <param name="address">要写入的数据地址</param>
            <param name="values">要写入的实际数据，可以指定任意的长度</param>
            <returns>返回写入结果</returns>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\OmronFinsNet.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsNetHelper">
            <summary>
            Omron PLC的FINS协议相关的辅助类，主要是一些地址解析，读写的指令生成。<br />
            The auxiliary classes related to the FINS protocol of Omron PLC are mainly some address resolution and the generation of read and write instructions.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.AnalysisAddress(System.String,System.Boolean)">
            <summary>
            解析欧姆龙的数据地址，参考来源是Omron手册第188页，比如D100， E1.100<br />
            Analyze Omron's data address, the reference source is page 188 of the Omron manual, such as D100, E1.100
            </summary>
            <param name="address">数据地址</param>
            <param name="isBit">是否是位地址</param>
            <returns>解析后的结果地址对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否使用位读取</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.BuildWriteWordCommand(System.String,System.Byte[],System.Boolean)">
            <summary>
            根据写入的地址，数据，是否位写入生成Fins协议的核心报文<br />
            According to the written address, data, whether the bit is written to generate the core message of the Fins protocol
            </summary>
            <param name="address">地址内容，具体格式请参照示例说明</param>
            <param name="value">实际的数据</param>
            <param name="isBit">是否位数据</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容<br />
            Verify that the data returned by Omron's Fins-TCP is correct data, if correct, and return all data content
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.UdpResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-Udp返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容<br />
            Verify that the data returned by Omron's Fins-Udp is correct data, if correct, and return all data content
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsNetHelper.GetStatusDescription(System.Int32)">
            <summary>
            根据欧姆龙返回的错误码，获取错误信息的字符串描述文本<br />
            According to the error code returned by Omron, get the string description text of the error message
            </summary>
            <param name="err">错误码</param>
            <returns>文本描述</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsServer">
            <summary>
            欧姆龙的虚拟服务器，支持DM区，CIO区，Work区，Hold区，Auxiliary区，可以方便的进行测试<br />
            Omron's virtual server supports DM area, CIO area, Work area, Hold area, and Auxiliary area, which can be easily tested
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.#ctor">
            <summary>
            实例化一个Fins协议的服务器<br />
            Instantiate a Fins protocol server
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsServer.DataFormat">
            <inheritdoc cref="P:HslCommunication.Core.ByteTransformBase.DataFormat"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ReadFromFinsCore(System.Byte[])">
            <summary>
            当收到mc协议的报文的时候应该触发的方法，允许继承重写，来实现自定义的返回，或是数据监听。
            </summary>
            <param name="finsCore">mc报文</param>
            <returns>返回的报文信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.Dispose(System.Boolean)">
            <inheritdoc cref="M:System.IDisposable.Dispose"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronFinsUdp">
            <summary>
            欧姆龙的Udp的数据对象
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Omron.OmronFinsNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.IpAddress">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.ICF">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.ICF"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.RSV">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.RSV"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.GCT">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.GCT"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DNA">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DNA"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DA1">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA1"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SNA">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SNA"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SA1">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA1"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronFinsUdp.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.PackCommand(System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.PackCommand(System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.BuildReadCommand(System.String,System.UInt16,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.BuildWriteCommand(System.String,System.Byte[],System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.BuildWriteCommand(System.String,System.Byte[],System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronFinsUdp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLink">
            <summary>
            欧姆龙的HostLink协议的实现，地址支持示例 DM区:D100; CIO区:C100; Work区:W100; Holding区:H100; Auxiliary区: A100<br />
            Implementation of Omron's HostLink protocol, address support example DM area: D100; CIO area: C100; Work area: W100; Holding area: H100; Auxiliary area: A100
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.ICF">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ICF"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.ResponseWaitTime">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseWaitTime"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLink.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLink.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">fins指令</param>
            <returns>完整的质量</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkCMode">
            <summary>
            欧姆龙的HostLink的C-Mode实现形式
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkCMode.UnitNumber">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ReadPlcModel">
            <summary>
            读取PLC的当前的型号信息
            </summary>
            <returns>型号</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">fins指令</param>
            <returns>完整的质量</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.AnalysisAddress(System.String,System.Boolean,System.Boolean)">
            <summary>
            解析欧姆龙的数据地址，参考来源是Omron手册第188页，比如D100， E1.100<br />
            Analyze Omron's data address, the reference source is page 188 of the Omron manual, such as D100, E1.100
            </summary>
            <param name="address">数据地址</param>
            <param name="isBit">是否是位地址</param>
            <param name="isRead">是否读取</param>
            <returns>解析后的结果地址对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.BuildReadCommand(System.String,System.UInt16,System.Boolean)">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="length">读取的数据长度</param>
            <param name="isBit">是否使用位读取</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.BuildWriteWordCommand(System.String,System.Byte[])">
            <summary>
            根据读取的地址，长度，是否位读取创建Fins协议的核心报文<br />
            According to the read address, length, whether to read the core message that creates the Fins protocol
            </summary>
            <param name="address">地址，具体格式请参照示例说明</param>
            <param name="value">等待写入的数据</param>
            <returns>带有成功标识的Fins核心报文</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkCMode.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp">
            <summary>
            欧姆龙的HostLink协议的实现，基于Tcp实现，地址支持示例 DM区:D100; CIO区:C100; Work区:W100; Holding区:H100; Auxiliary区: A100<br />
            Implementation of Omron's HostLink protocol, based on tcp protocol, address support example DM area: D100; CIO area: C100; Work area: W100; Holding area: H100; Auxiliary area: A100
            </summary>
            <remarks>
            感谢 深圳～拾忆 的测试
            欧姆龙的地址参考如下：
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>DM Area</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>CIO Area</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Work Area</term>
                <term>W</term>
                <term>W100,W200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Holding Bit Area</term>
                <term>H</term>
                <term>H100,H200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>Auxiliary Bit Area</term>
                <term>A</term>
                <term>A100,A200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            <br />
            <note type="important">
            如果发现串口线和usb同时打开才能通信的情况，需要按照如下的操作：<br />
            串口线不是标准的串口线，电脑的串口线的235引脚分别接PLC的329引脚，45线短接，就可以通讯，感谢 深圳-小君(QQ932507362)提供的解决方案。
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.#ctor(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronCipNet.#ctor(System.String,System.Int32)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ICF">
            <summary>
            Specifies whether or not there are network relays. Set “80” (ASCII: 38,30) 
            when sending an FINS command to a CPU Unit on a network.Set “00” (ASCII: 30,30) 
            when sending to a CPU Unit connected directly to the host computer.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.DA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.DA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SA2">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SA2"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.SID">
            <inheritdoc cref="P:HslCommunication.Profinet.Omron.OmronFinsNet.SID"/>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseWaitTime">
            <summary>
            The response wait time sets the time from when the CPU Unit receives a command block until it starts 
            to return a response.It can be set from 0 to F in hexadecimal, in units of 10 ms.
            If F(15) is set, the response will begin to be returned 150 ms (15 × 10 ms) after the command block was received.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.UnitNumber">
            <summary>
            PLC设备的站号信息<br />
            PLC device station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Omron.OmronFinsNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.PackCommand(System.Byte[])">
            <summary>
            将普通的指令打包成完整的指令
            </summary>
            <param name="cmd">fins指令</param>
            <returns>完整的质量</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Omron.OmronHostLinkOverTcp.ResponseValidAnalysis(System.Byte[],System.Boolean)">
            <summary>
            验证欧姆龙的Fins-TCP返回的数据是否正确的数据，如果正确的话，并返回所有的数据内容
            </summary>
            <param name="response">来自欧姆龙返回的数据内容</param>
            <param name="isRead">是否读取</param>
            <returns>带有是否成功的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet">
            <summary>
            开放以太网协议，仍然在开发中<br />
            Open Ethernet protocol, still under development
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的IP地址及端口来初始化对象<br />
            Use the specified IP address and port to initialize the object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.ReadCustomer(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            自定义的命令读取
            </summary>
            <param name="mid"></param>
            <param name="revison"></param>
            <param name="stationId"></param>
            <param name="spindleId"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.OpenProtocol.OpenProtocolNet.BuildReadCommand(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.String})">
            <summary>
            构建一个读取的初始报文
            </summary>
            <param name="mid"></param>
            <param name="revison"></param>
            <param name="stationId"></param>
            <param name="spindleId"></param>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicHelper">
            <summary>
            松下PLC的辅助类，提供了基本的辅助方法，用于解析地址，计算校验和，创建报文<br />
            The auxiliary class of Panasonic PLC provides basic auxiliary methods for parsing addresses, calculating checksums, and creating messages
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.CalculateComplexAddress(System.String)">
            <summary>
            位地址转换方法，101等同于10.1等同于10*16+1=161<br />
            Bit address conversion method, 101 is equivalent to 10.1 is equivalent to 10 * 16 + 1 = 161
            </summary>
            <param name="address">地址信息</param>
            <returns>实际的位地址信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址<br />
            Parse the data address, resolve the address type, start address
            </summary>
            <param name="address">数据地址</param>
            <returns>解析出地址类型，起始地址</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildReadOneCoil(System.Byte,System.String)">
            <summary>
            创建读取离散触点的报文指令<br />
            Create message instructions for reading discrete contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildWriteOneCoil(System.Byte,System.String,System.Boolean)">
            <summary>
            创建写入离散触点的报文指令<br />
            Create message instructions to write discrete contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="value">bool值数组</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildReadCommand(System.Byte,System.String,System.UInt16)">
            <summary>
            创建批量读取触点的报文指令<br />
            Create message instructions for batch reading contacts
            </summary>
            <param name="station">站号信息</param>
            <param name="address">地址信息</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.BuildWriteCommand(System.Byte,System.String,System.Byte[],System.Int16)">
            <summary>
            创建批量读取触点的报文指令<br />
            Create message instructions for batch reading contacts
            </summary>
            <param name="station">设备站号</param>
            <param name="address">地址信息</param>
            <param name="values">数据值</param>
            <param name="length">数据长度</param>
            <returns>包含是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.ExtraActualData(System.Byte[])">
            <summary>
            检查从PLC反馈的数据，并返回正确的数据内容<br />
            Check the data feedback from the PLC and return the correct data content
            </summary>
            <param name="response">反馈信号</param>
            <returns>是否成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.ExtraActualBool(System.Byte[])">
            <summary>
            检查从PLC反馈的数据，并返回正确的数据内容<br />
            Check the data feedback from the PLC and return the correct data content
            </summary>
            <param name="response">反馈信号</param>
            <returns>是否成功的结果信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicHelper.GetErrorDescription(System.Int32)">
            <summary>
            根据错误码获取到错误描述文本<br />
            Get the error description text according to the error code
            </summary>
            <param name="err">错误代码</param>
            <returns>字符信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMcNet">
            <summary>
            松下PLC的数据读写类，基于MC协议的实现，具体的地址格式请参考备注说明<br />
            Data reading and writing of Panasonic PLC, based on the implementation of the MC protocol, please refer to the note for specific address format
            </summary>
            <remarks>
            地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>地址示例一</term>
                <term>地址范围</term>
                <term>字操作</term>
                <term>位操作</term>
              </listheader>
              <item>
                <term>输入继电器</term>
                <term>X</term>
                <term>X0000,X100F</term>
                <term>X0000～X109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Y</term>
                <term>Y0000,Y100F</term>
                <term>Y0000～Y109F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0000,L100F</term>
                <term>L0000～L0127F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0000,R100F</term>
                <term>R0000～R511F,R9000～R951F</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>数据存储器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>D0～D65532,D90000～D90999</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>链路寄存器</term>
                <term>LD</term>
                <term>LD0,LD100</term>
                <term>LD0～LD255</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（当前值）</term>
                <term>TN</term>
                <term>TN100,TN200</term>
                <term>TN0～TN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>定时器（接点）</term>
                <term>TS</term>
                <term>TS100,TS200</term>
                <term>TS0～TS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
              <item>
                <term>计数器（当前值）</term>
                <term>CN</term>
                <term>CN100,CN200</term>
                <term>CN0～CN1023</term>
                <term>√</term>
                <term>×</term>
              </item>
              <item>
                <term>计数器（接点）</term>
                <term>CS</term>
                <term>CS100,CS200</term>
                <term>CS0～CS1023</term>
                <term>√</term>
                <term>√</term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.#ctor">
            <summary>
            实例化松下的的Qna兼容3E帧协议的通讯对象<br />
            Instantiate Panasonic's Qna compatible 3E frame protocol communication object
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip地址及端口号来实例化一个基恩士的Qna兼容3E帧协议的通讯对象<br />
            Specify an IP address and port number to instantiate a Keynes Qna compatible 3E frame protocol communication object
            </summary>
            <param name="ipAddress">PLC的Ip地址</param>
            <param name="port">PLC的端口</param>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.McAnalysisAddress(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMcNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocol">
            <summary>
            松下PLC的数据交互协议，采用Mewtocol协议通讯，支持的地址列表参考api文档<br />
            The data exchange protocol of Panasonic PLC adopts Mewtocol protocol for communication. For the list of supported addresses, refer to the api document.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.#ctor(System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.Byte)"/>
        </member>
        <member name="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocol.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp">
            <summary>
            松下PLC的数据交互协议，采用Mewtocol协议通讯，基于Tcp透传实现的机制，支持的地址列表参考api文档<br />
            The data exchange protocol of Panasonic PLC adopts Mewtocol protocol for communication. 
            It is based on the mechanism of Tcp transparent transmission. For the list of supported addresses, refer to the api document.
            </summary>
            <remarks>
            触点地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>外部输入继电器</term>
                <term>X</term>
                <term>X11,X1F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>X33 等同于 X3.3</term>
              </item>
              <item>
                <term>外部输出继电器</term>
                <term>Y</term>
                <term>Y22,Y2A</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>Y21 等同于 Y2.1</term>
              </item>
              <item>
                <term>内部继电器</term>
                <term>R</term>
                <term>R0F,R100F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>R21 等同于 R2.1</term>
              </item>
              <item>
                <term>定时器</term>
                <term>T</term>
                <term>T0,T100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>计数器</term>
                <term>C</term>
                <term>C0,C100</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>链接继电器</term>
                <term>L</term>
                <term>L0F,L100F</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term>L21 等同于 L2.1</term>
              </item>
            </list>
            数据地址的输入的格式说明如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器 DT</term>
                <term>D</term>
                <term>D0,D100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>链接寄存器 LD</term>
                <term>LD</term>
                <term>LD0,LD100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>文件寄存器 FL</term>
                <term>F</term>
                <term>F0,F100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>目标值 SV</term>
                <term>S</term>
                <term>S0,S100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>经过值 EV</term>
                <term>K</term>
                <term>K0,K100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IX</term>
                <term>IX</term>
                <term>IX0,IX100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>索引寄存器 IY</term>
                <term>IY</term>
                <term>IY0,IY100</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.Byte)">
            <summary>
            实例化一个默认的松下PLC通信对象，默认站号为0xEE<br />
            Instantiate a default Panasonic PLC communication object, the default station number is 0xEE
            </summary>
            <param name="station">站号信息，默认为0xEE</param>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.#ctor(System.String,System.Int32,System.Byte)">
            <summary>
            实例化一个默认的松下PLC通信对象，指定ip地址，端口，默认站号为0xEE<br />
            Instantiate a default Panasonic PLC communication object, specify the IP address, port, and the default station number is 0xEE
            </summary>
            <param name="ipAddress">Ip地址数据</param>
            <param name="port">端口号</param>
            <param name="station">站号信息，默认为0xEE</param>
        </member>
        <member name="P:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Station">
            <summary>
            PLC设备的目标站号，需要根据实际的设置来填写<br />
            The target station number of the PLC device needs to be filled in according to the actual settings
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Read(System.String,System.UInt16)">
            <summary>
            读取指定地址的原始数据，地址示例：D0  F0  K0  T0  C0<br />
            Read the original data of the specified address, address example: D0 F0 K0 T0 C0
            </summary>
            <param name="address">起始地址</param>
            <param name="length">长度</param>
            <returns>返回数据信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到指定的地址里去，地址示例：D0  F0  K0  T0  C0<br />
            Write data to the specified address, address example: D0 F0 K0 T0 C0
            </summary>
            <param name="address">起始地址</param>
            <param name="value">真实数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String,System.UInt16)">
            <summary>
            批量读取松下PLC的位数据，按照字为单位，地址为 X0,X10,Y10，读取的长度为16的倍数<br />
            Read the bit data of Panasonic PLC in batches, the unit is word, the address is X0, X10, Y10, and the read length is a multiple of 16
            </summary>
            <param name="address">起始地址</param>
            <param name="length">数据长度</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ReadBool(System.String)">
            <summary>
            读取单个的地址信息的bool值，地址举例：SR0.0  X0.0  Y0.0  R0.0  L0.0<br />
            Read the bool value of a single address, for example: SR0.0 X0.0 Y0.0 R0.0 L0.0
            </summary>
            <param name="address">起始地址</param>
            <returns>读取结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean[])">
            <summary>
            往指定的地址写入bool数组，地址举例：SR0.0  X0.0  Y0.0  R0.0  L0.0，存在一定的风险，谨慎操作，写入的数组长度要为8的倍数。<br />
            Write the bool array to the specified address. Example of the address: SR0.0 X0.0 Y0.0 R0.0 L0.0. There is a certain risk. Exercise caution. The length of the written array must be a multiple of 8.
            </summary>
            <param name="address">起始地址</param>
            <param name="values">数据值信息</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.Write(System.String,System.Boolean)">
            <summary>
            往指定的地址写入bool数据，地址举例：SR0.0  X0.0  Y0.0  R0.0  L0.0<br />
            Write bool data to the specified address. Example address: SR0.0 X0.0 Y0.0 R0.0 L0.0
            </summary>
            <param name="address">起始地址</param>
            <param name="value">数据值信息</param>
            <returns>返回是否成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Panasonic.PanasonicMewtocolOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Sick.SickIcrTcpServer">
            <summary>
            Sick的扫码器的服务器信息，只要启动服务器之后，扫码器配置将条码发送到PC的指定端口上来即可，就可以持续的接收条码信息，同样也适用于海康，基恩士，DATELOGIC 。<br />
            The server information of Sick's code scanner, as long as the server is started, the code scanner is configured to send the barcode to the designated port of the PC, and it can continuously receive the barcode information.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.#ctor">
            <summary>
            实例化一个默认的服务器对象<br />
            Instantiate a default server object
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Sick.SickIcrTcpServer.ReceivedBarCodeDelegate">
            <summary>
            接收条码数据的委托信息<br />
            Entrusted information to receive barcode data
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="barCode">条码信息</param>
        </member>
        <member name="E:HslCommunication.Profinet.Sick.SickIcrTcpServer.OnReceivedBarCode">
            <summary>
            当接收到条码数据的时候触发<br />
            Triggered when barcode data is received
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.AddConnectBarcodeScan(System.String,System.Int32)">
            <summary>
            新增一个主动连接的请求，将不会收到是否连接成功的信息，当网络中断及奔溃之后，会自动重新连接。<br />
            A new active connection request will not receive a message whether the connection is successful. When the network is interrupted and crashed, it will automatically reconnect.
            </summary>
            <param name="ipAddress">对方的Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="P:HslCommunication.Profinet.Sick.SickIcrTcpServer.OnlineCount">
            <summary>
            获取当前在线的客户端数量<br />
            Get the number of clients currently online
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Sick.SickIcrTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensDateTime">
            <summary>
            Contains the methods to convert between <see cref="T:System.DateTime"/> and S7 representation of datetime values.
            </summary>
            <remarks>
            这部分的代码参考了另一个s7的库，感谢原作者，此处贴出出处，遵循 MIT 协议
            
            https://github.com/S7NetPlus/s7netplus
            </remarks>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensDateTime.SpecMinimumDateTime">
            <summary>
            The minimum <see cref="T:System.DateTime"/> value supported by the specification.
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensDateTime.SpecMaximumDateTime">
            <summary>
            The maximum <see cref="T:System.DateTime"/> value supported by the specification.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.FromByteArray(System.Byte[])">
            <summary>
            Parses a <see cref="T:System.DateTime"/> value from bytes.
            </summary>
            <param name="bytes">Input bytes read from PLC.</param>
            <returns>A <see cref="T:System.DateTime"/> object representing the value read from PLC.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of
              <paramref name="bytes"/> is not 8 or any value in <paramref name="bytes"/>
              is outside the valid range of values.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToArray(System.Byte[])">
            <summary>
            Parses an array of <see cref="T:System.DateTime"/> values from bytes.
            </summary>
            <param name="bytes">Input bytes read from PLC.</param>
            <returns>An array of <see cref="T:System.DateTime"/> objects representing the values read from PLC.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the length of
              <paramref name="bytes"/> is not a multiple of 8 or any value in
              <paramref name="bytes"/> is outside the valid range of values.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToByteArray(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> value to a byte array.
            </summary>
            <param name="dateTime">The DateTime value to convert.</param>
            <returns>A byte array containing the S7 date time representation of <paramref name="dateTime"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the value of
              <paramref name="dateTime"/> is before <see cref="P:SpecMinimumDateTime"/>
              or after <see cref="P:SpecMaximumDateTime"/>.</exception>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensDateTime.ToByteArray(System.DateTime[])">
            <summary>
            Converts an array of <see cref="T:System.DateTime"/> values to a byte array.
            </summary>
            <param name="dateTimes">The DateTime values to convert.</param>
            <returns>A byte array containing the S7 date time representations of <paramref name="dateTimes"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown when any value of
              <paramref name="dateTimes"/> is before <see cref="P:SpecMinimumDateTime"/>
              or after <see cref="P:SpecMaximumDateTime"/>.</exception>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet">
            <summary>
            使用了Fetch/Write协议来和西门子进行通讯，该种方法需要在PLC侧进行一些配置<br />
            Using the Fetch/write protocol to communicate with Siemens, this method requires some configuration on the PLC side
            </summary>
            <remarks>
            配置的参考文章地址：https://www.cnblogs.com/dathlin/p/8685855.html
            <br />
            与S7协议相比较而言，本协议不支持对单个的点位的读写操作。如果读取M100.0，需要读取M100的值，然后进行提取位数据。
            
            如果需要写入位地址的数据，可以读取plc的byte值，然后进行与或非，然后写入到plc之中。
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="Usage2" title="简单的长连接使用" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.#ctor">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象<br />
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个西门子的Fetch/Write协议的通讯对象<br />
            Instantiate a communication object for a Siemens Fetch/write protocol
            </summary>
            <param name="ipAddress">PLC的Ip地址 -> Specify IP Address</param>
            <param name="port">PLC的端口 -> Specify IP Port</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，T100，C100，以字节为单位<br />
            Read data from PLC, address format I100,Q100,DB20.100,M100,T100,C100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100，T100，C100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100,T100,C100
            </param>
            <param name="length">读取的数量，以字节为单位 -> The number of reads, in bytes</param>
            <returns>带有成功标志的字节信息 -> Byte information with a success flag</returns>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位<br />
            Writes data to the PLC data, in the address format i100,q100,db20.100,m100, in bytes
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensFetchWriteNet.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据<br />
            Reads the byte data for the specified address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>byte类型的结果对象 -> Result object of type Byte</returns>
            <remarks>
            <note type="warning">
            不适用于DB块，定时器，计数器的数据读取，会提示相应的错误，读取长度必须为偶数
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回是否写入成功<br />
            Writes byte data to the PLC and returns whether the write succeeded
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="value">要写入的实际数据 -> The actual data to write</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.CalculateAddressStarted(System.String)">
            <summary>
            计算特殊的地址信息<br />
            Calculate special address information
            </summary>
            <param name="address">字符串信息</param>
            <returns>实际值</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址<br />
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <returns>解析出地址类型，起始地址，DB块的地址 -> Resolves address type, start address, db block address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.BuildReadCommand(System.String,System.UInt16)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="count">读取数据个数 -> Number of Read data</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensFetchWriteNet.BuildWriteCommand(System.String,System.Byte[])">
            <summary>
            生成一个写入字节数据的指令<br />
            Generate an instruction to write byte data
            </summary>
            <param name="address">起始地址，格式为M100,I100,Q100,DB1.100 -> Starting address, formatted as M100,I100,Q100,DB1.100</param>
            <param name="data">实际的写入的内容 -> The actual content of the write</param>
            <returns>带结果对象的报文数据 -> Message data with a result object</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensMPI">
            <summary>
            西门子的MPI协议信息，注意：未测试通过，无法使用<br />
            Siemens MPI protocol information, note: it has not passed the test and cannot be used
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.#ctor">
            <summary>
            实例化一个西门子的MPI协议对象<br />
            Instantiate a Siemens MPI protocol object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensMPI.Station">
            <summary>
            西门子PLC的站号信息<br />
            Siemens PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Handle">
            <summary>
            与PLC进行握手<br />
            Handshake with PLC
            </summary>
            <returns>是否握手成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Read(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Read data information from Siemens PLC, the address is "M100", "AI100", "I0", "Q0", "V100", "S100", etc., please refer to the API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ReadBool(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Read the bool data information from Siemens PLC. The addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. For details, please Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Write(System.String,System.Byte[])">
            <summary>
            将字节数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Write byte data to Siemens PLC, the address is "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ReadByte(System.String)">
            <summary>
            从西门子的PLC中读取byte数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Read byte data information from Siemens PLC. The addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. For details, please Refer to API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.Write(System.String,System.Byte)">
            <summary>
            将byte数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等，详细请参照API文档<br />
            Write byte data to Siemens PLC, the address is "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc. API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="station">设备的站号信息 -> Station number information for the device</param>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <param name="isBit">是否为位读取</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            生成一个写入PLC数据信息的报文内容<br />
            Generate a message content to write PLC data information
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址</param>
            <param name="values">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.GetMsgFromStatus(System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="code">状态</param>
            <returns>消息文本</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensMPI.GetMsgFromStatus(System.Byte,System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="errorClass">错误类型</param>
            <param name="errorCode">错误代码</param>
            <returns>错误信息</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPLCS">
            <summary>
            西门子的PLC类型，目前支持的访问类型
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S1200">
            <summary>
            1200系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S300">
            <summary>
            300系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S400">
            <summary>
            400系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S1500">
            <summary>
            1500系列PLC
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S200Smart">
            <summary>
            200的smart系列
            </summary>
        </member>
        <member name="F:HslCommunication.Profinet.Siemens.SiemensPLCS.S200">
            <summary>
            200系统，需要额外配置以太网模块
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPPI">
            <summary>
            西门子的PPI协议，适用于s7-200plc，注意，本类库有个致命的风险需要注意，由于本类库的每次通讯分成2次操作，
            故而不支持多线程同时读写，当发生线程竞争的时候，会导致数据异常，想要解决的话，需要您在每次数据交互时添加同步锁。<br />
            Siemens's PPI protocol is applicable to s7-200plc. Note that this library has a fatal risk. Please note that because this library is divided into two operations for each communication, 
            it does not support simultaneous reading and writing by multiple threads. When thread competition occurs When this happens, 
            the data will be abnormal. If you want to solve it, you need to add a synchronization lock at each data interaction.
            </summary>
            <remarks>
            适用于西门子200的通信，非常感谢 合肥-加劲 的测试，让本类库圆满完成。
            
            注意：M地址范围有限 0-31地址
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.#ctor">
            <summary>
            实例化一个西门子的PPI协议对象<br />
            Instantiate a Siemens PPI protocol object
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensPPI.Station">
            <summary>
            西门子PLC的站号信息<br />
            Siemens PLC station number information
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Read(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等<br />
            Read data information from Siemens PLC with addresses "M100", "AI100", "I0", "Q0", "V100", "S100", etc.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadBool(System.String,System.UInt16)">
            <summary>
            从西门子的PLC中读取bool数据信息，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Read bool data information from Siemens PLC, the addresses are "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="length">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte[])">
            <summary>
            将字节数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Write byte data to Siemens PLC with addresses "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean[])">
            <summary>
            将bool数据写入到西门子PLC中，地址为"M100.0","AI100.1","I0.3","Q0.6","V100.4","S100"等<br />
            Write the bool data to Siemens PLC with the addresses "M100.0", "AI100.1", "I0.3", "Q0.6", "V100.4", "S100", etc.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadByte(System.String)">
            <summary>
            从西门子的PLC中读取byte数据信息，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Read byte data information from Siemens PLC. The addresses are "M100", "AI100", "I0", "Q0", "V100", "S100", etc. Please refer to the API documentation for details.
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte)">
            <summary>
            向西门子的PLC中读取byte数据，地址为"M100","AI100","I0","Q0","V100","S100"等，详细请参照API文档<br />
            Read byte data from Siemens PLC with addresses "M100", "AI100", "I0", "Q0", "V100", "S100", etc. For details, please refer to the API documentation
            </summary>
            <param name="address">西门子的地址数据信息</param>
            <param name="value">数据长度</param>
            <returns>带返回结果的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Start">
            <summary>
            启动西门子PLC为RUN模式<br />
            Start Siemens PLC in RUN mode
            </summary>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.Stop">
            <summary>
            停止西门子PLC，切换为Stop模式<br />
            Stop Siemens PLC and switch to Stop mode
            </summary>
            <returns>是否停止成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPI.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp">
            <inheritdoc cref="T:HslCommunication.Profinet.Siemens.SiemensPPI"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.#ctor">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.#ctor"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来实例化对象<br />
            Instantiate the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Station">
            <inheritdoc cref="P:HslCommunication.Profinet.Siemens.SiemensPPI.Station"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Start">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Start"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.Stop">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensPPI.Stop"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.AnalysisAddress(System.String)">
            <summary>
            解析数据地址，解析出地址类型，起始地址，DB块的地址<br />
            Parse data address, parse out address type, start address, db block address
            </summary>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <returns>解析数据地址，解析出地址类型，起始地址，DB块的地址 ->
            Parse data address, parse out address type, start address, db block address</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.BuildReadCommand(System.Byte,System.String,System.UInt16,System.Boolean)">
            <summary>
            生成一个读取字数据指令头的通用方法<br />
            A general method for generating a command header to read a Word data
            </summary>
            <param name="station">设备的站号信息 -> Station number information for the device</param>
            <param name="address">起始地址，例如M100，I0，Q0，V100 ->
            Start address, such as M100,I0,Q0,V100</param>
            <param name="length">读取数据长度 -> Read Data length</param>
            <param name="isBit">是否为位读取</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.BuildWriteCommand(System.Byte,System.String,System.Byte[])">
            <summary>
            生成一个写入PLC数据信息的报文内容
            </summary>
            <param name="station">PLC的站号</param>
            <param name="address">地址</param>
            <param name="values">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.GetMsgFromStatus(System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="code">状态</param>
            <returns>消息文本</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.GetMsgFromStatus(System.Byte,System.Byte)">
            <summary>
            根据错误信息，获取到文本信息
            </summary>
            <param name="errorClass">错误类型</param>
            <param name="errorCode">错误代码</param>
            <returns>错误信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensPPIOverTcp.BuildWriteCommand(System.Byte,System.String,System.Boolean[])">
            <summary>
            创建写入PLC的bool类型数据报文指令
            </summary>
            <param name="station">PLC的站号信息</param>
            <param name="address">地址信息</param>
            <param name="values">bool[]数据值</param>
            <returns>带有成功标识的结果对象</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensS7Net">
            <summary>
            一个西门子的客户端类，使用S7协议来进行数据交互 <br />
            A Siemens client class that uses the S7 protocol for data interaction
            </summary>
            <remarks>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100，当然了你也可以输入V100</note>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
            </list>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage" title="简单的短连接使用" />
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="Usage2" title="简单的长连接使用" />
            
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample1" title="Read示例" />
            以下是一个复杂的读取示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample3" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.#ctor(HslCommunication.Profinet.Siemens.SiemensPLCS)">
            <summary>
            实例化一个西门子的S7协议的通讯对象 <br />
            Instantiate a communication object for a Siemens S7 protocol
            </summary>
            <param name="siemens">指定西门子的型号</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.#ctor(HslCommunication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            实例化一个西门子的S7协议的通讯对象并指定Ip地址 <br />
            Instantiate a communication object for a Siemens S7 protocol and specify an IP address
            </summary>
            <param name="siemens">指定西门子的型号</param>
            <param name="ipAddress">Ip地址</param>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Initialization(HslCommunication.Profinet.Siemens.SiemensPLCS,System.String)">
            <summary>
            初始化方法<br />
            Initialize method
            </summary>
            <param name="siemens">指定西门子的型号 -> Designation of Siemens</param>
            <param name="ipAddress">Ip地址 -> IpAddress</param>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Slot">
            <summary>
            PLC的槽号，针对S7-400的PLC设置的<br />
            The slot number of PLC is set for PLC of s7-400
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.Rack">
            <summary>
            PLC的机架号，针对S7-400的PLC设置的<br />
            The frame number of the PLC is set for the PLC of s7-400
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Siemens.SiemensS7Net.PDULength">
            <summary>
            获取当前西门子的PDU的长度信息，不同型号PLC的值会不一样。<br />
            Get the length information of the current Siemens PDU, the value of different types of PLC will be different.
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadOrderNumber">
            <summary>
            从PLC读取订货号信息<br />
            Reading order number information from PLC
            </summary>
            <returns>CPU的订货号信息 -> Order number information for the CPU</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.HotStart">
            <summary>
            对PLC进行热启动，目前仅适用于200smart型号<br />
            Hot start for PLC, currently only applicable to 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ColdStart">
            <summary>
            对PLC进行冷启动，目前仅适用于200smart型号<br />
            Cold start for PLC, currently only applicable to 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Stop">
            <summary>
            对PLC进行停止，目前仅适用于200smart型号<br />
            Stop the PLC, currently only applicable to the 200smart model
            </summary>
            <returns>是否启动成功的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)">
            <summary>
            从PLC读取原始的字节数据，地址格式为I100，Q100，DB20.100，M100，长度参数以字节为单位<br />
            Read the original byte data from the PLC, the address format is I100, Q100, DB20.100, M100, length parameters in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100<br />
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">读取的数量，以字节为单位<br />
            The number of reads, in bytes</param>
            <returns>
            是否读取成功的结果对象 <br />
            Whether to read the successful result object</returns>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Profinet.Siemens.SiemensS7Net" path="note"/>
            </remarks>
            <example>
            假设起始地址为M100，M100存储了温度，100.6℃值为1006，M102存储了压力，1.23Mpa值为123，M104，M105，M106，M107存储了产量计数，读取如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample2" title="Read示例" />
            以下是读取不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample1" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBitFromPLC(System.String)">
            <summary>
            从PLC读取数据，地址格式为I100，Q100，DB20.100，M100，以位为单位 ->
            Read the data from the PLC, the address format is I100，Q100，DB20.100，M100, in bits units
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String[],System.UInt16[])">
            <summary>
            一次性从PLC获取所有的数据，按照先后顺序返回一个统一的Buffer，需要按照顺序处理，两个数组长度必须一致，数组长度无限制<br />
            One-time from the PLC to obtain all the data, in order to return a unified buffer, need to be processed sequentially, two array length must be consistent
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100<br />
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="length">数据长度数组<br />
            Array of data Lengths</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <exception cref="T:System.NullReferenceException"></exception>
            <remarks>
            <note type="warning">原先的批量的长度为19，现在已经内部自动处理整合，目前的长度为任意和长度。</note>
            </remarks>
            <example>
            以下是一个高级的读取示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadExample3" title="Read示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            读取西门子的地址数据信息，支持任意个数的数据读取<br />
            Read Siemens address data information, support any number of data reading
            </summary>
            <param name="s7Addresses">
            西门子的数据地址<br />
            Siemens data address</param>
            <returns>返回的结果对象信息 -> Whether to read the successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadS7AddressData(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            单次的读取，只能读取最多19个数组的长度，所以不再对外公开该方法
            </summary>
            <param name="s7Addresses">西门子的地址对象</param>
            <returns>返回的结果对象信息</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.WriteBase(System.Byte[])">
            <summary>
            基础的写入数据的操作支持<br />
            Operational support for the underlying write data
            </summary>
            <param name="entireValue">完整的字节数据 -> Full byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])">
            <summary>
            将数据写入到PLC数据，地址格式为I100，Q100，DB20.100，M100，以字节为单位<br />
            Writes data to the PLC data, in the address format I100,Q100,DB20.100,M100, in bytes
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <param name="value">写入的原始数据 -> Raw data written to</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设起始地址为M100，M100,M101存储了温度，100.6℃值为1006，M102,M103存储了压力，1.23Mpa值为123，M104-M107存储了产量计数，写入如下：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample2" title="Write示例" />
            以下是写入不同类型数据的示例
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteExample1" title="Write示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)">
            <summary>
            读取指定地址的bool数据，地址格式为I100，M100，Q100，DB20.100<br />
            reads bool data for the specified address in the format I100，M100，Q100，DB20.100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <remarks>
            <note type="important">
            对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100
            </note>
            </remarks>
            <example>
            假设读取M100.0的位是否通断
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="ReadBool" title="ReadBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)">
            <summary>
            写入PLC的一个位，例如"M100.6"，"I100.7"，"Q100.0"，"DB20.100.0"，如果只写了"M100"默认为"M100.0"<br />
            Write a bit of PLC, for example  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0", if only write  "M100" defaults to  "M100.0"
            </summary>
            <param name="address">起始地址，格式为"M100.6",  "I100.7",  "Q100.0",  "DB20.100.0" ->
            Start address, format  "M100.6",  "I100.7",  "Q100.0",  "DB20.100.0"</param>
            <param name="value">写入的数据，True或是False -> Writes the data, either True or False</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <example>
            假设写入M100.0的位是否通断
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7Net.cs" region="WriteBool" title="WriteBool示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean[])">
            <summary>
            [危险] 向PLC中写入bool数组，比如你写入M100,那么data[0]对应M100.0<br />
            [Danger] Write the bool array to the PLC, for example, if you write M100, then data[0] corresponds to M100.0
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="values">要写入的bool数组，长度为8的倍数 -> The bool array to write, a multiple of 8 in length</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
            <remarks>
            <note type="warning">
            批量写入bool数组存在一定的风险，原因是只能批量写入长度为8的倍数的数组，否则会影响其他的位的数据，请谨慎使用。
            </note>
            </remarks>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)">
            <summary>
            读取指定地址的byte数据，地址格式I100，M100，Q100，DB20.100<br />
            Reads the byte data of the specified address, the address format I100,Q100,DB20.100,M100
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 ->
            Starting address, formatted as I100,M100,Q100,DB20.100</param>
            <returns>是否读取成功的结果对象 -> Whether to read the successful result object</returns>
            <example>参考<see cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>的注释</example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)">
            <summary>
            向PLC中写入byte数据，返回值说明<br />
            Write byte data to the PLC, return value description
            </summary>
            <param name="address">起始地址，格式为I100，M100，Q100，DB20.100 -> Starting address, formatted as I100,mM100,Q100,DB20.100</param>
            <param name="value">byte数据 -> Byte data</param>
            <returns>是否写入成功的结果对象 -> Whether to write a successful result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.String)">
            <summary>
            向设备中写入字符串，编码格式为ASCII，格式遵循西门子自身的地址格式<br />
            Write strings to the device, encoded as ASCII, following Siemens' own address format
            </summary>
            <param name="address">数据地址</param>
            <param name="value">字符串数据</param>
            <returns>是否写入成功的结果对象</returns>
            <example>
            以下为三菱的连接对象示例，其他的设备读写情况参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Core\NetworkDeviceBase.cs" region="WriteString" title="String类型示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadString(System.String)">
            <summary>
            读取西门子的地址的字符串信息，这个信息是和西门子绑定在一起，长度随西门子的信息动态变化的<br />
            Read the Siemens address string information. This information is bound to Siemens and its length changes dynamically with the Siemens information
            </summary>
            <param name="address">数据地址，具体的格式需要参照类的说明文档</param>
            <returns>带有是否成功的字符串结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadDateTime(System.String)">
            <summary>
            从PLC中读取时间格式的数据<br />
            Read time format data from PLC
            </summary>
            <param name="address">地址</param>
            <returns>时间对象</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.DateTime)">
            <summary>
            向PLC中写入时间格式的数据<br />
            Writes data in time format to the PLC
            </summary>
            <param name="address">地址</param>
            <param name="dateTime">时间</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildReadCommand(HslCommunication.Core.Address.S7AddressData[])">
            <summary>
            A general method for generating a command header to read a Word data
            </summary>
            <param name="s7Addresses">siemens address</param>
            <returns>Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildBitReadCommand(System.String)">
            <summary>
            生成一个位读取数据指令头的通用方法 ->
            A general method for generating a bit-read-Data instruction header
            </summary>
            <param name="address">起始地址，例如M100.0，I0.1，Q0.1，DB2.100.2 ->
            Start address, such as M100.0,I0.1,Q0.1,DB2.100.2
            </param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildWriteByteCommand(HslCommunication.OperateResult{HslCommunication.Core.Address.S7AddressData},System.Byte[])">
            <summary>
            生成一个写入字节数据的指令 -> Generate an instruction to write byte data
            </summary>
            <param name="analysis">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">原始的字节数据 -> Raw byte data</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Net.BuildWriteBitCommand(System.String,System.Boolean)">
            <summary>
            生成一个写入位数据的指令 -> Generate an instruction to write bit data
            </summary>
            <param name="address">起始地址，示例M100,I100,Q100,DB1.100 -> Start Address, example M100,I100,Q100,DB1.100</param>
            <param name="data">是否通断 -> Power on or off</param>
            <returns>包含结果对象的报文 -> Message containing the result object</returns>
        </member>
        <member name="T:HslCommunication.Profinet.Siemens.SiemensS7Server">
            <summary>
            西门子S7协议的虚拟服务器，支持TCP协议，无视PLC的型号，所以在客户端进行操作操作的时候，选择1200或是1500或是300或是400都是一样的。<br />
            Siemens S7 protocol virtual server supports TCP protocol, regardless of the PLC model, so when the client performs operations, the choice of 1200 or 1500 or 300 or 400 is the same.
            </summary>
            <remarks>
            地址支持的列表如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>中间寄存器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>DB块寄存器</term>
                <term>DB</term>
                <term>DB1.100,DB1.200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>V寄存器</term>
                <term>V</term>
                <term>V100,V200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>V寄存器本质就是DB块1</term>
              </item>
              <item>
                <term>定时器的值</term>
                <term>T</term>
                <term>T100,T200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
              <item>
                <term>计数器的值</term>
                <term>C</term>
                <term>C100,C200</term>
                <term>10</term>
                <term>√</term>
                <term>√</term>
                <term>未测试通过</term>
              </item>
            </list>
            <note type="important">对于200smartPLC的V区，就是DB1.X，例如，V100=DB1.100</note>
            </remarks>
            <example>
            你可以很快速并且简单的创建一个虚拟的s7服务器
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample1" title="简单的创建服务器" />
            当然如果需要高级的服务器，指定日志，限制客户端的IP地址，获取客户端发送的信息，在服务器初始化的时候就要参照下面的代码：
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="UseExample4" title="定制服务器" />
            服务器创建好之后，我们就可以对服务器进行一些读写的操作了，下面的代码是基础的BCL类型的读写操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="ReadWriteExample" title="基础的读写示例" />
            高级的对于byte数组类型的数据进行批量化的读写操作如下：   
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Profinet\SiemensS7ServerExample.cs" region="BytesReadWrite" title="字节的读写示例" />
            更高级操作请参见源代码。
            </example>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.#ctor">
            <summary>
            实例化一个S7协议的服务器，支持I，Q，M，DB1.X, DB2.X, DB3.X 数据区块的读写操作<br />
            Instantiate a server with S7 protocol, support I, Q, M, DB1.X data block read and write operations
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ReadByte(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadByte(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Byte)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Byte)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Profinet.Siemens.SiemensS7Net.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Profinet.Siemens.SiemensS7Server.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoSerial">
            <summary>
            托利多电子秤的串口服务器对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initial serial port information, 9600 baud rate, 8 data bits, 1 stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initializes serial port information, baud rate, 8-bit data bit, 1-bit stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定<br />
            Start serial port information, baud rate, data bit, stop bit, parity all need to be specified
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息<br />
            Initialize the serial port information according to the custom initialization method
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.Open">
            <summary>
            打开一个新的串行端口连接<br />
            Open a new serial port connection
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态<br />
            Gets a value indicating whether the serial port is open
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.Close">
            <summary>
            关闭当前的串口连接<br />
            Close the current serial connection
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.RtsEnable">
            <summary>
            获取或设置一个值，该值指示在串行通信中是否启用请求发送 (RTS) 信号。<br />
            Gets or sets a value indicating whether the request sending (RTS) signal is enabled in serial communication.
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.PortName">
            <summary>
            当前连接串口信息的端口号名称<br />
            The port name of the current connection serial port information
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoSerial.BaudRate">
            <summary>
            当前连接串口信息的波特率<br />
            Baud rate of current connection serial port information
            </summary>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoSerial.ToledoStandardDataReceivedDelegate">
            <summary>
            托利多数据接收时的委托
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="toledoStandardData">数据对象</param>
        </member>
        <member name="E:HslCommunication.Profinet.Toledo.ToledoSerial.OnToledoStandardDataReceived">
            <summary>
            当接收到一条新的托利多的数据的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoSerial.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoStandardData">
            <summary>
            托利多标准格式的数据类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.#ctor(System.Byte[])">
            <summary>
            从缓存里加载一个标准格式的对象
            </summary>
            <param name="buffer">缓存</param>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Suttle">
            <summary>
            为 True 则是净重，为 False 则为毛重
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Symbol">
            <summary>
            为 True 则是正，为 False 则为负
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.BeyondScope">
            <summary>
            是否在范围之外
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.DynamicState">
            <summary>
            是否为动态，为 True 则是动态，为 False 则为稳态
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Unit">
            <summary>
            单位
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.IsPrint">
            <summary>
            是否打印
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.IsTenExtend">
            <summary>
            是否10被扩展
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Weight">
            <summary>
            重量
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.Tare">
            <summary>
            皮重
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoStandardData.SourceData">
            <summary>
            解析数据的原始字节
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoStandardData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoTcpServer">
            <summary>
            托利多电子秤的TCP服务器，启动服务器后，等待电子秤的数据连接。
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Profinet.Toledo.ToledoTcpServer.HasChk">
            <summary>
            获取或设置当前的报文否是含有校验的，默认为含有校验
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Profinet.Toledo.ToledoTcpServer.ToledoStandardDataReceivedDelegate">
            <summary>
            托利多数据接收时的委托
            </summary>
            <param name="sender">数据发送对象</param>
            <param name="toledoStandardData">数据对象</param>
        </member>
        <member name="E:HslCommunication.Profinet.Toledo.ToledoTcpServer.OnToledoStandardDataReceived">
            <summary>
            当接收到一条新的托利多的数据的时候触发
            </summary>
        </member>
        <member name="M:HslCommunication.Profinet.Toledo.ToledoTcpServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.ABB.ABBWebApiClient">
            <summary>
            ABB机器人的web api接口的客户端，可以方便快速的获取到abb机器人的一些数据信息<br />
            The client of ABB robot's web API interface can easily and quickly obtain some data information of ABB robot
            </summary>
            <remarks>
            参考的界面信息是：http://developercenter.robotstudio.com/webservice/api_reference
            
            关于额外的地址说明，如果想要查看，可以调用<see cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSelectStrings"/> 返回字符串列表来看看。
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String)">
            <summary>
            使用指定的ip地址来初始化对象<br />
            Initializes the object using the specified IP address
            </summary>
            <param name="ipAddress">Ip地址信息</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip地址和端口号来初始化对象<br />
            Initializes the object with the specified IP address and port number
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.#ctor(System.String,System.Int32,System.String,System.String)">
            <summary>
            使用指定的ip地址，端口号，用户名，密码来初始化对象<br />
            Initialize the object with the specified IP address, port number, username, and password
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ReadByAddress(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSelectStrings">
            <summary>
            获取当前支持的读取的地址列表<br />
            Gets a list of addresses for currently supported reads
            </summary>
            <returns>数组信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetCtrlState">
            <summary>
            获取当前的控制状态，Content属性就是机器人的控制信息<br />
            Get the current control state. The Content attribute is the control information of the robot
            </summary>
            <returns>带有状态信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetErrorState">
            <summary>
            获取当前的错误状态，Content属性就是机器人的状态信息<br />
            Gets the current error state. The Content attribute is the state information of the robot
            </summary>
            <returns>带有状态信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetJointTarget">
            <summary>
            获取当前机器人的物理关节点信息，返回json格式的关节信息<br />
            Get the physical node information of the current robot and return the joint information in json format
            </summary>
            <returns>带有关节信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSpeedRatio">
            <summary>
            获取当前机器人的速度配比信息<br />
            Get the speed matching information of the current robot
            </summary>
            <returns>带有速度信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetOperationMode">
            <summary>
            获取当前机器人的工作模式<br />
            Gets the current working mode of the robot
            </summary>
            <returns>带有工作模式信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn">
            <summary>
            获取当前机器人的本机的输入IO<br />
            Gets the input IO of the current robot's native
            </summary>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut">
            <summary>
            获取当前机器人的本机的输出IO<br />
            Gets the output IO of the current robot's native
            </summary>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2In">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOIn"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIO2Out">
            <inheritdoc cref="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetIOOut"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetLog(System.Int32)">
            <summary>
            获取当前机器人的日志记录，默认记录为10条<br />
            Gets the log record for the current robot, which is 10 by default
            </summary>
            <param name="logCount">读取的最大的日志总数</param>
            <returns>带有IO信息的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetSystem">
            <summary>
            获取当前机器人的系统信息，版本号，唯一ID等信息<br />
            Get the current robot's system information, version number, unique ID and other information
            </summary>
            <returns>系统的基本信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRobotTarget">
            <summary>
            获取当前机器人的系统信息，版本号，唯一ID等信息<br />
            Get the current robot's system information, version number, unique ID and other information
            </summary>
            <returns>系统的基本信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetServoEnable">
            <summary>
            获取当前机器人的伺服使能状态<br />
            Get the current robot servo enable state
            </summary>
            <returns>机器人的伺服使能状态</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidExecution">
            <summary>
            获取当前机器人的当前程序运行状态<br />
            Get the current program running status of the current robot
            </summary>
            <returns>机器人的当前的程序运行状态</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.GetRapidTasks">
            <summary>
            获取当前机器人的任务列表<br />
            Get the task list of the current robot
            </summary>
            <returns>任务信息的列表</returns>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.ABB.ABBWebApiServer">
            <summary>
            ABB机器人的虚拟服务器，基于WebApi协议构建，可用于读取一些数据信息<br />
            The virtual server of ABB robot, built based on the WebApi protocol, can be used to read some data information
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.SetLoginAccount(System.String,System.String)">
            <summary>
            设置用户的登录信息，用户名和密码信息<br />
            Set user login information, user name and password information
            </summary>
            <param name="name">用户名</param>
            <param name="password">密码</param>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)">
            <inheritdoc cref="M:HslCommunication.Enthernet.HttpServer.HandleRequest(System.Net.HttpListenerRequest,System.Net.HttpListenerResponse,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.ABB.ABBWebApiServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.EfortData">
            <summary>
            埃夫特机器人的数据结构<br />
            The data structure of the efort robot
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketStart">
            <summary>
            报文开始的字符串
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketOrders">
            <summary>
            数据命令
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketHeartbeat">
            <summary>
            数据心跳
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ErrorStatus">
            <summary>
            报警状态，1:有报警，0：无报警
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.HstopStatus">
            <summary>
            急停状态，1：无急停，0：有急停
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.AuthorityStatus">
            <summary>
            权限状态，1：有权限，0：无权限
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ServoStatus">
            <summary>
            伺服状态，1：有使能，0：未使能
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.AxisMoveStatus">
            <summary>
            轴运动状态，1：有运动，0：未运动
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgMoveStatus">
            <summary>
            程序运行状态，1：有运行，0：未运行
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgLoadStatus">
            <summary>
            程序加载状态，1：有加载，0：无加载
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgHoldStatus">
            <summary>
            程序暂停状态，1：有暂停，0：无暂停
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ModeStatus">
            <summary>
            模式状态，1:手动，2:自动，3:远程
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.SpeedStatus">
            <summary>
            读读状态，百分比（单位）
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoDOut">
            <summary>
            IoDOut状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoDIn">
            <summary>
            IoDIn状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoIOut">
            <summary>
            IoIOut状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.IoIIn">
            <summary>
            IoIIn状态
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProjectName">
            <summary>
            加载工程名
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ProgramName">
            <summary>
            加载程序名
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.ErrorText">
            <summary>
            错误信息
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisPos">
            <summary>
            一到七轴的角度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbCartPos">
            <summary>
            X,Y,Z,A,B,C方向，也叫笛卡尔坐标系
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisSpeed">
            <summary>
            一到七轴的速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisAcc">
            <summary>
            一到七轴的加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisAccAcc">
            <summary>
            一到七轴的加加速度
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisTorque">
            <summary>
            一到七轴的力矩
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisDirCnt">
            <summary>
            轴反向计数
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbAxisTime">
            <summary>
            轴工作总时长
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.DbDeviceTime">
            <summary>
            设备开机总时长
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.EFORT.EfortData.PacketEnd">
            <summary>
            报文结束标记
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.PraseFromPrevious(System.Byte[])">
            <summary>
            从之前的版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.EfortData.PraseFrom(System.Byte[])">
            <summary>
            从新版本数据构造一个埃夫特机器人的数据类型
            </summary>
            <param name="data">真实的数据内容</param>
            <returns>转换的结果内容</returns>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.ER7BC10">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为定制版，新版报文对齐<br />
            The corresponding model of efort robot is er7b-c10. This protocol is the customized version, and the new version is the message alignment
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008<br />
            Instantiate a default object and specify the IP address and port number, usually 8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.GetReadCommand">
            <summary>
            获取发送的消息的命令<br />
            Gets the command to send the message
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ReadEfortData">
            <summary>
            读取机器人的详细信息，返回解析后的数据类型<br />
            Read the details of the robot and return the resolved data type
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.EFORT.ER7BC10Previous">
            <summary>
            埃夫特机器人对应型号为ER7B-C10，此协议为旧版的定制版，报文未对齐的版本<br />
            The corresponding model of the efort robot is er7b-c10. This protocol is a customized version of the old version, and the message is not aligned
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的对象，并指定IP地址和端口号，端口号通常为8008<br />
            Instantiate a default object and specify the IP address and port number, usually 8008
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.GetReadCommand">
            <summary>
            获取发送的消息的命令<br />
            Gets the command to send the message
            </summary>
            <returns>字节数组命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.Byte[])">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.Write(System.String,System.String)">
            <summary>
            本机器人不支持该方法操作，将永远返回失败，无效的操作<br />
            This robot does not support this method operation, will always return failed, invalid operation
            </summary>
            <param name="address">指定的地址信息，有些机器人可能不支持</param>
            <param name="value">字符串的数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ReadEfortData">
            <summary>
            读取机器人的详细信息<br />
            Read the details of the robot
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.EFORT.ER7BC10Previous.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucAlarm">
            <summary>
            Fanuc机器人的报警对象
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmID">
            <summary>
            AlarmID
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmNumber">
            <summary>
            AlarmNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmID">
            <summary>
            CauseAlarmID
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmNumber">
            <summary>
            CauseAlarmNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.Severity">
            <summary>
            Severity
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.Time">
            <summary>
            Time
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.AlarmMessage">
            <summary>
            AlarmMessage
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.CauseAlarmMessage">
            <summary>
            CauseAlarmMessage
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucAlarm.SeverityMessage">
            <summary>
            SeverityMessage
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从字节数据加载真实的信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节内容</param>
            <param name="index">索引</param>
            <param name="encoding">编码</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucAlarm.PraseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从数据内容创建报警信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节内容</param>
            <param name="index">索引</param>
            <param name="encoding">编码</param>
            <returns>报警信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucData">
            <summary>
            Fanuc机器人的所有的数据信息
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.LoadByContent(System.Byte[])">
            <summary>
            从原始的数据内容加载数据
            </summary>
            <param name="content">原始的内容</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucData.PraseFrom(System.Byte[])">
            <summary>
            从字节数组解析出fanuc的数据信息
            </summary>
            <param name="content">原始的字节数组</param>
            <returns>fanuc数据</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucHelper">
            <summary>
            Fanuc的辅助方法信息
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_Q">
            <summary>
            Q区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_I">
            <summary>
            I区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_AQ">
            <summary>
            AQ区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_AI">
            <summary>
            AI区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_M">
            <summary>
            M区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_D">
            <summary>
            D区数据
            </summary>
        </member>
        <member name="F:HslCommunication.Robot.FANUC.FanucHelper.SELECTOR_G">
            <summary>
            命令数据
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.AnalysisFanucAddress(System.String)">
            <summary>
            从FANUC机器人地址进行解析数据信息，地址为D,I,Q,M,AI,AQ区<br />
            Parse data information from FANUC robot address, the address is D, I, Q, M, AI, AQ area
            </summary>
            <param name="address">fanuc机器人的地址信息</param>
            <returns>解析结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BulidReadData(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            构建读取数据的报文内容
            </summary>
            <param name="sel">数据类别</param>
            <param name="address">偏移地址</param>
            <param name="length">长度</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BuildReadResponseData(System.Byte[])">
            <summary>
            构建读取返回的数据信息
            </summary>
            <param name="data">数据</param>
            <returns>结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.BuildWriteData(System.Byte,System.UInt16,System.Byte[],System.Int32)">
            <summary>
            构建写入的数据报文，需要指定相关的参数信息
            </summary>
            <param name="sel">数据类别</param>
            <param name="address">偏移地址</param>
            <param name="value">原始数据内容</param>
            <param name="length">写入的数据长度</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucHelper.GetFanucCmds">
            <summary>
            获取所有的命令信息<br />
            Get all command information
            </summary>
            <returns>命令数组</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucInterfaceNet">
            <summary>
            Fanuc机器人的PC Interface实现，在R-30iB mate plus型号上测试通过，支持读写任意的数据，写入操作务必谨慎调用，写入数据不当造成生命财产损失，作者概不负责。读写任意的地址见api文档信息<br />
            The Fanuc robot's PC Interface implementation has been tested on R-30iB mate plus models. It supports reading and writing arbitrary data. The writing operation must be called carefully. 
            Improper writing of data will cause loss of life and property. The author is not responsible. Read and write arbitrary addresses see api documentation information
            </summary>
            <remarks>
            如果使用绝对地址进行访问的话，支持的地址格式如下：
            <list type="table">
              <listheader>
                <term>地址名称</term>
                <term>地址代号</term>
                <term>示例</term>
                <term>地址进制</term>
                <term>字操作</term>
                <term>位操作</term>
                <term>备注</term>
              </listheader>
              <item>
                <term>数据寄存器</term>
                <term>D</term>
                <term>D100,D200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入寄存器</term>
                <term>AI</term>
                <term>AI100,AI200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输出寄存器</term>
                <term>AQ</term>
                <term>AQ100,Q200</term>
                <term>10</term>
                <term>√</term>
                <term>×</term>
                <term></term>
              </item>
              <item>
                <term>输入继电器</term>
                <term>I</term>
                <term>I100,I200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>输出继电器</term>
                <term>Q</term>
                <term>Q100,Q200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
              <item>
                <term>中间继电器</term>
                <term>M</term>
                <term>M100,M200</term>
                <term>10</term>
                <term>×</term>
                <term>√</term>
                <term></term>
              </item>
            </list>
            </remarks>
            <example>
            我们先来看看简单的情况
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample1" title="简单的读取" />
            读取fanuc部分数据
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample2" title="属性读取" />
            最后是比较高级的任意数据读写
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Robot\FANUC\FanucInterfaceNetSample.cs" region="Sample3" title="复杂读取" />
            </example>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.#ctor(System.String,System.Int32)">
            <summary>
            指定ip及端口来实例化一个默认的对象，端口默认60008<br />
            Specify the IP and port to instantiate a default object, the port defaults to 60008
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucInterfaceNet.ClientId">
            <summary>
            获取或设置当前客户端的ID信息，默认为1024<br />
            Gets or sets the ID information of the current client. The default is 1024.
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucInterfaceNet.FanucDataRetainTime">
            <summary>
            获取或设置缓存的Fanuc数据的有效时间，对<see cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)"/>方法有效，默认为100，单位毫秒。也即是在100ms内频繁读取机器人的属性数据的时候，优先读取缓存值，提高读取效率。<br />
            Gets or sets the valid time of the cached Fanuc data. It is valid for the <see cref="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)" /> method. The default is 100, in milliseconds. 
            That is, when the attribute data of the robot is frequently read within 100ms, the cache value is preferentially read to improve the reading efficiency.
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.String,System.UInt16)">
            <summary>
            按照字为单位批量读取设备的原始数据，需要指定地址及长度，地址示例：D1，AI1，AQ1，共计3个区的数据，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of words. You need to specify the address and length. Example addresses: D1, AI1, AQ1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1</param>
            <param name="length">读取的长度，字为单位</param>
            <returns>返回的数据信息结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1<br />
            Write the original byte array data to the specified address, and return whether the write was successful. Example addresses: D1, AI1, AQ1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：D1，AI1，AQ1，共计3个区的数据，注意起始的起始为1</param>
            <param name="value">写入值</param>
            <returns>带有成功标识的结果类对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.String,System.UInt16)">
            <summary>
            按照位为单位批量读取设备的原始数据，需要指定地址及长度，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of boolean. You need to specify the address and length. Example addresses: M1，I1，Q1, a total of 3 areas of data. Note that the start of the address is 1.
            </summary>
            <param name="address">起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1</param>
            <param name="length">读取的长度，位为单位</param>
            <returns>返回的数据信息结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.String,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否写入成功，需要指定起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1<br />
            Write <see cref="T:System.Boolean"/> array data in batches. If the write success is returned, you need to specify the starting address. Example address: M1, I1, Q1, a total of 3 areas of data. Note that the starting address is 1.
            </summary>
            <param name="address">起始地址，地址示例：M1，I1，Q1，共计3个区的数据，注意地址的起始为1</param>
            <param name="value">等待写入的数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Read(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            按照字为单位批量读取设备的原始数据，需要指定数据块地址，偏移地址及长度，主要针对08, 10, 12的数据块，注意地址的起始为1<br />
            Read the raw data of the device in batches in units of words. You need to specify the data block address, offset address, and length. It is mainly for data blocks of 08, 10, and 12. Note that the start of the address is 1.
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度，字为单位</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.Write(System.Byte,System.UInt16,System.Byte[])">
            <summary>
            写入原始的byte数组数据到指定的地址，返回是否写入成功，，需要指定数据块地址，偏移地址，主要针对08, 10, 12的数据块，注意起始的起始为1<br />
            Write the original byte array data to the specified address, and return whether the writing is successful. You need to specify the data block address and offset address, 
            which are mainly for the data blocks of 08, 10, and 12. Note that the start of the start is 1.
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="value">原始数据内容</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadBool(System.Byte,System.UInt16,System.UInt16)">
            <summary>
            按照位为单位批量读取设备的原始数据，需要指定数据块地址，偏移地址及长度，主要针对70, 72, 76的数据块，注意地址的起始为1<br />
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度，字为单位</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteBool(System.Byte,System.UInt16,System.Boolean[])">
            <summary>
            批量写入<see cref="T:System.Boolean"/>数组数据，返回是否写入成功，需要指定数据块地址，偏移地址，主要针对70, 72, 76的数据块，注意起始的起始为1
            </summary>
            <param name="select">数据块信息</param>
            <param name="address">偏移地址</param>
            <param name="value">原始的数据内容</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadFanucData">
            <summary>
            读取机器人的详细信息，返回解析后的数据类型<br />
            Read the details of the robot and return the resolved data type
            </summary>
            <returns>结果数据信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取的长度</param>
            <returns>结果数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSDI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSDI(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的RDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDI(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的RDI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的UI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadUO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的UO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteUO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的UO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadSO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的SO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteSO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的SO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGI(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的GI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">数据长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGI(System.UInt16,System.UInt16[])">
            <summary>
            写入机器人的GI信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadGO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的GO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteGO(System.UInt16,System.UInt16[])">
            <summary>
            写入机器人的GO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>写入结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadPMCR2(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的PMCR2信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WritePMCR2(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的PMCR2信息
            </summary>
            <param name="address">偏移信息</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ReadRDO(System.UInt16,System.UInt16)">
            <summary>
            读取机器人的RDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="length">读取长度</param>
            <returns>结果信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRDO(System.UInt16,System.Boolean[])">
            <summary>
            写入机器人的RDO信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="value">数据值</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRXyzwpr(System.UInt16,System.Single[],System.Int16[],System.Int16,System.Int16)">
            <summary>
            写入机器人的Rxyzwpr信息，谨慎调用，
            </summary>
            <param name="Address">偏移地址</param>
            <param name="Xyzwpr">姿态信息</param>
            <param name="Config">设置信息</param>
            <param name="UserFrame">参考系</param>
            <param name="UserTool">工具</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.WriteRJoint(System.UInt16,System.Single[],System.Int16,System.Int16)">
            <summary>
            写入机器人的Joint信息
            </summary>
            <param name="address">偏移地址</param>
            <param name="joint">关节坐标</param>
            <param name="UserFrame">参考系</param>
            <param name="UserTool">工具</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucInterfaceNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucPose">
            <summary>
            机器人的姿态数据
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Xyzwpr">
            <summary>
            Xyzwpr
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Config">
            <summary>
            Config
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.Joint">
            <summary>
            Joint
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.UF">
            <summary>
            UF
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.UT">
            <summary>
            UT
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.ValidC">
            <summary>
            ValidC
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucPose.ValidJ">
            <summary>
            ValidJ
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32)">
            <summary>
            从原始数据解析出当前的姿态数据
            </summary>
            <param name="byteTransform">字节变化内容</param>
            <param name="content">原始的内容</param>
            <param name="index">索引位置</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.PraseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32)">
            <summary>
            从原始的字节数据创建一个新的姿态数据
            </summary>
            <param name="byteTransform"></param>
            <param name="content">原始的内容</param>
            <param name="index">索引位置</param>
            <returns>姿态数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucPose.TransConfigStringArray(System.Int16[])">
            <summary>
            将short类型的config数组转换成string数组类型的config
            </summary>
            <param name="value">short数组的值</param>
            <returns>string数组的值</returns>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucRobotServer">
            <summary>
            虚拟的FANUC机器人的服务器对象，支持I,Q,M,D,AI,AQ数据区的数据读写，其中D区是机器人数据存放的区域，相关的数据需要去机器人区读取。详细参见api文档信息。<br />
            The server object of the virtual FANUC robot supports data reading and writing in I, Q, M, D, AI, and AQ data areas, 
            where D area is the area where the robot data is stored, and related data needs to be read in the robot area. See the api documentation for details.
            </summary>
            <remarks>
            <inheritdoc cref="T:HslCommunication.Robot.FANUC.FanucInterfaceNet" path="remarks"/>
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.#ctor">
            <summary>
            实例化一个默认的对象信息，并初始化机器人的相关数据<br />
            Instantiate a default object information and initialize the relevant data of the robot
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Read(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Write(System.String,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ReadBool(System.String,System.UInt16)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Write(System.String,System.Boolean[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ThreadPoolLoginAfterClientCheck(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.LoadFromBytes(System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.SaveToBytes">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucRobotServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.FANUC.FanucTask">
            <summary>
            Fanuc机器人的任务类
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.ProgramName">
            <summary>
            ProgramName
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.LineNumber">
            <summary>
            LineNumber
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.State">
            <summary>
            State
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.FANUC.FanucTask.ParentProgramName">
            <summary>
            ParentProgramName
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.LoadByContent(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从原始的数据对象加载数据信息
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节数据</param>
            <param name="index">索引信息</param>
            <param name="encoding">编码</param>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.FANUC.FanucTask.PraseFrom(HslCommunication.Core.IByteTransform,System.Byte[],System.Int32,System.Text.Encoding)">
            <summary>
            从原始的数据信息初始化一个任务对象
            </summary>
            <param name="byteTransform">字节变换</param>
            <param name="content">原始的字节数据</param>
            <param name="index">索引信息</param>
            <param name="encoding">编码</param>
            <returns>任务对象</returns>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiData">
            <summary>
            Hyundai的数据类对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.#ctor(System.Byte[])">
            <summary>
            通过缓存对象实例化一个
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Command">
            <summary>
            命令码，从控制器发数据到PC和PC到控制器，两者的命令不一样
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.CharDummy">
            <summary>
            虚标记
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.State">
            <summary>
            状态码
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Count">
            <summary>
            标记数据，从PLC发送给机器人的数据，原封不动的返回
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.IntDummy">
            <summary>
            虚标记
            </summary>
        </member>
        <member name="P:HslCommunication.Robot.Hyundai.HyundaiData.Data">
            <summary>
            关节坐标数据，包含X,Y,Z,W,P,R，三个位置数据，三个角度数据。
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.LoadBy(System.Byte[],System.Int32)">
            <summary>
            从字节数组的指定索引开始加载现在机器人的数据
            </summary>
            <param name="buffer">原始的字节数据</param>
            <param name="index">起始的索引信息</param>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.ToBytes">
            <summary>
            将现代机器人的数据转换为字节数组
            </summary>
            <returns>字节数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiData.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiUdpNet">
            <summary>
            现代机器人的UDP通讯类，注意本类是服务器，需要等待机器人先配置好ip地址及端口，然后连接到本服务器才能正确的进行操作。详细参见api文档注释<br />
            The UDP communication class of modern robots. Note that this class is a server. You need to wait for the robot to configure the IP address and port first, 
            and then connect to this server to operate correctly. See api documentation for details
            </summary>
            <remarks>
            为使用联机跟踪功能，通过JOB文件的 OnLTrack 命令激活本功能后对通信及位置增量命令 Filter 进行设置，必要时以 LIMIT 命令设置机器人的动作领域，速度限制项。
            最后采用 OnLTrack 命令关闭联机跟踪功能以退出本功能。<br />
            功能开始，通信及 Filter 设置，程序示例： OnLTrack ON,IP=192.168.1.254,PORT=7127,CRD=1,Bypass,Fn=10
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.ThreadReceiveCycle">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.WriteIncrementPos(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            将指定的增量写入机器人，需要指定6个参数，位置和角度信息，其中位置单位为mm，角度单位为°<br />
            To write the specified increment to the robot, you need to specify 6 parameters, 
            position and angle information, where the position unit is mm and the angle unit is °
            </summary>
            <param name="x">X轴增量信息，单位毫米</param>
            <param name="y">Y轴增量信息，单位毫米</param>
            <param name="z">Z轴增量信息，单位毫米</param>
            <param name="rx">X轴角度增量信息，单位角度</param>
            <param name="ry">Y轴角度增量信息，单位角度</param>
            <param name="rz">Z轴角度增量信息，单位角度</param>
            <returns>是否写入机器人成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.WriteIncrementPos(System.Double[])">
            <summary>
            将指定的增量写入机器人，需要指定6个参数，位置和角度信息，其中位置单位为mm，角度单位为°<br />
            To write the specified increment to the robot, you need to specify 6 parameters, position and angle information, where the position unit is mm and the angle unit is °
            </summary>
            <param name="pos">增量的数组信息</param>
            <returns>是否写入机器人成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.Write(HslCommunication.Robot.Hyundai.HyundaiData)">
            <summary>
            将指定的命令写入机器人，该命令是完全自定义的，需要遵循机器人的通讯协议，在写入之前，需要调用<see cref="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)"/> 方法<br />
            Write the specified command to the robot. The command is completely customized and needs to follow the robot's communication protocol. 
            Before writing, you need to call the <see cref="M:HslCommunication.Core.Net.NetworkUdpServerBase.ServerStart(System.Int32)" />
            </summary>
            <param name="data">机器人数据</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveX(System.Double)">
            <summary>
            机器人在X轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the X axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveY(System.Double)">
            <summary>
            机器人在Y轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the Y axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.MoveZ(System.Double)">
            <summary>
            机器人在Z轴上移动一小段距离，单位毫米<br />
            The robot moves a short distance on the Z axis, in millimeters
            </summary>
            <param name="value">移动距离，单位毫米</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateX(System.Double)">
            <summary>
            机器人在X轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the X axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateY(System.Double)">
            <summary>
            机器人在Y轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the Y axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.RotateZ(System.Double)">
            <summary>
            机器人在Z轴方向上旋转指定角度，单位角度<br />
            The robot rotates the specified angle in the Z axis direction, the unit angle
            </summary>
            <param name="value">旋转角度，单位角度</param>
            <returns>是否写入成功</returns>
        </member>
        <member name="T:HslCommunication.Robot.Hyundai.HyundaiUdpNet.OnHyundaiMessageReceiveDelegate">
            <summary>
            收到机器人消息的事件委托
            </summary>
            <param name="data">机器人消息</param>
        </member>
        <member name="E:HslCommunication.Robot.Hyundai.HyundaiUdpNet.OnHyundaiMessageReceive">
            <summary>
            当接收到机器人数据的时候触发的事件
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.Hyundai.HyundaiUdpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.KUKA.KukaAvarProxyNet">
            <summary>
            Kuka机器人的数据交互类，通讯支持的条件为KUKA 的 KRC4 控制器中运行KUKAVARPROXY 这个第三方软件，端口通常为7000<br />
            The data interaction class of Kuka robot is supported by the third-party software KUKAVARPROXY running in the KRC4 controller of Kuka. The port is usually 7000
            </summary>
            <remarks>
            非常感谢 昆山-LT 网友的测试和意见反馈。<br />
            其中KUKAVARPROXY 这个第三方软件在来源地址：
            https://github.com/ImtsSrl/KUKAVARPROXY <br />
            如果想要更详细的了解配置，连接，数据读取操作，请点击下面的连接：http://blog.davidrobot.com/2019/03/hsl_for_kuka.html?tdsourcetag=s_pctim_aiomsg
            </remarks>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的Kuka机器人对象，并指定IP地址和端口号，端口号通常为7000<br />
            Instantiate a default Kuka robot object and specify the IP address and port number, usually 7000
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.GetNewNetMessage">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Read(System.String)">
            <summary>
            读取Kuka机器人的数据内容，根据输入的变量名称来读取<br />
            Read the data content of the Kuka robot according to the input variable name
            </summary>
            <param name="address">地址数据</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ReadString(System.String)">
            <summary>
            读取Kuka机器人的所有的数据信息，返回字符串信息，解码方式为ANSI，需要指定变量名称<br />
            Read all the data information of the Kuka robot, return the string information, decode by ANSI, need to specify the variable name
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.Byte[])">
            <summary>
            根据Kuka机器人的变量名称，写入原始的数据内容<br />
            Write the original data content according to the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.Write(System.String,System.String)">
            <summary>
            根据Kuka机器人的变量名称，写入ANSI编码的字符串数据信息<br />
            Writes ansi-encoded string data information based on the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.PackCommand(System.Byte[])">
            <summary>
            将核心的指令打包成一个可用于发送的消息对象<br />
            Package the core instructions into a message object that can be sent
            </summary>
            <param name="commandCore">核心命令</param>
            <returns>最终实现的可以发送的机器人的字节数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaAvarProxyNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Robot.KUKA.KukaTcpNet">
            <summary>
            Kuka机器人的数据交互类，通讯支持的条件为KUKA 的 TCP通讯
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.#ctor(System.String,System.Int32)">
            <summary>
            实例化一个默认的Kuka机器人对象，并指定IP地址和端口号，端口号通常为9999<br />
            Instantiate a default Kuka robot object and specify the IP address and port number, usually 9999
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Read(System.String)">
            <summary>
            读取Kuka机器人的数据内容，根据输入的变量名称来读取<br />
            Read the data content of the Kuka robot according to the input variable name
            </summary>
            <param name="address">地址数据</param>
            <returns>带有成功标识的byte[]数组</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ReadString(System.String)">
            <summary>
            读取Kuka机器人的所有的数据信息，返回字符串信息，解码方式为UTF8，需要指定变量名称<br />
            Read all the data information of the Kuka robot, return the string information, decode by ANSI, need to specify the variable name
            </summary>
            <param name="address">地址信息</param>
            <returns>带有成功标识的字符串数据</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.Byte[])">
            <summary>
            根据Kuka机器人的变量名称，写入原始的数据内容<br />
            Write the original data content according to the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">原始的字节数据信息</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String,System.String)">
            <summary>
            根据Kuka机器人的变量名称，写入UTF8编码的字符串数据信息<br />
            Writes ansi-encoded string data information based on the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.Write(System.String[],System.String[])">
            <summary>
            根据Kuka机器人的变量名称，写入UTF8编码的字符串数据信息<br />
            Writes ansi-encoded string data information based on the variable name of the Kuka robot
            </summary>
            <param name="address">变量名称</param>
            <param name="value">ANSI编码的字符串</param>
            <returns>是否成功的写入</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StartProgram(System.String)">
            <summary>
            启动机器人的指定的程序<br />
            Start the specified program of the robot
            </summary>
            <param name="program">程序的名字</param>
            <returns>是否启动成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ResetProgram">
            <summary>
            复位当前的程序<br />
            Reset current program
            </summary>
            <returns>复位结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.StopProgram">
            <summary>
            停止当前的程序<br />
            Stop current program
            </summary>
            <returns>复位结果</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildReadCommands(System.String[])">
            <summary>
            构建读取变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildReadCommands(System.String)">
            <summary>
            构建读取变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <returns>报文内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildWriteCommands(System.String[],System.String[])">
            <summary>
            构建写入变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <param name="values">数据信息</param>
            <returns>字符串信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.KUKA.KukaTcpNet.BuildWriteCommands(System.String,System.String)">
            <summary>
            构建写入变量的报文命令
            </summary>
            <param name="address">地址信息</param>
            <param name="value">数据信息</param>
            <returns>字符串信息</returns>
        </member>
        <member name="T:HslCommunication.Robot.YAMAHA.YamahaRCX">
            <summary>
            雅马哈机器人的数据访问类
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.#ctor(System.String,System.Int32)">
            <summary>
            指定IP地址和端口来实例化一个对象
            </summary>
            <param name="ipAddress">IP地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadFromServer(System.Byte[],System.Int32)">
            <summary>
            发送命令行到socket, 并从机器人读取指定的命令行
            </summary>
            <param name="send">等待发送的数据</param>
            <param name="lines">接收的行数</param>
            <returns>结果的结果数据内容</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadCommand(System.String,System.Int32)">
            <summary>
            读取指定的命令的方法
            </summary>
            <param name="command">命令</param>
            <param name="lines">接收的行数信息</param>
            <returns>接收的命令</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Reset">
            <summary>
            指定程序复位信息，对所有的程序进行复位。当重新启动了程序时，从主程序或者任务 1 中最后执行的程序开头开始执行。
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Run">
            <summary>
            执行程序运行。执行所有的 RUN 状态程序。
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.Stop">
            <summary>
            执行程序停止。执行所有的 STOP 状态程序。
            </summary>
            <returns>执行结果是否成功</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadMotorStatus">
            <summary>
            获取马达电源状态，返回的0:马达电源关闭; 1:马达电源开启; 2:马达电源开启＋所有机器人伺服开启
            </summary>
            <returns>返回的0:马达电源关闭; 1:马达电源开启; 2:马达电源开启＋所有机器人伺服开启</returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadModeStatus">
            <summary>
            读取模式状态
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadJoints">
            <summary>
            读取关节的基本数据信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:HslCommunication.Robot.YAMAHA.YamahaRCX.ReadEmergencyStatus">
            <summary>
            读取紧急停止状态，0 ：正常状态、1 ：紧急停止状态
            </summary>
            <returns></returns>
        </member>
        <member name="T:HslCommunication.Robot.YASKAWA.YRC1000TcpNet">
            <summary>
            安川机器人的Ethernet 服务器功能的通讯类<br />
            Yaskawa robot's Ethernet server features a communication class
            </summary>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.#ctor(System.String,System.Int32)">
            <summary>
            指定机器人的ip地址及端口号来实例化对象<br />
            Specify the robot's IP address and port number to instantiate the object
            </summary>
            <param name="ipAddress">Ip地址</param>
            <param name="port">端口号</param>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Read(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Read(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadString(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.ReadString(System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.Net.IRobotNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <summary>
            before read data , the connection should be Initialized
            </summary>
            <param name="socket">connected socket</param>
            <returns>whether is the Initialization is success.</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <summary>
            重写父类的数据交互方法，接收的时候采用标识符来接收<br />
            Overrides the data interaction method of the parent class, using an identifier when receiving
            </summary>
            <param name="socket">套接字</param>
            <param name="send">发送的数据</param>
            <returns>发送结果对象</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadFromCoreServer(System.Net.Sockets.Socket,System.String)">
            <summary>
            Read string value from socket
            </summary>
            <param name="socket">connected socket</param>
            <param name="send">string value</param>
            <returns>received string value with is successfully</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadByCommand(System.String,System.String)">
            <summary>
            根据指令来读取设备的信息，如果命令数据为空，则传入null即可，注意，所有的命令不带换行符<br />
            Read the device information according to the instructions. If the command data is empty, pass in null. Note that all commands do not have a newline character
            </summary>
            <param name="command">命令的内容</param>
            <param name="commandData">命令数据内容</param>
            <returns>最终的结果内容，需要对IsSuccess进行验证</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadRALARM">
            <summary>
            读取机器人的报警信息
            </summary>
            <returns>原始的报警信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ReadRPOSJ">
            <summary>
            读取机器人的坐标数据信息
            </summary>
            <returns>原始的报警信息</returns>
        </member>
        <member name="M:HslCommunication.Robot.YASKAWA.YRC1000TcpNet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Serial.SoftCRC16">
            <summary>
            用于CRC16验证的类，提供了标准的验证方法，可以方便快速的对数据进行CRC校验<br />
            The class for CRC16 validation provides a standard validation method that makes it easy to CRC data quickly
            </summary>
            <remarks>
            本类提供了几个静态的方法，用来进行CRC16码的计算和验证的，多项式码可以自己指定配置，但是预置的寄存器为0xFF 0xFF
            </remarks>
            <example>
            先演示如何校验一串数据的CRC码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example1" title="SoftCRC16示例" />
            然后下面是如何生成你自己的CRC校验码
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\Serial\SoftCRC16.cs" region="Example2" title="SoftCRC16示例" />
            </example>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CheckCRC16(System.Byte[])">
            <summary>
            来校验对应的接收数据的CRC校验码，默认多项式码为0xA001<br />
            To verify the CRC check code corresponding to the received data, the default polynomial code is 0xA001
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CheckCRC16(System.Byte[],System.Byte,System.Byte)">
            <summary>
            指定多项式码来校验对应的接收数据的CRC校验码<br />
            Specifies a polynomial code to validate the corresponding CRC check code for the received data
            </summary>
            <param name="value">需要校验的数据，带CRC校验码</param>
            <param name="CH">多项式码高位</param>
            <param name="CL">多项式码低位</param>
            <returns>返回校验成功与否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CRC16(System.Byte[])">
            <summary>
            获取对应的数据的CRC校验码，默认多项式码为0xA001<br />
            Get the CRC check code of the corresponding data, the default polynomial code is 0xA001
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftCRC16.CRC16(System.Byte[],System.Byte,System.Byte)">
            <summary>
            通过指定多项式码来获取对应的数据的CRC校验码<br />
            The CRC check code of the corresponding data is obtained by specifying the polynomial code
            </summary>
            <param name="value">需要校验的数据，不包含CRC字节</param>
            <param name="CL">多项式码地位</param>
            <param name="CH">多项式码高位</param>
            <returns>返回带CRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="T:HslCommunication.Serial.SerialBase">
            <summary>
            所有串行通信类的基类，提供了一些基础的服务，核心的通信实现<br />
            The base class of all serial communication classes provides some basic services for the core communication implementation
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.#ctor">
            <summary>
            实例化一个无参的构造方法<br />
            Instantiate a parameterless constructor
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String)">
            <summary>
            初始化串口信息，9600波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initial serial port information, 9600 baud rate, 8 data bits, 1 stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String,System.Int32)">
            <summary>
            初始化串口信息，波特率，8位数据位，1位停止位，无奇偶校验<br />
            Initializes serial port information, baud rate, 8-bit data bit, 1-bit stop bit, no parity
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.String,System.Int32,System.Int32,System.IO.Ports.StopBits,System.IO.Ports.Parity)">
            <summary>
            初始化串口信息，波特率，数据位，停止位，奇偶校验需要全部自己来指定<br />
            Start serial port information, baud rate, data bit, stop bit, parity all need to be specified
            </summary>
            <param name="portName">端口号信息，例如"COM3"</param>
            <param name="baudRate">波特率</param>
            <param name="dataBits">数据位</param>
            <param name="stopBits">停止位</param>
            <param name="parity">奇偶校验</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SerialPortInni(System.Action{System.IO.Ports.SerialPort})">
            <summary>
            根据自定义初始化方法进行初始化串口信息<br />
            Initialize the serial port information according to the custom initialization method
            </summary>
            <param name="initi">初始化的委托方法</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Open">
            <summary>
            打开一个新的串行端口连接<br />
            Open a new serial port connection
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.IsOpen">
            <summary>
            获取一个值，指示串口是否处于打开状态<br />
            Gets a value indicating whether the serial port is open
            </summary>
            <returns>是或否</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Close">
            <summary>
            关闭当前的串口连接<br />
            Close the current serial connection
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadBase(System.Byte[])">
            <summary>
            将原始的字节数据发送到串口，然后从串口接收一条数据。<br />
            The raw byte data is sent to the serial port, and then a piece of data is received from the serial port.
            </summary>
            <param name="send">发送的原始字节数据</param>
            <returns>带接收字节的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ReadBase(System.Byte[],System.Boolean)">
            <summary>
            将原始的字节数据发送到串口，然后从串口接收一条数据。<br />
            The raw byte data is sent to the serial port, and then a piece of data is received from the serial port.
            </summary>
            <param name="send">发送的原始字节数据</param>
            <param name="sendOnly">是否只是发送，如果为true, 不需要等待数据返回，如果为false, 需要等待数据返回</param>
            <returns>带接收字节的结果对象</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ClearSerialCache">
            <summary>
            清除串口缓冲区的数据，并返回该数据，如果缓冲区没有数据，返回的字节数组长度为0<br />
            The number sent clears the data in the serial port buffer and returns that data, or if there is no data in the buffer, the length of the byte array returned is 0
            </summary>
            <returns>是否操作成功的方法</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.InitializationOnOpen">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.InitializationOnConnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ExtraOnClose">
            <inheritdoc cref="M:HslCommunication.Core.Net.NetworkDoubleBase.ExtraOnDisconnect(System.Net.Sockets.Socket)"/>
        </member>
        <member name="F:HslCommunication.Serial.SerialBase.LogMsgFormatBinary">
            <inheritdoc cref="F:HslCommunication.Core.Net.NetworkDoubleBase.LogMsgFormatBinary"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SPSend(System.IO.Ports.SerialPort,System.Byte[])">
            <summary>
            发送数据到串口去。<br />
            Send data to serial port.
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="data">字节数据</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.SPReceived(System.IO.Ports.SerialPort,System.Boolean)">
            <summary>
            从串口接收一串字节数据信息，直到没有数据为止，如果参数awaitData为false, 第一轮接收没有数据则返回<br />
            Receives a string of bytes of data information from the serial port until there is no data, and returns if the parameter awaitData is false
            </summary>
            <param name="serialPort">串口对象</param>
            <param name="awaitData">是否必须要等待数据返回</param>
            <returns>结果数据对象</returns>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.LogNet">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkBase.LogNet"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.RtsEnable">
            <summary>
            获取或设置一个值，该值指示在串行通信中是否启用请求发送 (RTS) 信号。<br />
            Gets or sets a value indicating whether the request sending (RTS) signal is enabled in serial communication.
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.ReceiveTimeout">
            <summary>
            接收数据的超时时间，默认5000ms<br />
            Timeout for receiving data, default is 5000ms
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.SleepTime">
            <summary>
            连续串口缓冲数据检测的间隔时间，默认20ms，该值越小，通信速度越快，但是越不稳定。<br />
            Continuous serial port buffer data detection interval, the default 20ms, the smaller the value, the faster the communication, but the more unstable.
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.IsClearCacheBeforeRead">
            <summary>
            是否在发送数据前清空缓冲数据，默认是false<br />
            Whether to empty the buffer before sending data, the default is false
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.PortName">
            <summary>
            当前连接串口信息的端口号名称<br />
            The port name of the current connection serial port information
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialBase.BaudRate">
            <summary>
            当前连接串口信息的波特率<br />
            Baud rate of current connection serial port information
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Dispose(System.Boolean)">
            <summary>
            释放当前的对象
            </summary>
            <param name="disposing">是否在</param>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.Dispose">
            <summary>
            释放当前的对象
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SerialBase.ToString">
            <inheritdoc/>
        </member>
        <member name="F:HslCommunication.Serial.SerialBase.sP_ReadData">
            <summary>
            串口交互的核心
            </summary>
        </member>
        <member name="T:HslCommunication.Serial.SerialDeviceBase">
            <summary>
            串口设备交互类的基类，实现了<see cref="T:HslCommunication.Core.IReadWriteNet"/>接口的基础方法方法，需要使用继承重写来实现字节读写，bool读写操作。<br />
            The base class of the serial device interaction class, which implements the basic methods of the <see cref="T:HslCommunication.Core.IReadWriteNet"/> interface, 
            requires inheritance rewriting to implement byte read and write, and bool read and write operations.
            </summary>
            <remarks>
            本类实现了不同的数据类型的读写交互的api，继承自本类，重写下面的四个方法将可以实现你自己的设备通信对象
            <list type="number">
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Read(System.String,System.UInt16)"/> 方法，读取字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Byte[])"/> 方法，写入字节数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String,System.UInt16)"/> 方法，读取bool数组的方法。
            </item>
            <item>
            <see cref="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean[])"/> 方法，写入bool数组的方法。
            </item>
            </list>
            如果需要实现异步的方法。那就需要重写下面的四个方法。
            <list type="number">
            <item>
            <see cref="!:ReadAsync(string, ushort)"/> 方法，读取字节数组的方法。
            </item>
            <item>
            <see cref="!:WriteAsync(string, byte[])"/> 方法，写入字节数组的方法。
            </item>
            <item>
            <see cref="!:ReadBoolAsync(string, ushort)"/> 方法，读取bool数组的方法。
            </item>
            <item>
            <see cref="!:WriteAsync(string, bool[])"/> 方法，写入bool数组的方法。
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.#ctor">
            <summary>
            默认的构造方法实现的设备信息
            </summary>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.ByteTransform">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ByteTransform"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.ConnectionId">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDoubleBase.ConnectionId"/>
        </member>
        <member name="P:HslCommunication.Serial.SerialDeviceBase.WordLength">
            <inheritdoc cref="P:HslCommunication.Core.Net.NetworkDeviceBase.WordLength"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Read(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Byte[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Byte[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadBool(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadBool(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Boolean)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Boolean)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadCustomer``1(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadCustomer``1(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.WriteCustomer``1(System.String,``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.WriteCustomer``1(System.String,``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Read``1">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Read``1"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write``1(``0)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write``1(``0)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt16(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt16(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt32(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt32(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloat(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadFloat(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadFloat(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadUInt64(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadUInt64(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDouble(System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadDouble(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadDouble(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadString(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ReadString(System.String,System.UInt16,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.ReadString(System.String,System.UInt16,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt16[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt16)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt16)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt32[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Single[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Single)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Single)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Int64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Int64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt64[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.UInt64)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.UInt64)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Double[])">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double[])"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.Double)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.Double)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Int32)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.Write(System.String,System.String,System.Int32,System.Text.Encoding)">
            <inheritdoc cref="M:HslCommunication.Core.IReadWriteNet.Write(System.String,System.String,System.Int32,System.Text.Encoding)"/>
        </member>
        <member name="M:HslCommunication.Serial.SerialDeviceBase.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Serial.SoftLRC">
            <summary>
            用于LRC验证的类，提供了标准的验证方法<br />
            The class used for LRC verification provides a standard verification method
            </summary>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.LRC(System.Byte[])">
            <summary>
            获取对应的数据的LRC校验码<br />
            Class for LRC validation that provides a standard validation method
            </summary>
            <param name="value">需要校验的数据，不包含LRC字节</param>
            <returns>返回带LRC校验码的字节数组，可用于串口发送</returns>
        </member>
        <member name="M:HslCommunication.Serial.SoftLRC.CheckLRC(System.Byte[])">
            <summary>
            检查数据是否符合LRC的验证<br />
            Check data for compliance with LRC validation
            </summary>
            <param name="value">等待校验的数据，是否正确</param>
            <returns>是否校验成功</returns>
        </member>
        <member name="T:HslCommunication.StringResources">
            <summary>
            系统的字符串资源及多语言管理中心<br />
            System string resource and multi-language management Center
            </summary>
        </member>
        <member name="F:HslCommunication.StringResources.Language">
            <summary>
            获取或设置系统的语言选项<br />
            Gets or sets the language options for the system
            </summary>
        </member>
        <member name="M:HslCommunication.StringResources.SetLanguageChinese">
            <summary>
            将语言设置为中文<br />
            Set the language to Chinese
            </summary>
        </member>
        <member name="M:HslCommunication.StringResources.SeteLanguageEnglish">
            <summary>
            将语言设置为英文<br />
            Set the language to English
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient">
            <summary>
            websocket协议的客户端实现，支持从服务器订阅，发布数据内容信息，详细参考api文档信息<br />
            Client implementation of the websocket protocol. It supports subscribing from the server and publishing data content information.
            </summary>
            <example>
            本客户端使用起来非常的方便，基本就是实例化，绑定一个数据接收的事件即可，如下所示
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample1" title="简单的实例化" />
            假设我们需要发数据给服务端，那么可以参考如下的方式
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample2" title="发送数据" />
            如果我们需要搭配服务器来做订阅推送的功能的话，写法上会稍微有点区别，按照下面的代码来写。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample3" title="订阅操作" />
            当网络发生异常的时候，我们需要这么来进行重新连接。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketClientSample.cs" region="Sample4" title="异常重连" />
            </example>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String,System.Int32)">
            <summary>
            使用指定的ip，端口来实例化一个默认的对象
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String,System.Int32,System.String)">
            <summary>
            使用指定的ip，端口，额外的url信息来实例化一个默认的对象
            </summary>
            <param name="ipAddress">Ip地址信息</param>
            <param name="port">端口号信息</param>
            <param name="url">额外的信息，比如 /A/B?C=123456</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.#ctor(System.String)">
            <summary>
            使用指定的url来实例化一个默认的对象，例如 ws://127.0.0.1:1883/A/B?C=123456
            </summary>
            <param name="url">完整的ws地址</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectServer(System.String[])">
            <summary>
            连接服务器，实例化客户端之后，至少要调用成功一次，如果返回失败，那些请过一段时间后重新调用本方法连接。<br />
            After connecting to the server, the client must be called at least once after instantiating the client.
            If the return fails, please call this method to connect again after a period of time.
            </summary>
            <param name="subscribes">订阅的消息</param>
            <returns>连接是否成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ConnectClose">
            <summary>
            关闭Mqtt服务器的连接。<br />
            Close the connection to the Mqtt server.
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.SendServer(System.String)">
            <summary>
            发送数据到WebSocket的服务器<br />
            Send data to WebSocket server
            </summary>
            <param name="message">消息</param>
            <returns>是否发送成功</returns>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient.OnClientApplicationMessageReceiveDelegate">
            <summary>
            websocket的消息收到委托<br />
            websocket message received delegate
            </summary>
            <param name="message">websocket的消息</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnClientApplicationMessageReceive">
             <summary>
             websocket的消息收到时触发<br />
             Triggered when a websocket message is received
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketClient.OnClientConnectedDelegate">
            <summary>
            连接服务器成功的委托<br />
            Connection server successfully delegated
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnClientConnected">
            <summary>
            当客户端连接成功触发事件，就算是重新连接服务器后，也是会触发的<br />
            The event is triggered when the client is connected successfully, even after reconnecting to the server.
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketClient.OnNetworkError">
            <summary>
            当网络发生异常的时候触发的事件，用户应该在事件里进行重连服务器
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.ConnectTimeOut">
            <summary>
            获取或设置当前客户端的连接超时时间，默认10,000毫秒，单位ms<br />
            Gets or sets the connection timeout of the current client. The default is 10,000 milliseconds. The unit is ms.
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketClient.IsClosed">
            <summary>
            获取当前的客户端状态是否关闭了连接，当自己手动处理网络异常事件的时候，在重连之前就需要判断是否关闭了连接。<br />
            Obtain whether the current client status has closed the connection. When manually handling network abnormal events, you need to determine whether the connection is closed before reconnecting.
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketClient.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketHelper">
            <summary>
            websocket的相关辅助的方法
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.CalculateWebscoketSha1(System.String)">
            <summary>
            计算websocket返回得令牌
            </summary>
            <param name="webSocketKey">请求的令牌</param>
            <returns>返回的令牌</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetSecKeyAccetp(System.String)">
            <summary>
            根据http网页的信息，计算出返回的安全令牌
            </summary>
            <param name="httpGet">网页信息</param>
            <returns>返回的安全令牌</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.CheckWebSocketLegality(System.String)">
            <summary>
            检测当前的反馈对象是否是标准的websocket请求
            </summary>
            <param name="httpGet">http的请求内容</param>
            <returns>是否验证成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetWebSocketSubscribes(System.String)">
            <summary>
            检测当前的反馈对象是否是标准的websocket请求
            </summary>
            <param name="httpGet">http的请求内容</param>
            <returns>是否验证成功</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.GetResponse(System.String)">
            <summary>
            获取初步握手的时候的完整返回的数据信息
            </summary>
            <param name="httpGet">请求的网页信息</param>
            <returns>完整的返回信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsSubRequest(System.String,System.Int32,System.String,System.String[])">
            <summary>
            创建连接服务器的http请求，输入订阅的主题信息
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">远程服务器的端口号</param>
            <param name="url">参数信息</param>
            <param name="subscribes">通知hsl的服务器，需要订阅的topic信息</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsQARequest(System.String,System.Int32)">
            <summary>
            创建连接服务器的http请求，采用问答的机制
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">远程服务器的端口号</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.BuildWsRequest(System.String,System.Int32,System.String,System.String)">
            <summary>
            根据额外的参数信息，创建新的websocket的请求信息
            </summary>
            <param name="ipAddress">ip地址</param>
            <param name="port">端口号</param>
            <param name="url">跟在端口号后面的额外的参数信息</param>
            <param name="extra">额外的参数信息</param>
            <returns>报文信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.WebScoketPackData(System.Int32,System.Boolean,System.String)">
            <summary>
            将普通的文本信息转换成websocket的报文
            </summary>
            <param name="opCode">操作信息码</param>
            <param name="isMask">是否使用掩码</param>
            <param name="message">等待转换的数据信息</param>
            <returns>数据包</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketHelper.WebScoketPackData(System.Int32,System.Boolean,System.Byte[])">
            <summary>
            将普通的文本信息转换成websocket的报文
            </summary>
            <param name="opCode">操作信息码</param>
            <param name="isMask">是否使用掩码</param>
            <param name="payload">等待转换的数据信息</param>
            <returns>数据包</returns>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketMessage">
            <summary>
            websocket 协议下的单个消息的数据对象<br />
            Data object for a single message under the websocket protocol
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.HasMask">
            <summary>
            是否存在掩码<br />
            Whether a mask exists
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.OpCode">
            <summary>
            当前的websocket的操作码<br />
            The current websocket opcode
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketMessage.Payload">
            <summary>
            负载数据
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketMessage.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketQANet">
            <summary>
            WebSocket的问答机制的客户端，本客户端将会在请求头上追加 RequestAndAnswer: true，本客户端将会请求服务器的信息，然后等待服务器的返回<br />
            Client of WebSocket Q &amp; A mechanism, this client will append RequestAndAnswer: true to the request header, this client will request the server information, and then wait for the server to return
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.#ctor(System.String,System.Int32)">
            <summary>
            根据指定的ip地址及端口号，实例化一个默认的对象<br />
            Instantiates a default object based on the specified IP address and port number
            </summary>
            <param name="ipAddress">远程服务器的ip地址</param>
            <param name="port">端口号信息</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.InitializationOnConnect(System.Net.Sockets.Socket)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromCoreServer(System.Net.Sockets.Socket,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ReadFromServer(System.String)">
            <summary>
            和websocket的服务器交互，将负载数据发送到服务器端，然后等待接收服务器的数据<br />
            Interact with the websocket server, send the load data to the server, and then wait to receive data from the server
            </summary>
            <param name="payload">数据负载</param>
            <returns>返回的结果数据</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketQANet.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer">
            <summary>
            WebSocket协议的实现，支持创建自定义的websocket服务器，直接给其他的网页端，客户端，手机端发送数据信息，详细看api文档说明<br />
            The implementation of the WebSocket protocol supports the creation of custom websocket servers and sends data information directly to other web pages, clients, and mobile phones. See the API documentation for details.
            </summary>
            <example>
            使用本组件库可以非常简单方便的构造属于你自己的websocket服务器，从而实现和其他的客户端进行通信，尤其是和网页进行通讯，
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample1" title="简单的实例化" />
            当客户端发送数据给服务器的时候，会发一个事件，并且把当前的会话暴露出来，下面举例打印消息，并且演示一个例子，发送数据给指定的会话。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample2" title="接触数据" />
            也可以在其他地方发送数据给所有的客户端，只要调用一个方法就可以了。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample3" title="发送数据" />
            当客户端上线之后也触发了当前的事件，我们可以手动捕获到
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample4" title="捕获上线事件" />
            我们再来看看一个高级的操作，实现订阅，大多数的情况，websocket被设计成了订阅发布的操作。基本本服务器可以扩展出非常复杂功能的系统，我们来看一种最简单的操作。
            <br />
            客户端给服务器发的数据都视为主题(topic)，这样服务器就可以辨认出主题信息，并追加主题。如下这么操作。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample5" title="订阅实现" />
            然后在发布的时候，调用下面的代码。
            <code lang="cs" source="HslCommunication_Net45.Test\Documentation\Samples\WebSocket\WebSocketServerSample.cs" region="Sample6" title="发布数据" />
            可以看到，我们这里只有订阅操作，如果想要实现更为复杂的操作怎么办？丰富客户端发来的数据，携带命令，数据，就可以区分了。比如json数据。具体的实现需要看各位能力了。
            </example>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.#ctor">
            <summary>
            实例化一个默认的对象<br />
            Instantiate a default object
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ServerStart(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ThreadPoolLogin(System.Net.Sockets.Socket,System.Net.IPEndPoint)">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer.OnClientApplicationMessageReceiveDelegate">
            <summary>
            websocket的消息收到委托<br />
            websocket message received delegate
            </summary>
            <param name="session">当前的会话对象</param>
            <param name="message">websocket的消息</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientApplicationMessageReceive">
             <summary>
             websocket的消息收到时触发<br />
             Triggered when a websocket message is received
            </summary>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketServer.OnClientConnectedDelegate">
            <summary>
            当前websocket连接上服务器的事件委托<br />
            Event delegation of the server on the current websocket connection
            </summary>
            <param name="session">当前的会话对象</param>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientConnected">
            <summary>
            Websocket的客户端连接上来时触发<br />
            Triggered when a Websocket client connects
            </summary>
        </member>
        <member name="E:HslCommunication.WebSocket.WebSocketServer.OnClientDisConnected">
            <summary>
            Websocket的客户端下线时触发<br />
            Triggered when Websocket client connects
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.StartInitialization">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.CloseAction">
            <inheritdoc/>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishAllClientPayload(System.String)">
            <summary>
            向所有的客户端强制发送消息<br />
            Force message to all clients
            </summary>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.PublishClientPayload(System.String,System.String)">
            <summary>
            向订阅了topic主题的客户端发送消息<br />
            Send messages to clients subscribed to topic
            </summary>
            <param name="topic">主题</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.SendClientPayload(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            向指定的客户端发送数据<br />
            Send data to the specified client
            </summary>
            <param name="session">会话内容</param>
            <param name="payload">消息内容</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.AddSessionTopic(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            给一个当前的会话信息动态添加订阅的主题<br />
            Dynamically add subscribed topics to a current session message
            </summary>
            <param name="session">会话内容</param>
            <param name="topic">主题信息</param>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.OnlineCount">
            <summary>
            获取当前的在线的客户端数量<br />
            Get the current number of online clients
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.IsTopicRetain">
            <summary>
            获取或设置当前的服务器是否对订阅主题信息缓存，方便订阅客户端立即收到结果，默认开启<br />
            Gets or sets whether the current server caches the topic information of the subscription, so that the subscription client can receive the results immediately. It is enabled by default.
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.OnlineSessions">
            <summary>
            获取当前的在线的客户端信息，可以用于额外的分析或是显示。
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.KeepAlivePeriod">
            <summary>
            设置的参数，最小单位为1s，当超过设置的时间间隔必须回复PONG报文，否则服务器认定为掉线。默认120秒<br />
            Set the minimum unit of the parameter is 1s. When the set time interval is exceeded, the PONG packet must be returned, otherwise the server considers it to be offline. 120 seconds by default
            </summary>
            <remarks>
            保持连接（Keep Alive）是一个以秒为单位的时间间隔，它是指客户端返回一个PONG报文到下一次返回PONG报文的时候，
            两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。
            </remarks>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketServer.KeepAliveSendInterval">
            <summary>
            获取或是设置用于保持连接的心跳时间的发送间隔。默认30秒钟，需要在服务启动之前设置<br />
            Gets or sets the sending interval of the heartbeat time used to keep the connection. 30 seconds by default, need to be set before the service starts
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.RemoveAndCloseSession(HslCommunication.WebSocket.WebSocketSession,System.String)">
            <summary>
            让Websocket客户端正常下线，调用本方法即可自由控制会话客户端强制下线操作。<br />
            Let the Websocket client go offline normally. Call this method to freely control the session client to force offline operation.
            </summary>
            <param name="session">当前的会话信息</param>
            <param name="reason">下线的原因，默认为空</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketServer.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.WebSocket.WebSocketSession">
            <summary>
            websocket 的会话客户端
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.#ctor">
            <summary>
            实例化一个默认的对象
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.ActiveTime">
            <summary>
            当前客户端的激活时间
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.OnlineTime">
            <summary>
            获取当前的客户端的上线时间
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.WsSocket">
            <summary>
            当前客户端绑定的套接字对象
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Topics">
            <summary>
            当前客户端订阅的所有的Topic信息
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Remote">
            <summary>
            远程的客户端的ip及端口信息
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.IsQASession">
            <summary>
            当前的会话是否是问答客户端，如果是问答客户端的话，数据的推送是无效的。
            </summary>
        </member>
        <member name="P:HslCommunication.WebSocket.WebSocketSession.Url">
            <summary>
            客户端请求的url信息，可能携带一些参数信息
            </summary>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.IsClientSubscribe(System.String)">
            <summary>
            检查当前的连接对象是否在
            </summary>
            <param name="topic">主题信息</param>
            <returns>是否包含的结果信息</returns>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.AddTopic(System.String)">
            <summary>
            动态增加一个订阅的信息
            </summary>
            <param name="topic">订阅的主题</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.RemoveTopic(System.String)">
            <summary>
            动态移除一个订阅的信息
            </summary>
            <param name="topic">订阅的主题</param>
        </member>
        <member name="M:HslCommunication.WebSocket.WebSocketSession.ToString">
            <inheritdoc/>
        </member>
        <member name="T:HslCommunication.Properties.Resources">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.abstr1">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.abstr11">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Activity_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.AddressViewer">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.alipay">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.asset_progressBar_24x24_on">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.asset_progressBar_24x24_on1">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.AudioRecording">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.brackets_Square_16xMD">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Class_489">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ClassIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Cloud_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Copy_6524">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Delegate_8339">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.docview_xaml_on_16x16">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Enum_582">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Event_594">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Event_594_exp">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.glasses_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.grid_Data_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.lightningBolt_16xLG">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.ListView_687">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Method_636">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.mm_facetoface_collect_qrcode_1525331158525">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Module_648">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.PropertyIcon">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.qrcode_for_gh_319218678954_258">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Soundfile_461">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Structure_507">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.TabControl_707">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Table_748">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Tag_7213">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.Textfile_818_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.TreeView_713">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.usbcontroller">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.UseCaseDiagramFile_usecasediagram_13447_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.VirtualMachine">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.WebFormTemplate_11274_16x_color">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
        <member name="P:HslCommunication.Properties.Resources.WindowsForm_817_16x">
            <summary>
              查找 System.Drawing.Bitmap 类型的本地化资源。
            </summary>
        </member>
    </members>
</doc>
